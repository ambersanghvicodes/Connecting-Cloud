/*global define*/
/*jslint browser: true*/
define('RevisionsServerProxy',['jquery', 'Utility'],
    function($, utility) {
        "use strict";
        return {
            getInitData: function(ownerId, quoteId, callback) {
                $.get("/api/rd/v1/Revisions/GetInitData", { cryptedOwnerId: ownerId, cryptedQuoteId: quoteId }, callback);
            },
            getRevisions: function(ownerId, quoteId, callback) {
                $.get("/api/rd/v1/Revisions/GetRevisions", { cryptedOwnerId: ownerId, cryptedQuoteId: quoteId }, callback);
            },
            viewQuote: function (ownerId, quoteId) {
                var url = utility.buildUrl("/Quotation/QuoteView.aspx", { OwnerId: ownerId, CartId: quoteId });
                utility.showLoaderAndOverlay();
                window.location = url;
                return false;
            },
            quoteHistory: function (ownerId, quoteId) {
                var url = utility.buildUrl("/Quotation/CartHistory.aspx", { rc: quoteId, ro: ownerId });
                utility.showLoaderAndOverlay();
                window.location = url;
            },
            executeAction: function (data, callback) {
                utility.postJson("/api/rd/v1/Revisions/ExecuteAction", data, callback);
            },
            updateRevisions: function (revisions, cryptedOwnerId, cryptedQuoteId, callback) {
                utility.showLoaderAndOverlay();
                utility.postJson("/api/rd/v1/Revisions/UpdateRevisions?cryptedOwnerId=" + cryptedOwnerId + "&cryptedQuoteId=" + cryptedQuoteId, revisions, callback);
                utility.hideLoaderAndOverlay();
            },
            getCurrentRevision: function(callback) {
                $.get("/api/rd/v1/Revisions/GetCurrentRevision", {}, callback);
            },
            renameRevision: function (cryptedOwnerId, cryptedQuoteId, newName, callback) {
                $.get("/api/rd/v1/Revisions/RenameRevision", { cryptedOwnerId: cryptedOwnerId, cryptedQuoteId: cryptedQuoteId, newName: newName }, callback);
            }
        };
    });
define('CustomerFeedbackServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        var baseUrl = "/api/rd/v1/CustomerFeedback/";
        return {

            getData: function (callback) {
                $.getJSON(baseUrl + 'GetData', callback);
            },
            getUnreadCount: function (callback) {
                $.getJSON(baseUrl + 'GetUnreadCount', callback);
            },
            save: function (commentText, itemNumber, callback, errorcallback) {
                utility.postJson(baseUrl + 'SaveComment', { CommentText: commentText, ItemNumber: itemNumber }, callback, errorcallback);
            },

            deleteComment: function (commentId, callback) {
                utility.postJson(utility.buildUrl(baseUrl + "DeleteComment", { id: commentId }), callback);
            }
            //changeDiscount: function (changeDiscountRequest, callback) {
            //    utility.postJson(baseUrl + "ChangeDiscount", changeDiscountRequest, callback);
            //},
            //addProduct: function (addProductRequest, callback) {
            //    utility.postJson(baseUrl + "AddProduct", addProductRequest, callback);
            //},
            //decline: function (itemData, callback) {
            //    utility.postJson('/api/rd/v1/Recommendations/Decline', itemData, callback);
            //}
        };
    });

define('CustomerFeedbackModel',['jquery', 'knockout', 'Toastr', 'Utility', 'CustomerFeedbackServerProxy', 'moment', 'underscore', 'mediator-js'],
    function ($, ko, toastr, utility, serverProxy, moment, _, mediator) {
        "use strict";

        return function () {
            var self = this;
            var getDataCallback, CartCommentFactory, ItemCommentFactory, CommentFactory, showCustomerFeedback, EmptyCartCommentFactory, GroupCommentFactory, errorcallback;

            self.clmProviderEnabled = ko.observable(false);
            self.inProgress = ko.observable(false);
            self.totalCount = ko.observable(0);
            self.cartCommentsSection = ko.observableArray([]);
            self.itemCommentsSection = ko.observableArray([]);
            self.scrollPosition = 0;
            self.cartItem = ko.observable();

            self.customerFeedbackTitle = ko.computed(function () {
                return self.customerFeedbackTitleText + " (" + self.totalCount() + ")";
            });

            self.reset = function() {
                self.cartItem = ko.observable();
            };

            mediator.subscribe("API:lineItems:AddCollaborationComment", function (data) {
                self.cartItem(data.item);
                if (!$('#sidebar').length) {
                    self.showCustomerFeedbackInternal();
                }
            });

            self.showCustomerFeedback = function (data) {
                self.cartItem = ko.observable();
                self.showCustomerFeedbackInternal();
            };

            self.showCustomerFeedbackInternal = function() {
                self.inProgress(true);
                serverProxy.getData(function(serverData) {
                    getDataCallback(serverData);
                    showCustomerFeedback();
                    self.scrollToBottom();
                });
            };

            self.scrollToBottom = function() {
                var $collaborationContainer = $('#collaborationMessageContainer');
                if ($collaborationContainer.length > 0) {
                    $collaborationContainer[0].scrollTop = $collaborationContainer[0].scrollHeight;
                }
            };

            self.closeCustomerFeedback = function () {
                self.totalCount(0);
                if (self.sidebar) {
                    self.sidebar.removeClass('slide-in');
                    self.sidebar.addClass('slide-out');

                    setTimeout(function () {
                        self.sidebar.toggleClass('hidden');
                        self.closeModal();
                    }, 300);
                }
            };

            self.reply = function (commentSection) {
                commentSection.isReplying(!commentSection.isReplying());
                $('textarea').focus();
            };

            self.save = function (commentSection) {
				if (commentSection.messageText().length === 0) {
					return;
				}
                commentSection.isReplying(!commentSection.isReplying());
                var commentText = commentSection.messageText();
                var itemNumber = undefined;
                if (commentText) {                   
                    if ($('#collaborationMessageContainer') && $('#collaborationMessageContainer')[0]) {
                        self.scrollPosition = $('#collaborationMessageContainer')[0].scrollHeight;
                    }
                    if (self.cartItem()) {
                        itemNumber = self.cartItem().id;
                        self.cartItem = ko.observable();
                    }
                    
                    serverProxy.save(commentText, itemNumber, getDataCallback, errorcallback);
                }
            };


            self.deselectItemComment = function() {
                self.cartItem(null);
            };

            // entry point
            self.initialize = function (cartCompositeNumber, cartRevisionNumber) {
                self.inProgress(true);
                serverProxy.getUnreadCount(function (serverData) {
                    self.totalCount(serverData.NumberOfUnread);
                    self.inProgress(false);
                });
            };

            getDataCallback = function (serverData) {
                if (serverData.ErrorMessage) {
                    toastr.error(serverData.ErrorMessage);
                    self.cartCommentsSection(new EmptyCartCommentFactory());
                } else {
                    self.cartCommentsSection(new CartCommentFactory(serverData));
                }

                self.inProgress(false);
                self.scrollToBottom();
                self.setupAccessiblity();
            };

            errorcallback = function(xhr, status, error) {
                var that = this;

                self.showCustomerFeedback();
                that.isReplying = ko.observable(false);
                that.messageText = ko.observable("");
            };

            EmptyCartCommentFactory = function () {
                var that = this;

                that.isReplying = ko.observable(false);
                that.messageText = ko.observable("");
                that.cartComments = ko.observableArray([]);
            };

            CartCommentFactory = function (serverData) {
                var that = this;

                that.isReplying = ko.observable(false);
                that.messageText = ko.observable("");
                that.groupCartComments = ko.observableArray([]);

                var groupedComments = _.groupBy(serverData, function (data) {
                    return data.Comment.DateCreated;
                });

                _.each(groupedComments,
                    function(value, key) {
                        that.groupCartComments().push(new GroupCommentFactory(key, value));
                    });
            };

            GroupCommentFactory = function (dateCreated, row) {
                var that = this;
                that.todayDate = ko.observable(moment().format(utility.dateFormat));
                that.dateCreated = ko.observable(dateCreated);
                that.comments = ko.observableArray([]);
                utility.rebuildObservableArray(that.comments, row, CommentFactory);
            };

            CommentFactory = function (serverData) {
                var that = this;

                that.id = ko.observable(serverData.Comment.Id);
                that.isMyComment = ko.observable(serverData.Comment.IsMyComment);
                that.userFullName = ko.observable(serverData.Comment.UserFullName);
                that.userEmail = ko.observable(serverData.Comment.UserEmail);
                that.userCompany = ko.observable(serverData.Comment.UserCompany);
                that.commentText = ko.observable(serverData.Comment.CommentText);
                that.isLineItemComment = ko.observable(serverData.IsLineItemComment);
                that.lineItemTitle = ko.observable(serverData.LineItemTitle);
                that.commentTime = ko.observable(serverData.Comment.TimeCreated);

                that.userTitle = ko.computed(function () {
                    return that.userFullName() + ' (' + that.userEmail() + ')';
                });

                that.deleteComment = function () {
	                var deleteButtons = $(".feedback-delete-comment");
	                var length = deleteButtons.length;
	                var index = -1;
	                for (var i = 0; i < length; i++) {
						if (deleteButtons[i].id == 'deleteComment_' + that.id()) {
							index = i;
						}
					}
	                var isItLast = index === (length - 1);
	                
					if (length == 1) {
						window.lastActiveElementId = "replyTextarea";
					} else {
						if (isItLast) {
							window.lastActiveElementId = deleteButtons[index - 1].id;
						} else {
							window.lastActiveElementId = deleteButtons[index + 1].id;
						}
					}
	                
	                self.scrollPosition = $('#collaborationMessageContainer').scrollTop();
                    serverProxy.deleteComment(that.id(), getDataCallback);
                };
            };

            showCustomerFeedback = function () {
                var $el, $modal;
                $el = $("<div>");
                $('body').append($el);
                ko.renderTemplate('customerFeedbackDialogTemplate', self, null, $el.get(0));
                $modal = $el.children(":first");

                self.closeModal = function () {
                    $el.remove();
                };
               
                self.sidebar = $('#sidebar');

                if (self.sidebar && self.sidebar.hasClass('hidden')) {
                    self.sidebar.toggleClass('slide-out');
                    self.sidebar.toggleClass('slide-in');

                    if (self.sidebar.hasClass('slide-out')) {
                        setTimeout(function () {
                            self.sidebar.toggleClass('hidden');
                        }, 300);
                    } else {
                        self.sidebar.toggleClass('hidden');
                    }
                }

                self.setupAccessiblity();
            };

            self.openCustomerComments = function(event, data) {
				if (event.key === 'NumpadEnter' || event.key === 'Enter') {
					window.lastActiveElementId = "customerCommentsTitle";
					self.showCustomerFeedback();
				}
            };

            self.closeCustomerComments = function(event, data) {
	            if (event.key === 'NumpadEnter' || event.key === 'Enter') {
		            self.closeCustomerFeedback();
					if (window.lastActiveItemActionRowId) {
						window.lastActiveElementId = window.lastActiveItemActionRowId;
						window.lastActiveItemActionRowId = null;
					} else {
						window.lastActiveElementId = "customerComments";
					}
		            mediator.publish('customerCommentsModal.activateFocus');
		            window.lastActiveElementId = "";
	            }
            };

            self.removeItemComment = function(event, data) {
				if (event.key === 'NumpadEnter' || event.key === 'Enter') {
					self.cartItem(null);
					window.lastActiveElementId = "replyTextarea";
					mediator.publish('customerCommentsModal.activateFocus');
				}
            };

            self.setupAccessiblity = function () {
                $('#replyTextarea').focus();

                var focusables = utility.getAllFocusableElements('#sidebar');
                $(focusables).each(function (index, element) {
                    $(element).on('keydown', function (event) {
                        if (event.key === "Escape" || event.key === "Esc") {
                            self.closeCustomerFeedback();
                            $('#customerComments').focus();
                        };
                    });
                });

                utility.makeFocusTrap('#sidebar');
            };

			self.focusTabHandler = function(currentElement, nextElement) {
				utility.focusTabHandler(currentElement, nextElement);
			};

			self.focusShiftTabHandler = function(currentElement, nextElement) {
				utility.focusShiftTabHandler(currentElement, nextElement);
			};

			mediator.subscribe('customerCommentsModal.activateFocus', function() {
				utility.focusLastActiveElementByIdIfExists();
			});

            mediator.subscribe('cartItemsModel.itemDeleted', function() {
                if (self.sidebar && !self.sidebar.hasClass("hidden")) {
                    self.showCustomerFeedback();
                }
            });
        };
    });

/*global define, requirejs*/
/*jslint browser: true*/
define('CartTabs',['knockout', 'Utility', 'RevisionsServerProxy', 'CustomerFeedbackModel', 'mediator-js'],
    function (ko, utility, revisionsServerProxy, CustomerFeedbackModelFactory, mediator) {
        "use strict";
        return function () {
            var self = this;

            self.title = ko.observable('');
            self.tabs = ko.observableArray();
            self.currentTabName = ko.observable('');
            self.customerFeedback = new CustomerFeedbackModelFactory();
            self.init = function (serverTabsData) {
                if (!serverTabsData) return;
                self.title(serverTabsData.Title);
                self.currentTabName(serverTabsData.CurrentTabName);
                self.customerFeedback.initialize();
                self.customerFeedback.clmProviderEnabled(serverTabsData.ClmProviderEnabled);
                utility.rebuildObservableArray(self.tabs, serverTabsData.Tabs, function (serverTab) {
                    this.name = serverTab.Name;
                    this.url = serverTab.Url;
                    this.active = serverTab.Active;
                    this.onTabChange = function () {
                        if (window.location.pathname === '/quotation/Cart.aspx') {
                            mediator.publish("CartTabs.TabChanged", serverTab.Url);
                        } else {
                            window.location.href = serverTab.Url;
                        }
                    };
                });
            };
            self.reloadOnCustomFieldsChange = function (customFieldsData) {
            	var TabsData = {
            		Tabs: customFieldsData.model.tabsData.tabs(),
            		Title: customFieldsData.model.tabsData.title(),
            		CurrentTabName: customFieldsData.model.tabsData.currentTabName()
            	};
            	TabsData.Tabs = TabsData.Tabs.map(function (data) {
            		return {
            			Name: data.name,
            			Url: data.url,
            			Active: data.active
            		};
            	});
            	self.init(TabsData);
            };

            var selectedRevision = ko.observable();
            self.selectedRevision = function() {
                if (!selectedRevision()) {
                    revisionsServerProxy.getCurrentRevision(function(revisionServerData) {
                        selectedRevision(revisionServerData);
                    });
                }
                return selectedRevision();
            };
        };
    }
);

/*global define*/
/*jslint browser: true*/
define('CartServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getInitDataUrl: "/api/rd/v1/Cart/GetInitData",

            getAutoCompleteSourceTableValuesUrl: "/api/rd/v1/Cart/GetAutoCompleteSourceTableValues",

            getAutoCompleteSubscriptionFieldsUrl: "/api/rd/v1/Cart/GetAutoCompleteSubscriptionFields",

            getInitData: function (mode, ownerId, cartId, avc, callback) {
                $.getJSON(this.getInitDataUrl, { mode: mode, ownerId: ownerId, cartId: cartId, avc: avc }, callback);
            },

            getItems: function (pageNumber, pageSize, filterQuery, cartItem, callback) {
                $.getJSON('/api/rd/v1/Cart/GetItems', { pageNumber: pageNumber, pageSize: pageSize, filterQuery: filterQuery, CartItem: cartItem }, callback);
            },
            
            getItemsPost: function (pageNumber, pageSize, filterQuery, cartItem, callback) {
                utility.postJson(utility.buildUrl('/api/rd/v1/Cart/GetItemsPost'), { pageNumber: pageNumber, pageSize: pageSize, filterQuery: filterQuery, cartItem: cartItem }, callback);
            },

            crateViewRevisionsUrl: function (ownerIdCrypted, cartIdCrypted) {
                return utility.buildUrl("/Quotation/Revisions.aspx", { cr: 1, o: ownerIdCrypted, c: cartIdCrypted });
            },

            crateViewRevisionsUrlNewQuoteEngine: function (ownerIdCrypted, cartIdCrypted) {
                return utility.buildUrl("/Revisions/", { cr: 1, o: ownerIdCrypted, c: cartIdCrypted });
            },

            changeStatus: function (newStatusId, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeStatus", { newStatusId: newStatusId }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeMarket: function (newMarketId, itemsFilterQuery, callback, errorCallback) {
                utility.postJsonWithoutShowingToasterOnError(utility.buildUrl("/api/rd/v1/Cart/ChangeMarket", { newMarketId: newMarketId }), { itemsFilterQuery: itemsFilterQuery }, callback, errorCallback);
            },

            getProductsWithoutPricesForMarket: function (marketId, callback) {
                utility.get('/api/rd/v1/Cart/GetSbItemsWithoutMarketPrices', { marketId: marketId }, callback);
            },

            changePricebook: function (newPricebookId, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangePricebook", { newPricebookId: newPricebookId }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeEffectiveDate: function (newValue, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeEffectiveDate", { NewEffectiveDate: newValue }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeShipping: function (newShippingId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeShipping", { newShippingId: newShippingId }), callback);
            },

            saveCartComment: function (newValue, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/SaveCartComment", { comment: newValue }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            undo: function (callback) {
                utility.postJson("/api/rd/v1/Cart/Undo", callback);
            },

            redo: function (callback) {
                utility.postJson("/api/rd/v1/Cart/Redo", callback);
            },

            setActiveEditableGroup: function (editableGroup, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/SetActiveEditableGroup", { editableGroup: editableGroup }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            executeAction: function (actionId, cartUpdateParams, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ExecuteAction", { actionId: actionId }), cartUpdateParams, callback);
            },

            getProductsForUpgrade: function (callback) {
                $.getJSON("/api/rd/v1/Cart/GetProductsForUpgrade", callback);
            },

            getCartProductsUpgradeConfirmationMessage: function (callback) {
                $.getJSON("/api/rd/v1/Cart/GetCartProductsUpgradeConfirmationMessage", callback);
            },

            getCartItemProductUpgradeConfirmationMessage: function (cartItem, callback) {
                $.getJSON("/api/rd/v1/Cart/GetCartItemProductUpgradeConfirmationMessage", { cartItem: cartItem }, callback);
            },

            calculate: function (cartUpdateParams, callback) {
                utility.postJson("/api/rd/v1/Cart/Calculate", cartUpdateParams, callback);
            },

            navigateToCartList: function () {
                window.location.href = "/Quotation/LoadQuote.aspx";
            },

            navigateToConfigurator: function (section) {
                window.location.href = "/Configurator.aspx" + (section ? '?section=' + section : '');
            },

            crateNewAdditionalDiscount: function (cartUpdateParams, callback) {
                utility.postJson("/api/rd/v1/Cart/CrateNewAdditionalDiscount", cartUpdateParams, callback);
            },

            deleteAdditionalDiscount: function (discountId, cartUpdateParams, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/DeleteAdditionalDiscount", { discountId: discountId }), cartUpdateParams, callback);
            },

            executeItemAction: function (actionId, cartItem, itemsFilterQuery, itemId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ExecuteItemAction", { actionId: actionId, cartItem: cartItem, itemId: itemId }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            executeUpgradeItemAction: function (cartItem, itemId, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ExecuteUpgradeItemAction", { cartItem: cartItem, itemId: itemId }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            upgradeAndEditProduct: function (cartItem, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/UpgradeAndEditProduct", { cartItem: cartItem }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            cancelItemEdit: function () {
                utility.postJson("/api/rd/v1/Cart/CancelItemEdit");
            },

            moveItemUp: function (cartItem, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/MoveItemUp", { cartItem: cartItem }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            moveItemDown: function (cartItem, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/MoveItemDown", { cartItem: cartItem }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            moveToPosition: function (cartItem, upperCartItem, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/MoveToPosition", { cartItem: cartItem, upperCartItem: upperCartItem }), callback);
            },

            changeItemType: function (cartItem, newItemType, newBaseItem, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeItemType", { cartItem: cartItem, newItemType: newItemType, newBaseItem: newBaseItem }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeItemsType: function (cartItems, selectedItemType, itemsFilterQuery, callback) {
                utility.postJson("/api/rd/v1/Cart/ChangeItemsType", { CartItems: cartItems, ItemType: selectedItemType, ItemsFilterQuery: itemsFilterQuery }, callback);
            },

            addToQuote: function (productId, quantity, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/AddToQuote", { productId: productId, quantity: quantity }), { itemsFilterQuery: itemsFilterQuery },callback);
            },

            addToQuoteWithSection: function (productId, quantity, section, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/AddToQuoteWithSection", { productId: productId, quantity: quantity, section: section }), callback);
            },

            addFavoriteToQuote: function (favoriteId, quantity, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/AddFavoriteToQuote", { favoriteId: favoriteId, quantity: quantity }), { itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeApprovalProbability: function (sliderId, value, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeApprovalProbability", { sliderId: sliderId, value: value }), callback);
            },

            changeMarginHealth: function (margin, calculationMode, id, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeMarginHealth", { margin: margin, calculationMode: calculationMode, id: id }), callback);
            },

            deleteItems: function (cartItems, callback) {
                utility.postJson("/api/rd/v1/Cart/DeleteItems", cartItems, callback);
            },

            reorderItems: function (reorderItems, callback) {
                utility.postJson("/api/rd/v1/Cart/ReorderItems", reorderItems, callback);
            },

            getCustomFields: function (tabId, callback) {
                $.getJSON("/api/rd/v1/Cart/GetCustomFields", { tabId: tabId }, callback);
            },

            selectAutocompleteCustomField: function (scParamId, contentId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/SelectAutocompleteCustomField", { scParamId: scParamId, contentId: contentId }), callback);
            },

            saveCustomFields: function (dirtyCustomFields, callback) {
                utility.postJson("/api/rd/v1/Cart/SaveCustomFields", dirtyCustomFields, callback);
            },

            continueActionExecution: function (actionId, dirtyCustomFields, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ContinueActionExecution", { actionId: actionId }), dirtyCustomFields, callback);

            },

            approvalHistory: function (ownerId, cartId) {
                var url = utility.buildUrl("/Quotation/ApprovalHistory.aspx", { rc: cartId, ro: ownerId });
                window.location = url;
                return false;
            },

            getPartNumberSuggestions: function () {
                return "/api/rd/v1/Cart/GetPartNumberSuggestions?query=%QUERY";
            },

            saveFavoriteFromCart: function (cartItem, name, description, isSharedWithCompanyUsers, isSharedWithAllUsers, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/SaveFavoriteFromCart", {
                    cartItem: cartItem,
                    name: name,
                    description: description,
                    isSharedWithCompanyUsers: isSharedWithCompanyUsers,
                    isSharedWithAllUsers: isSharedWithAllUsers
                }), callback);
            },

            setCartItemComment: function (cartItem, comment, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/SetCartItemComment", { cartItem: cartItem, comment: comment }), callback);
            },

            navigateToFavoritesForProduct: function (prodId) {
                window.location.href = utility.buildUrl("/Favorites/Favorites.aspx", { productId: prodId });
            },

            getProductNameAndDescription: function (prodId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/GetProductNameAndDescription", { productId: prodId }), callback);
            },

            getPartialOrderInitialData: function (callback) {
                utility.postJson("/api/rd/v1/Cart/GetPartialOrderData", callback);
            },

            createPartialOrder: function (rowsSelection, callback) {
                utility.postJson("/api/rd/v1/Cart/CreatePartialOrder", rowsSelection, callback);
            },

            getPromotions: function (callback) {
                $.getJSON("/api/rd/v1/Cart/GetPromotions", callback);
            },

            applyPromotions: function (rowsSelection, callback) {
                utility.postJson("/api/rd/v1/Cart/ApplyPromotions", rowsSelection, callback);
            },

            navigateToNewCart: function () {
                window.location.href = "Cart.aspx";
            },

            expandItem: function (cartItem, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ExpandItem", { cartItem: cartItem }), callback);
            },

            expandAll: function (callback) {
                utility.postJson("/api/rd/v1/Cart/ExpandAll", callback);
            },

            collapseItem: function (cartItem, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/CollapseItem", { cartItem: cartItem }), callback);
            },

            collapseAll: function (callback) {
                utility.postJson("/api/rd/v1/Cart/CollapseAll", callback);
            },

            searchItems: function (search, callback) {
                $.getJSON('/api/rd/v1/Cart/SearchItems', { search: search }, callback);
            },

            copyQuoteTableRow: function (rowId, quoteTableId, tabId, reduced, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/CopyQuoteTableRow", { tabId: tabId, reduced: reduced }), { rowId: rowId, quoteTableId: quoteTableId, itemsFilterQuery: itemsFilterQuery }, callback);
            },

            deleteQuoteTableRow: function (rowId, quoteTableId, tabId, reduced, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/DeleteQuoteTableRow", { tabId: tabId, reduced: reduced }), { rowId: rowId, quoteTableId: quoteTableId, itemsFilterQuery: itemsFilterQuery }, callback);
            },

            changeQuoteTableCells: function (dirtyTables, tabId, reduced, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/ChangeQuoteTableCells", { tabId: tabId, reduced: reduced }), { dirtyQuoteTables: dirtyTables, itemsFilterQuery: itemsFilterQuery }, callback);
            },

            addQuoteTableRow: function (quoteTableId, tabId, reduced, itemsFilterQuery, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/AddQuoteTableRow", { tabId: tabId, reduced: reduced }), { quoteTableId: quoteTableId, itemsFilterQuery: itemsFilterQuery }, callback);
            },

            getQuoteTableRows: function (quoteTableId, pageNumber, pageSize, tabId, callback) {
                $.getJSON(utility.buildUrl("/api/rd/v1/Cart/GetQuoteTableRows", { quoteTableId: quoteTableId, pageNumber: pageNumber, pageSize: pageSize, tabId: tabId }), callback);
            },

            executeQuoteTableCustomAction: function (tabId, quoteTableId, actionId, reduced, callback) {
                utility.postJson("/api/rd/v1/Cart/ExecuteQuoteTableCustomAction", { tabId: tabId, quoteTableId: quoteTableId, actionId: actionId, reduced: reduced }, callback);
            },

            filterQuoteTableRows: function (quoteTableId, filters, pageNumber, pageSize, tabId, callback) {
                utility.postJson("/api/rd/v1/Cart/FilterQuoteTableRows", { quoteTableId: quoteTableId, filters: filters, pageNumber: pageNumber, pageSize: pageSize, tabId: tabId }, callback);
            },

            downloadQTDataTemplate: function (quoteTableId, onerror) {
                utility.download("/api/rd/v1/Cart/DownloadQTDataTemplate", { quoteTableId: quoteTableId }, null, onerror);
            },

            downloadQTEmptyTemplate: function (quoteTableId, onerror) {
                utility.download("/api/rd/v1/Cart/DownloadQTEmptyTemplate", { quoteTableId: quoteTableId }, null, onerror);
            },

            getLookups: function (url, callback) {
                utility.get(url, callback);
            },

            getSections: function (callback) {
                $.getJSON('/api/rd/v1/Cart/GetSections', callback);
            }
        };
    });

/*global define*/
define('CartCellAndFieldManager',['knockout', 'mediator-js', 'CartServerProxy', 'Utility', 'Slider', 'underscore'],
    function (ko, mediator, cartServerProxy, utility, SliderFactory, _) {
        "use strict";
        return function (isInViewMode, activeEditableGroup) {
            var self, CreateValueCell, CreateEditableCell, CreateMarginHealthCell, CreateMathCell,
                CreateMathDiscountCell, CreateItemTypeCell, CreateCustomFieldSummaryCell, editableCells, customFields, getItemTypeName, lastFocused, getCustomFieldTemplateName;

            function verifyResult(item, selectedRow) {
                return selectedRow.id === item.Id &&
                    selectedRow.text !== item.Values;
            }

            self = this;
            editableCells = [];
            customFields = [];
            // saves the selector required to refocus the last Element when autosave triggered a table reload.
            self.lastFocusedElemSelector = null;
            self.calculationModeProductTypes = 2;

            getItemTypeName = function(itemType) {
                switch (itemType) {
                    case 0:
                        return self.baseItemTypeMsg;
                    case 1:
                        return self.alternativeItemTypeMsg;
                    case 2:
                        return self.variantItemTypeMsg;
                    case 3:
                        return self.optionalItemTypeMsg;
                }
            };

            CreateValueCell = function (serverValue) {
                this.value = ko.observable(serverValue);
            };

            CreateValueCell.prototype.template = 'valueCellTemplate';

            self.formatId = function(id) {
	            var lastIndex = id.lastIndexOf("_");
				var formatedId = id.substring(0, lastIndex);
				return formatedId;
            };

            CreateMarginHealthCell = function (serverCell) {
                var that = this;
                that.id = serverCell.Id;
                that.calculationMode = serverCell.CalculationMode;
                that.imageUrl = serverCell.ImageUrl;
                that.color = serverCell.Color;
                that.isEditable = serverCell.IsEditable;

                if (that.isEditable) {
                    that.slider = new SliderFactory(serverCell.Slider, function () {
						if (that.calculationMode == self.calculationModeProductTypes) {
							mediator.publish("cartCellManager.applyMarginHealthValue", that.slider.value(), that.calculationMode, self.formatId(that.id));
						} else {
							mediator.publish("cartCellManager.applyMarginHealthValue", that.slider.value(), that.calculationMode, that.id);
						}
                    });
                }

                that.getSlider = function () {
                    return that.slider;
                };

                if (that.isEditable) {
                    that.template = 'marginHealthEditableCellTemplate';
                } else {
                    that.template = 'marginHealthReadonlyCellTemplate';
                }
            };

            CreateEditableCell = function (serverCell) {
                var that = this;
                that.id = serverCell.Id;
                that.tabId = serverCell.Id;
                that.serverValue = serverCell ? serverCell.Value : '';
                that.value = ko.observable(that.serverValue);
                that.computedValue = ko.observable(serverCell.ComputedValue || '');
                that.isFocused = ko.observable();
                that.autoCalculate = serverCell.autoCalculate || false;

                that.isDirty = function () {
                    return that.serverValue !== that.value();
                };
                that.isPrice = serverCell.ValueType === 1;
                that.isCost = serverCell.IsCost;
                that.isDiscount = serverCell.ValueType === 2;

                that.editable = serverCell ? serverCell.Editable : false;

                if (that.editable) {
                    that.template = 'editableCellTemplate';
                } else {
                    that.template = 'readonlyEditableCellTemplate';
                }

                that.hasModifiedComputedField = ko.pureComputed(function() {
                    return that.computedValue().length > 0 && that.computedValue() !== that.value();
                });

                that.updateCellFocus = function (id) {
                    window.lastActiveElementId = id;
                    mediator.publish('cartCellManager.CellFocusUpdated');
                }

                that.modifiedComputedFieldMsg = ko.pureComputed(function () {
                    return self.computedValueChangedMsg + that.computedValue();
                });

                if (serverCell.IsAttribute || serverCell.IsSubscriptionAttribute ) {
                    that.stdAttrCode = serverCell.StdAttrCode;
                    that.placeholder = serverCell.Placeholder;
                    that.valueId = serverCell.ValueId;
                    that.selectedRow = ko.observable({});
                    that.autocompleteResults = {};
                    that.url = serverCell.IsAttribute ? cartServerProxy.getAutoCompleteSourceTableValuesUrl : cartServerProxy.getAutoCompleteSubscriptionFieldsUrl

                    that.getSearchResults = {
                        url: that.url,
                        dataType: 'json',
                        data: function (search) {
                            if (serverCell.IsAttribute) {
                                return {
                                    stdAttrCode: that.stdAttrCode, searchValue: search.term || ""
                                };
                            } else {
                                return {
                                    itemId: serverCell.ItemId, column: serverCell.ColumnName, searchValue: search.term || ""
                                };

                            }
                        },
                        processResults: function (data) {
                            that.autocompleteResults = {
                                results: jQuery.map(data.Items, function (item) {
                                    return {
                                        text: item.Values,
                                        id: item.Id,
                                        invalid: verifyResult(item, that.selectedRow())
                                    };
                                })
                            };

                            return that.autocompleteResults;
                        }
                    };

                    that.onSelect = function (e) {
                        ko.utils.arrayForEach(that.autocompleteResults.results, function (item) {
                            if (item.id === e.params.data.id) {
                                that.valueId = item.id;
                                that.value(item.text);
                            }
                        });
                    };

                    that.onUnselect = function () {
                        that.valueId = 0;
                        that.value('');
                    };

                    if (that.valueId > 0) {
                        that.selectedRow = ko.observable({ id: that.valueId, text: that.value() });
                    }
                }


                if (serverCell.IsDropDownCell) {

                    that.availableOptions = ko.observableArray();
                    that.selectedValue = ko.observable();
                    
                    that.initOptionsFromServer = function (serverData) {
                        utility.rebuildObservableArray(that.availableOptions, serverData, function (serverItem) {
                            this.id = serverItem.Id;
                            this.selectedText = serverItem.Text;
                            this.displayText = serverItem.DisplayText;
                        });

                        that.selectedValue(_.find(that.availableOptions(), function (item) {
                            if (item.id.toString() === that.serverValue) {
                                return item;
                            }
                        }));

                        that.value = ko.computed(function () { return that.selectedValue().id.toString() });
                    }

                    cartServerProxy.getLookups(serverCell.LookupUrl, that.initOptionsFromServer); 
                }
            };

            CreateMathCell = function (serverCell) {
                var cell = new CreateEditableCell(serverCell);

                cell.isSinglelineText = serverCell.IsText && !serverCell.IsMultiline;
                cell.isMultilineText = serverCell.IsText && serverCell.IsMultiline;
                cell.isDate = serverCell.IsDate;
                cell.isAttribute = serverCell.IsAttribute;
                cell.isSubscriptionAttribute = serverCell.IsSubscriptionAttribute;
                cell.isDropDown = serverCell.IsDropDownCell;
                cell.isNumber = !serverCell.IsText && !serverCell.IsDate && !serverCell.IsAttribute && !serverCell.IsDropDownCell;

                cell.editableGroup = serverCell ? serverCell.EditableGroup : 0;
                cell.isEditable = function () {
                    return !isInViewMode() && cell.editableGroup === activeEditableGroup();
                };
                cell.canStartEditing = function () {
                    return !cell.isEditable() && cell.editableGroup > 0 && !isInViewMode();
                };

                cell.template = ko.pureComputed(function () {
                    if (cell.isEditable()) {
                        if (cell.isSinglelineText) {
                            return 'textMathCellTemplate';
                        } else if (cell.isMultilineText) {
                            return 'textareaMathCellTemplate';
                        } else if (cell.isDate) {
                            return 'dateCellTemplate';
                        } else if (cell.isAttribute || cell.isSubscriptionAttribute) {
                            return 'attributeCellTemplate';
                        } else if (cell.isDropDown) {
                            return 'dropDownCellTemplate';
                        } else {
                            return 'numericMathCellTemplate';
                        }
                    } else {
                        if (cell.canStartEditing()) {
                            return 'readModeForEditableMathCellTemplate';
                        } else {
                            return 'readModeForMathCellTemplate';
                        }
                    }
                });

                cell.errorMessage = ko.observable('');

                cell.startEditing = function (id) {
                    window.lastActiveElementId = typeof id === "object" ? id.id : id; // preventing breaking change
                    mediator.publish("cartCellManager.activateEditableGroup", cell.editableGroup);
                };

                return cell;
            };

            CreateMathDiscountCell = function (serverCell) {
                var cell = new CreateMathCell(serverCell);

                cell.errorMessage(serverCell.ErrorMessage);
                cell.minValue = serverCell.MinValue;
                cell.maxValue = serverCell.MaxValue;
                cell.defaultValue = serverCell.DefaultValue;
                cell.canOverride = serverCell.CanOverride;
                cell.isMultiplier = serverCell.IsMultiplier;

                cell.value.subscribe(function (newValue) {
                    var number;
                    if (typeof newValue === "string") {
                        // value is string so we must first convert it to number
                        number = utility.stringToNumber(newValue);
                    } else {
                        number = newValue;
                    }

                    if (!isNaN(number) && (number < cell.minValue || number > cell.maxValue)) {
                        // if value is not in range
                        var message;
                        if (cell.isMultiplier) {
                            message = utility.formatMsg(self.multiplierExceededMsg, { 'mMin': cell.minValue, 'mMax': cell.maxValue });
                        } else {
                            message = utility.formatMsg(self.discountExceededMsg, { 'dMin': cell.minValue, 'dMax': cell.maxValue });
                        }

                        if (cell.canOverride) {
                            // if user can override valid  input just set error message
                            cell.errorMessage(message);
                        } else {
                            // if user cannot override valid input restore default value
                            // and alert user
                            if (cell.value() !== cell.defaultValue) { //comperison only by value is intentional because value is sometimes set as a string and sometimes as int.
                                cell.value(cell.defaultValue);
                                utility.alert("", message, function() {
                                    mediator.publish("cartCellManager.CellFocusUpdated");
                                });
                            }
                        }
                    } else {
                        // clear error message if value is ok
                        cell.errorMessage("");
                    }
                });

                return cell;
            };

            CreateItemTypeCell = function (serverCell) {
                this.itemType = serverCell.ItemType;
                this.baseCartItem = serverCell.BaseCartItem;
                this.baseItemNumber = serverCell.BaseItemNumber;
                this.editable = serverCell.Editable;
                this.itemTypeName = getItemTypeName(serverCell.ItemType);

                if (this.editable) {
                    this.template = 'itemTypeEditableCellTemplate';
                } else {
                    this.template = 'itemTypeReadonlyCellTemplate';
                }
            };

            CreateCustomFieldSummaryCell = function (serverCell) {
                this.isCurrency = serverCell.ValueType === 1;
                this.count = serverCell.Count;
                this.summaryValue = serverCell.SummaryValue;
                this.summaryCalculatedValue = serverCell.SummaryCalculatedValue;
                this.maxValue = serverCell.MaxValue;
                this.maxCalculatedValue = serverCell.MaxCalculatedValue;
                this.minValue = serverCell.MinValue;
                this.minCalculatedValue = serverCell.MinCalculatedValue;
                this.template = 'customFieldSummaryCellTemplate';
            };

            getCustomFieldTemplateName = function(type) {
                switch (type) {
                    case 0:
                        return "CartCustomFieldHtmlTemplate";
                    case 1:
                        return "CartCustomFieldFreeFormTemplate";
                    case 2:
                        return "CartCustomFieldAttributeTemplate";
                    case 3:
                        return "CartCustomFieldDateTemplate";
                    case 4:
                        return "CartCustomFieldLongTextTemplate";
                    case 5:
                        return "CartCustomFieldAutocompleteTemplate";
                }
            };

            self.createCell = function (serverCell) {
                var cell, cellType;
                cellType = serverCell && serverCell.CellType || 0;

                if (cellType === 0) {
                    cell = new CreateValueCell(serverCell);
                } else if (cellType === 1) {
                    cell = new CreateMarginHealthCell(serverCell);
                } else if (cellType === 2) {
                    cell = new CreateEditableCell(serverCell);
                    editableCells.push(cell);
                } else if (cellType === 3) {
                    cell = new CreateMathCell(serverCell);
                    editableCells.push(cell);
                } else if (cellType === 4) {
                    cell = new CreateMathDiscountCell(serverCell);
                    editableCells.push(cell);
                } else if (cellType === 5) {
                    cell = new CreateItemTypeCell(serverCell);
                } else if (cellType === 6) {
                    cell = new CreateCustomFieldSummaryCell(serverCell);
                } else {
                    throw "Unknown cell type " + cellType;
                }

                cell.tabIndexGroup = '';
                return cell;
            };

            self.CreateCustomField = function (serverField) {
                var that = this;
                that.id = serverField.Id;
                that.name = serverField.Name;
                that.label = serverField.Label.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                that.isRequired = serverField.IsRequired;
                that.editable = serverField.Editable;
                that.isRequiredIndicatorVisible = that.isRequired && that.editable;
                that.error = serverField.Error;
                that.serverContent = serverField.Content;
                that.content = ko.observable(that.serverContent);
                that.triggersSave = serverField.TriggersSave;
                that.stdAttrCode = serverField.StdAttrCode;
                that.placeholder = serverField.Placeholder;
                that.selectedRow = ko.observable({}),
                that.autocompleteResults = {};
                that.isDirty = function () {
                    return that.serverContent !== that.content();
                };
                that.type = serverField.Type;
                that.template = getCustomFieldTemplateName(serverField.Type);
                that.rank = serverField.Rank;
                that.values = ko.utils.arrayMap(serverField.Values, function (serverItem) {
                    return {
                        id: serverItem.Id,
                        value: serverItem.Value
                    };
                });

                that.selectedValue = ko.pureComputed({
                    read: function () {
                        return ko.utils.arrayFirst(that.values, function (valueItem) {
                            return valueItem.value === that.content();
                        });
                    },

                    write: function (newValueItem) {
                        that.content(newValueItem.value);
                    }
                });

                that.content.subscribe(function () {
                    if (that.triggersSave) {
                        // use timeout to ensure this update is executed AFTER the focus/blur-event-handlers, which set the correct "self.lastFocusedElemSelector"
                        setTimeout(function () {
                            // self.lastFocusedElemSelector will be empty when tabbing onto a select2 element (because focusin is not working there), 
                            // then find the correct lastActive select2 from document
                            var lastElemSelector = self.lastFocusedElemSelector || that.checkForSelect2Element($(document.activeElement));
                            mediator.publish("cartCellManager.customFieldsChanged", lastElemSelector);
                        });
                    }
                });

                that.getSearchResults = {
                    url: cartServerProxy.getAutoCompleteSourceTableValuesUrl,
                    dataType: 'json',
                    data: function (search) {
                        return {
                            stdAttrCode: that.stdAttrCode, searchValue: search.term || ""
                        };
                    },
                    processResults: function (data) {
                        that.autocompleteResults = {
                            results: jQuery.map(data.Items, function (item) {
                                return {
                                    text: item.Values,
                                    id: item.Id,
                                    invalid: verifyResult(item, that.selectedRow())
                                };
                            })
                        };

                        return that.autocompleteResults;
                    }
                };

                if (serverField.Type === 5 && serverField.ContentId > 0) {
                    that.selectedRow({
                        text: serverField.Content,
                        id: serverField.ContentId
                    });
                }

                that.onSelect = function (e) {
                    mediator.publish('cart.customfield.autocomplete.select', that.id, e.params.data.id, function () {
                        ko.utils.arrayForEach(that.autocompleteResults.results, function (item) {
                            if (item.id === e.params.data.id) {
                                that.content(item.text);
                            }
                        });
                    });
                };

                that.onUnselect = function () {
                    mediator.publish('cart.customfield.autocomplete.unselect', that.id, function () {
                        that.content('');
                    });
                };

                that.setLastFocusedField = function (data, event) {
                    if ($(event.target).hasClass('ignore-id-on-autosave')) {
                        self.lastFocusedElemSelector = '';
                        return;
                    }
                    self.lastFocusedElemSelector = event.target.id ? '#' + event.target.id : '';
                };

                that.clearLastFocusedField = function (data, event) {
                    self.lastFocusedElemSelector = '';
                };

                that.checkForSelect2Element = function ($elem) {
                    var $select2 = $elem.parents('.select2').siblings('select');
                    if ($select2.length && $select2[0].id) {
                        // if the active element is a select2, return the selector to the focusable span. (we also need the id of the parent-sibling-select to identify this exact span)
                        return '#' + $select2[0].id + ' ~ .select2 .select2-selection';
                    }
                    return null;
                }

                customFields.push(that);
            };

            self.clearCellsAndFields = function () {
                editableCells = [];
                customFields = [];
            };

            self.getDirtyCells = function () {
                return ko.utils.arrayFilter(editableCells, function (item) {
                    return item.isDirty();
                });
            };

            self.getDirtyCustomFields = function () {
                return ko.utils.arrayFilter(customFields, function (item) {
                    return item.isDirty();
                });
            };

            self.isCellOrCustomFieldsDirty = function () {
                return self.getDirtyCells().length > 0 || self.getDirtyCustomFields().length > 0;
            };
        };
    });

/*global define*/
/*jslint browser: true*/
define('DealViewServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getInitData: function (tabId, callback) {
                $.getJSON('/api/rd/v1/DealView/GetDealViewInitData', { tabId: tabId }, callback);
            },
            bulkUpdateDealStructure: function (quoteId, dealStructure, callback) {
                utility.postJson(utility.buildUrl('/api/rd/v1/DealView/BulkUpdateDealStructure?quoteId=' + quoteId), dealStructure, callback);
            },
            getItemsBySections: function (pageSize, page, filterQuery, callback) {
                utility.postJson('/api/rd/v1/Cart/GetItemsBySections', { PageSize: pageSize, Page: page, FilterQuery: filterQuery }, callback);
            },
            getActionsForItem: function (itemId, callback) {
                utility.get('/api/rd/v1/Cart/GetActionsForItem', { itemId: itemId }, callback);
            },
            moveItemToSection: function (itemId, sectionPath, callback) {
                utility.get('/api/rd/v1/DealView/MoveItemToSection', { itemId: itemId, sectionPath: sectionPath }, callback);
            },
            getDealSectionByPath: function (sectionPath, callback) {
                utility.get('/api/rd/v1/DealView/GetDealSectionByPath', { sectionPath: sectionPath }, callback);
            },
            searchSectionsByName: function (searchString, callback) {
                $.getJSON('/api/rd/v1/DealView/SearchSectionsByName', { searchString: searchString }, callback);
            },
            dealStructureModelsCount: function (callback) {
                $.getJSON('/api/rd/v1/DealView/DealStructureModelsCount', null, callback);
            },
            downloadSectionsTemplate: function (callback, error) {
                utility.download('/api/rd/v1/DealView/DownloadSectionsTemplate', null, callback, error);
            },
            calculate: function (cartUpdateParams, callback) {
                utility.postJson("/api/rd/v1/Cart/CalculateSections", cartUpdateParams, callback);
            },
            exportDealStructure: function (filterQuery, callback, error) {
                utility.download('/api/rd/v1/DealView/ExportDealStructure', { filterQuery: filterQuery }, callback, error);
            },
            getFilterableItemColumns: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetFilterableItemColumns", data, callback);
            },
            getMinAndMaxForColumn: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetMinAndMaxForColumn", data, callback);
            },
            getFieldDistinctValues: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetFieldDistinctValues", data, callback);
            },
            getSectionPaths: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetSectionPaths", data, callback);
            },
            getAutocompleteValues: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetCustomFieldAutocomplete", data, callback);
            },
            loadFilters: function (key, callback) {
                var filters = utility.getTenantStorageItem("dealViewFilter_" + key);
                callback(JSON.parse(filters));
            },
            saveFilters: function (key, filters, callback) {
                utility.setTenantStorageItem("dealViewFilter_" + key, JSON.stringify(filters));
                if (callback) callback();
            },
            deleteFilters: function (key, callback) {
                utility.removeTenantStorageItem("dealViewFilter_" + key);
                if (callback) callback();
            },
            getFilteredDealStructure: function (filterQuery, callback) {
                $.get("/api/rd/v1/DealView/GetFilteredDealStructure", { filterQuery: filterQuery }, callback);
            },
            getAutocompleteAttributeValues: function (data, callback) {
                $.get("/api/rd/v1/DealView/GetCustomFieldAutocompleteAttribute", data, callback);
            },
            distributeSections: function (dealStructure, sourceId, callback) {
                utility.postJson("/api/rd/v1/DealView/DistributeSections", { DealStructure: dealStructure, SourceId: sourceId }, callback);
            },
            redistribute: function (callback) {
                $.get("/api/rd/v1/DealView/Redistribute", null, callback);
            },
            retractDistribution: function (dealStructure, sourceId, callback) {
                utility.postJson("/api/rd/v1/DealView/RetractDistribution", { DealStructure: dealStructure, SourceId: sourceId }, callback);
            },
            getSectionSearchInit: function (callback) {
                $.get("/api/rd/v1/DealView/GetSectionsDistinctPaths", null, callback);
            },
            getFiltersMetadata: function (callback) {
                $.get("/api/rd/v1/DealView/GetFiltersMetadata", null, callback);
            },
            bulkAssign: function (cartUpdateParams, callback) {
                utility.postJson("/api/rd/v1/Cart/BulkAssign", cartUpdateParams, callback);
            },
            getTotal: function (quoteId, filters, callback) {
                utility.postJson("/api/rd/v1/DealView/GetSectionTotals", { QuoteId: quoteId, FilterQuery: filters }, callback);
            }
        };
    });

/*global define*/
/*jslint browser: true*/
define('QuoteTeamsServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getQuoteTeamsTabData: function (tabId, callback) {
                utility.get('/api/rd/v1/Cart/GetQuoteTeamsTabData', { tabId: tabId }, callback);
            },
            searchUsers: function (query, callback) {
                $.getJSON('/api/rd/v1/UserPersonalization/GetUsers', { query: query, includeCurrentUser: true }, callback);
            },
            deleteTeam: function (teamId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/DeleteQuoteTeam", { teamId: teamId }), callback);
            },
            saveTeam: function (team, callback) {
                utility.postJson("/api/rd/v1/Cart/SaveQuoteTeam", team, callback);
            }
        };
    });

/*global define*/
/*jslint browser: true*/
define('TeamSelectionModule',['knockout', 'Utility', 'QuoteTeamsServerProxy'],
    function(ko, utility, serverProxy) {
        "use strict";
        return function() {
            var self = this;
            var TeamFactory, TeamCollectionFactory;

            self.teamWithMembers = ko.observableArray([]);

            function save(team, item) {
                var teamNames = [];
                item.selectedTeams = [];

                team.filter(function (d) { return d.isChecked() })().forEach(function (value) {
                    teamNames.push(value.name());
                    item.selectedTeams.push(value.id);
                });
                item.teams(teamNames.join(", "));
            };

            TeamCollectionFactory = function (teamMembers, item) {
                var team = this;
                team.data = teamMembers;
                team.saveTeamSelection = function () {
                    if (item.teams) {
                        save(team.data, item);
                    } else {
                        item.forEach(function (item) {
                            save(team.data, item);
                        });
                    }
                    window.lastActiveElementId = (item.teams().length)
                        ? window.lastActiveElementId.replace("noTeams", "hasTeams")
                        : window.lastActiveElementId.replace("hasTeams", "noTeams");
                };
            };
            TeamFactory = function (serverData, item) {
                var that = this;
                that.id = serverData.Id;
                that.name = ko.observable(serverData.Name);
                that.isChecked = ko.observable(false);
                if (item.selectedTeams) {
                    that.isChecked(item.selectedTeams.includes(serverData.Id));
                }
                that.isExpanded = ko.observable(false);
                that.members = ko.observableArray([]);
                that.toggleExpanded = function () {
                    that.isExpanded(!that.isExpanded());
                };

                utility.rebuildObservableArray(that.members, serverData.Members, function (item) {
                    var userData = this;
                    userData.name = item.Name + ' | ' + item.Email;
                    userData.isBlocked = item.IsBlocked;
                });
            };

            self.showPopup = function (item) {
                serverProxy.getQuoteTeamsTabData(null, function (data) {
                    var solutionTeams = data.Teams.filter(function (d) { return d.Role === 2 });
                    var newArray = [];
                    solutionTeams.forEach(function (value) {
                        newArray.push(new TeamFactory(value, item));
                    });

                    self.teamWithMembers(newArray);
                    var model = new TeamCollectionFactory(self.teamWithMembers, item);
                    model.canClose = false;
                    window.lastActiveElementId = document.activeElement.id;
                    utility.activateModalFromTemplate(model, "TeamsAssignTeamTemplate");
                });
            };
        }
    });

/*global define*/
/*jslint browser: true*/
define('DealSectionModel',['knockout', 'TeamSelectionModule'],
    function (ko, TeamSelectionModule) {
        "use strict";
        return function (data) {
            var self = this;
            self.error = ko.observable('');
            self.hierarchyId = ko.observable(data.HierarchyId || '');
            self.sectionPath = ko.observable(data.SectionPath || '');
            self.rank = data.Rank || 0;

            self.parentName = '';

            self.parentPath = ko.computed(function() {
                var sectionPathParts = self.sectionPath().split('\\');
                sectionPathParts.pop();
                self.parentName = sectionPathParts[sectionPathParts.length - 1];
                return sectionPathParts.join('\\');
            });

            self.sectionName = ko.computed({
                read: function () {
                    var sectionPathParts = self.sectionPath().split('\\');
                    return sectionPathParts[sectionPathParts.length - 1];
                },
                write: function (value) {
                    if (value.includes("\\")) {
                        self.error(self.sectionErrorBackslash);
                        return;
                    }
                    self.error('');
                    var sectionPathParts = self.sectionPath().split('\\');
                    sectionPathParts.pop();
                    sectionPathParts.push(value)
                    self.sectionPath(sectionPathParts.join('\\'));
                }
            });     

            self.id = data.Id || '';
            self.quoteId = data.QuoteId || '';
            self.level = ko.observable(data.Level || 0);
            self.canContainProducts = ko.observable(data.CanContainProducts);
            self.canBeDistributed = ko.observable(data.CanBeDistributed);
            self.teams = ko.observable(data.Teams);
            self.selectedTeams = data.SelectedTeams;
            self.distributionParentPath = data.DistributionParentPath;
            self.distributionPercent = ko.observable(data.DistributionPercent);
            self.distributionMethod = ko.observable(data.DistributionMethod);
            self.canManageSection = ko.observable(data.CanManageSection);

            self.isDeleted = ko.observable(data.IsDeleted || false);
            self.isNew = !self.id;

            self.toJS = function () {
                return {
                    Id: self.id,
                    QuoteId: self.quoteId,
                    HierarchyId: self.hierarchyId(),
                    Level: self.level(),
                    SectionPath: self.sectionPath().trim(),
                    CanContainProducts: self.canContainProducts(),
                    CanBeDistributed: self.canBeDistributed(),
                    Teams: self.teams(),
                    SelectedTeams: self.selectedTeams,
                    Rank: self.rank,
                    DistributionParentPath: self.distributionParentPath || null,
                    DistributionPercent: self.distributionPercent(),
                    DistributionMethod: self.distributionMethod(),
                    CanManageSection: self.canManageSection(),
                    IsDeleted: self.isDeleted()
                }
            }

            self.originalModel = self.toJS();
            
            self.hasTeams = ko.computed(function () {
                return self.teams() && self.teams().length > 0;
            });

            self.getChanges = function () {
                var changes = {};
                var currentModel = self.toJS();
                for (var property in self.originalModel) {
                    if (currentModel[property] != self.originalModel[property]) {
                        changes[property] = { oldValue: self.originalModel[property], newValue: currentModel[property] }
                    }
                }
                return changes;
            }

            self.hasChanges = function () {
                var changes = self.getChanges();
                var hasChanges = false;
                for (var change in changes) {
                    hasChanges = true;
                    break;
                }
                return hasChanges;
            }

            self.getTitle = function () {
                return self.hierarchyId() + ' ' + self.sectionName();
            }

            self.addTeamClicked = function (item) {
                var selectionModule = new TeamSelectionModule();
                selectionModule.showPopup(item);
            };
        }
    });
/*
===============================================================================
    Author:     Eric M. Barnard - @ericmbarnard                                
    License:    MIT (http://opensource.org/licenses/mit-license.php)           
                                                                               
    Description: Validation Library for KnockoutJS                             
===============================================================================
*/

(function (factory) {
    // Module systems magic dance.

    if (typeof require === "function" && typeof exports === "object" && typeof module === "object") {
        // CommonJS or Node: hard-coded dependency on "knockout"
        factory(require("knockout"), exports);
    } else if (typeof define === "function" && define["amd"]) {
        // AMD anonymous module with hard-coded dependency on "knockout"
        define('knockoutValidations',["knockout", "exports"], factory);
    } else {
        // <script> tag: use the global `ko` object, attaching a `mapping` property
        factory(ko, ko.validation = {});
    }
}(function ( ko, exports ) {

    if (typeof (ko) === undefined) { throw 'Knockout is required, please ensure it is loaded before loading this validation plug-in'; }

    // create our namespace object
    var validation = exports;
    ko.validation = validation;

    var defaults = {
        registerExtenders: true,
        messagesOnModified: true,
        errorsAsTitleOnModified: false, // shows the error when hovering the input field (decorateElement must be true)
        messageTemplate: null,
        insertMessages: true,           // automatically inserts validation messages as <span></span>
        parseInputAttributes: false,    // parses the HTML5 validation attribute from a form element and adds that to the object
        writeInputAttributes: false,    // adds HTML5 input validation attributes to form elements that ko observable's are bound to
        decorateElement: false,         // false to keep backward compatibility
        errorClass: null,               // single class for error message and element
        errorElementClass: 'validationElement',  // class to decorate error element
        errorMessageClass: 'validationMessage',  // class to decorate error message
        grouping: {
            deep: false,        //by default grouping is shallow
            observable: true    //and using observables
        }
    };

    // make a copy  so we can use 'reset' later
    var configuration = ko.utils.extend({}, defaults);

    var html5Attributes = ['required', 'pattern', 'min', 'max', 'step'];

    var async = function (expr) {
        if (window.setImmediate) { window.setImmediate(expr); }
        else { window.setTimeout(expr, 0); }
    };

    //#region Utilities

    var utils = (function () {
        var seedId = new Date().getTime();

        var domData = {}; //hash of data objects that we reference from dom elements
        var domDataKey = '__ko_validation__';

        return {
            isArray: function (o) {
                return o.isArray || Object.prototype.toString.call(o) === '[object Array]';
            },
            isObject: function (o) {
                return o !== null && typeof o === 'object';
            },
            values: function (o) {
                var r = [];
                for (var i in o) {
                    if (o.hasOwnProperty(i)) {
                        r.push(o[i]);
                    }
                }
                return r;
            },
            getValue: function (o) {
                return (typeof o === 'function' ? o() : o);
            },
            hasAttribute: function (node, attr) {
                return node.getAttribute(attr) !== null;
            },
            isValidatable: function (o) {
                return o && o.rules && o.isValid && o.isModified;
            },
            insertAfter: function (node, newNode) {
                node.parentNode.insertBefore(newNode, node.nextSibling);
            },
            newId: function () {
                return seedId += 1;
            },
            getConfigOptions: function (element) {
                var options = utils.contextFor(element);

                return options || configuration;
            },
            setDomData: function (node, data) {
                var key = node[domDataKey];

                if (!key) {
                    node[domDataKey] = key = utils.newId();
                }

                domData[key] = data;
            },
            getDomData: function (node) {
                var key = node[domDataKey];

                if (!key) {
                    return undefined;
                }

                return domData[key];
            },
            contextFor: function (node) {
                switch (node.nodeType) {
                    case 1:
                    case 8:
                        var context = utils.getDomData(node);
                        if (context) return context;
                        if (node.parentNode) return utils.contextFor(node.parentNode);
                        break;
                }
                return undefined;
            },
            isEmptyVal: function (val) {
                if (val === undefined) {
                    return true;
                }
                if (val === null) {
                    return true;
                }
                if (val === "") {
                    return true;
                }
            }
        };
    } ());

    //#endregion

    //#region Public API
    var api = (function () {

        var isInitialized = 0;

        return {
            utils: utils,

            //Call this on startup
            //any config can be overridden with the passed in options
            init: function (options, force) {
                //done run this multiple times if we don't really want to
                if (isInitialized > 0 && !force) {
                    return;
                }

                //becuase we will be accessing options properties it has to be an object at least
                options = options || {};
                //if specific error classes are not provided then apply generic errorClass
                //it has to be done on option so that options.errorClass can override default
                //errorElementClass and errorMessage class but not those provided in options
                options.errorElementClass = options.errorElementClass || options.errorClass || configuration.errorElementClass;
                options.errorMessageClass = options.errorMessageClass || options.errorClass || configuration.errorMessageClass;

                ko.utils.extend(configuration, options);

                if (configuration.registerExtenders) {
                    exports.registerExtenders();
                }

                isInitialized = 1;
            },
            // backwards compatability
            configure: function (options) { exports.init(options); },

            // resets the config back to its original state
            reset: function () { configuration = $.extend(configuration, defaults); },

            // recursivly walks a viewModel and creates an object that
            // provides validation information for the entire viewModel
            // obj -> the viewModel to walk
            // options -> {
            //      deep: false, // if true, will walk past the first level of viewModel properties
            //      observable: false // if true, returns a computed observable indicating if the viewModel is valid
            // }
            group: function group(obj, options) { // array of observables or viewModel
                var options = ko.utils.extend(configuration.grouping, options),
                validatables = ko.observableArray([]),
                result = null,

                //anonymous, immediate function to traverse objects hierarchically
                //if !options.deep then it will stop on top level
                traverse = function traverse(obj, level) {
                    var objValues = [],
                        val = ko.utils.unwrapObservable(obj);

                    //default level value depends on deep option.
                    level = (level !== undefined ? level : options.deep ? 1 : -1);

                    // if object is observable then add it to the list
                    if (ko.isObservable(obj)) {

                        //make sure it is validatable object
                        if (!obj.isValid) obj.extend({ validatable: true });
                        validatables.push(obj);
                    }

                    //get list of values either from array or object but ignore non-objects
                    if (val) {
                        if (utils.isArray(val)) {
                            objValues = val;
                        } else if (utils.isObject(val)) {
                            objValues = utils.values(val);
                        }
                    }

                    //process recurisvely if it is deep grouping
                    if (level !== 0) {
                        ko.utils.arrayForEach(objValues, function (observable) {

                            //but not falsy things and not HTML Elements
                            if (observable && !observable.nodeType) traverse(observable, level + 1);
                        });
                    }
                };

                //if using observables then traverse structure once and add observables
                if (options.observable) {

                    traverse(obj);

                    result = ko.computed(function () {
                        var errors = [];
                        ko.utils.arrayForEach(validatables(), function (observable) {
                            if (!observable.isValid()) {
                                errors.push(observable.error);
                            }
                        });
                        return errors;
                    });

                } else { //if not using observables then every call to error() should traverse the structure
                    result = function () {
                        var errors = [];
                        validatables([]); //clear validatables
                        traverse(obj); // and traverse tree again
                        ko.utils.arrayForEach(validatables(), function (observable) {
                            if (!observable.isValid()) {
                                errors.push(observable.error);
                            }
                        });
                        return errors;
                    };


                }

                result.showAllMessages = function (show) { // thanks @heliosPortal
                    if (show == undefined) //default to true
                        show = true;

                    // ensure we have latest changes
                    result();

                    ko.utils.arrayForEach(validatables(), function (observable) {
                        observable.isModified(show);
                    });
                };

                obj.errors = result;
                obj.isValid = function () {
                    return obj.errors().length === 0;
                };
                obj.isAnyMessageShown = function() {
                    var invalidAndModifiedPresent = false;
                    
                    // ensure we have latest changes
                    result();
                    
                    ko.utils.arrayForEach(validatables(), function (observable) {
                        if (!observable.isValid() && observable.isModified()) {
                            invalidAndModifiedPresent = true;
                        }
                    });
                    return invalidAndModifiedPresent;
                };

                return result;
            },

            formatMessage: function (message, params) {
                if (typeof (message) === 'function')
                    return message(params);
                message = message || "";
                return message.replace(/\{0\}/gi, params);
            },

            // addRule:
            // This takes in a ko.observable and a Rule Context - which is just a rule name and params to supply to the validator
            // ie: ko.validation.addRule(myObservable, {
            //          rule: 'required',
            //          params: true
            //      });
            //
            addRule: function (observable, rule) {
                observable.extend({ validatable: true });

                //push a Rule Context to the observables local array of Rule Contexts
                observable.rules.push(rule);
                return observable;
            },

            // addAnonymousRule:
            // Anonymous Rules essentially have all the properties of a Rule, but are only specific for a certain property
            // and developers typically are wanting to add them on the fly or not register a rule with the 'ko.validation.rules' object
            //
            // Example:
            // var test = ko.observable('something').extend{(
            //      validation: {
            //          validator: function(val, someOtherVal){
            //              return true;
            //          },
            //          message: "Something must be really wrong!',
            //          params: true
            //      }
            //  )};
            addAnonymousRule: function (observable, ruleObj) {
                var ruleName = utils.newId();

                if ( ruleObj['message'] === undefined ) {
                    ruleObj['message'] = 'Error';
                }

                //Create an anonymous rule to reference
                exports.rules[ruleName] = ruleObj;

                //add the anonymous rule to the observable
                exports.addRule(observable, {
                    rule: ruleName,
                    params: ruleObj.params
                });
            },

            addExtender: function (ruleName) {
                ko.extenders[ruleName] = function (observable, params) {
                    //params can come in a few flavors
                    // 1. Just the params to be passed to the validator
                    // 2. An object containing the Message to be used and the Params to pass to the validator
                    // 3. A condition when the validation rule to be applied
                    //
                    // Example:
                    // var test = ko.observable(3).extend({
                    //      max: {
                    //          message: 'This special field has a Max of {0}',
                    //          params: 2,
                    //          onlyIf: function() {
                    //                      return specialField.IsVisible();
                    //                  }
                    //      }
                    //  )};
                    //
                    if (params.message || params.onlyIf) { //if it has a message or condition object, then its an object literal to use
                        return exports.addRule(observable, {
                            rule: ruleName,
                            message: params.message,
                            params: utils.isEmptyVal(params.params) ? true : params.params,
                            condition: params.onlyIf
                        });
                    } else {
                        return exports.addRule(observable, {
                            rule: ruleName,
                            params: params
                        });
                    }
                };
            },

            // loops through all ko.validation.rules and adds them as extenders to
            // ko.extenders
            registerExtenders: function () { // root extenders optional, use 'validation' extender if would cause conflicts
                if (configuration.registerExtenders) {
                    for (var ruleName in exports.rules) {
                        if (exports.rules.hasOwnProperty(ruleName)) {
                            if (!ko.extenders[ruleName]) {
                                exports.addExtender(ruleName);
                            }
                        }
                    }
                }
            },

            //creates a span next to the @element with the specified error class
            insertValidationMessage: function (element) {
                var span = document.createElement('SPAN');
                span.className = utils.getConfigOptions(element).errorMessageClass;
                utils.insertAfter(element, span);
                return span;
            },

            // if html-5 validation attributes have been specified, this parses
            // the attributes on @element
            parseInputValidationAttributes: function (element, valueAccessor) {
                ko.utils.arrayForEach(html5Attributes, function (attr) {
                    if (utils.hasAttribute(element, attr)) {
                        exports.addRule(valueAccessor(), {
                            rule: attr,
                            params: element.getAttribute(attr) || true
                        });
                    }
                });
            },

            // writes html5 validation attributes on the element passed in
            writeInputValidationAttributes: function (element, valueAccessor) {
                var observable = valueAccessor();

                if (!observable || !observable.rules) {
                    return;
                }

                var contexts = observable.rules(); // observable array

                // loop through the attributes and add the information needed
                ko.utils.arrayForEach(html5Attributes, function (attr) {
                    var params;
                    var ctx = ko.utils.arrayFirst(contexts, function (ctx) {
                        return ctx.rule.toLowerCase() === attr.toLowerCase();
                    });

                    if (!ctx)
                        return;

                    params = ctx.params;

                    // we have to do some special things for the pattern validation
                    if (ctx.rule == "pattern") {
                        if (ctx.params instanceof RegExp) {
                            params = ctx.params.source; // we need the pure string representation of the RegExpr without the //gi stuff
                        }
                    }

                    // we have a rule matching a validation attribute at this point
                    // so lets add it to the element along with the params
                    element.setAttribute(attr, params);
                });

                contexts = null;
            }
        };
    }());

    // expose api publicly
    ko.utils.extend(validation, api);
    //#endregion

    //#region Core Validation Rules

    //Validation Rules:
    // You can view and override messages or rules via:
    // ko.validation.rules[ruleName]
    //
    // To implement a custom Rule, simply use this template:
    // ko.validation.rules['<custom rule name>'] = {
    //      validator: function (val, param) {
    //          <custom logic>
    //          return <true or false>;
    //      },
    //      message: '<custom validation message>' //optionally you can also use a '{0}' to denote a placeholder that will be replaced with your 'param'
    // };
    //
    // Example:
    // ko.validation.rules['mustEqual'] = {
    //      validator: function( val, mustEqualVal ){
    //          return val === mustEqualVal;
    //      },
    //      message: 'This field must equal {0}'
    // };
    //
    validation.rules = {};
    validation.rules['required'] = {
        validator: function (val, required) {
            var stringTrimRegEx = /^\s+|\s+$/g,
                testVal;

            if (val === undefined || val === null) {
                return !required;
            }

            testVal = val;
            if (typeof (val) == "string") {
                testVal = val.replace(stringTrimRegEx, '');
            }

            if (!required) // if they passed: { required: false }, then don't require this
                return true;

            return ((testVal + '').length > 0);
        },
        message: 'This field is required.'
    };

    validation.rules['min'] = {
        validator: function (val, min) {
            return utils.isEmptyVal(val) || val >= min;
        },
        message: 'Please enter a value greater than or equal to {0}.'
    };

    validation.rules['max'] = {
        validator: function (val, max) {
            return utils.isEmptyVal(val) || val <= max;
        },
        message: 'Please enter a value less than or equal to {0}.'
    };

    validation.rules['minLength'] = {
        validator: function (val, minLength) {
            return utils.isEmptyVal(val) || val.length >= minLength;
        },
        message: 'Please enter at least {0} characters.'
    };

    validation.rules['maxLength'] = {
        validator: function (val, maxLength) {
            return utils.isEmptyVal(val) || val.length <= maxLength;
        },
        message: 'Please enter no more than {0} characters.'
    };

    validation.rules['pattern'] = {
        validator: function (val, regex) {
            return utils.isEmptyVal(val) || val.toString().match(regex) != null;
        },
        message: 'Please check this value.'
    };

    validation.rules['step'] = {
        validator: function (val, step) {

            // in order to handle steps of .1 & .01 etc.. Modulus won't work
            // if the value is a decimal, so we have to correct for that
            return utils.isEmptyVal(val) || (val * 100) % (step * 100) === 0;
        },
        message: 'The value must increment by {0}'
    };

    validation.rules['email'] = {
        validator: function (val, validate) {
            if (!validate) return true;

            //I think an empty email address is also a valid entry
            //if one want's to enforce entry it should be done with 'required: true'
            return utils.isEmptyVal(val) || (
                // jquery validate regex - thanks Scott Gonzalez
                validate && /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(val)
            );
        },
        message: 'Please enter a proper email address'
    };

    validation.rules['date'] = {
        validator: function (value, validate) {
            if (!validate) return true;
            return utils.isEmptyVal(value) || (validate && !/Invalid|NaN/.test(new Date(value)));
        },
        message: 'Please enter a proper date'
    };

    validation.rules['dateISO'] = {
        validator: function (value, validate) {
            if (!validate) return true;
            return utils.isEmptyVal(value) || (validate && /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value));
        },
        message: 'Please enter a proper date'
    };

    validation.rules['number'] = {
        validator: function (value, validate) {
            if (!validate) return true;
            return utils.isEmptyVal(value) || (validate && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value));
        },
        message: 'Please enter a number'
    };

    validation.rules['digit'] = {
        validator: function (value, validate) {
            if (!validate) return true;
            return utils.isEmptyVal(value) || (validate && /^\d+$/.test(value));
        },
        message: 'Please enter a digit'
    };

    validation.rules['phoneUS'] = {
        validator: function (phoneNumber, validate) {
            if (!validate) return true;
            if (typeof (phoneNumber) !== 'string') { return false; }
            if (utils.isEmptyVal(phoneNumber)) { return true; } // makes it optional, use 'required' rule if it should be required
            phoneNumber = phoneNumber.replace(/\s+/g, "");
            return validate && phoneNumber.length > 9 && phoneNumber.match(/^(1-?)?(\([2-9]\d{2}\)|[2-9]\d{2})-?[2-9]\d{2}-?\d{4}$/);
        },
        message: 'Please specify a valid phone number'
    };

    validation.rules['equal'] = {
        validator: function (val, params) {
            var otherValue = params;
            return val === utils.getValue(otherValue);
        },
        message: 'Values must equal'
    };

    validation.rules['notEqual'] = {
        validator: function (val, params) {
            var otherValue = params;
            return val !== utils.getValue(otherValue);
        },
        message: 'Please choose another value.'
    };

    //unique in collection
    // options are:
    //    collection: array or function returning (observable) array
    //              in which the value has to be unique
    //    valueAccessor: function that returns value from an object stored in collection
    //              if it is null the value is compared directly
    //    external: set to true when object you are validating is automatically updating collection
    validation.rules['unique'] = {
        validator: function (val, options) {
            var c = utils.getValue(options.collection),
                external = utils.getValue(options.externalValue),
                counter = 0;

            if (!val || !c) return true;

            ko.utils.arrayFilter(ko.utils.unwrapObservable(c), function (item) {
                if (val === (options.valueAccessor ? options.valueAccessor(item) : item)) counter++;
            });
            // if value is external even 1 same value in collection means the value is not unique
            return counter < (external !== undefined && val !== external ? 1 : 2);
        },
        message: 'Please make sure the value is unique.'
    };


    //now register all of these!
    (function () {
        validation.registerExtenders();
    } ());

    //#endregion

    //#region Knockout Binding Handlers

    // The core binding handler
    // this allows us to setup any value binding that internally always
    // performs the same functionality
    ko.bindingHandlers['validationCore'] = (function () {

        return {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var config = utils.getConfigOptions(element);

                // parse html5 input validation attributes, optional feature
                if (config.parseInputAttributes) {
                    async(function () { exports.parseInputValidationAttributes(element, valueAccessor) });
                }

                // if requested insert message element and apply bindings
                if (config.insertMessages && utils.isValidatable(valueAccessor())) {

                    // insert the <span></span>
                    var validationMessageElement = exports.insertValidationMessage(element);

                    // if we're told to use a template, make sure that gets rendered
                    if (config.messageTemplate) {
                        ko.renderTemplate(config.messageTemplate, { field: valueAccessor() }, null, validationMessageElement, 'replaceNode');
                    } else {
                        ko.applyBindingsToNode(validationMessageElement, { validationMessage: valueAccessor() });
                    }
                }

                // write the html5 attributes if indicated by the config
                if (config.writeInputAttributes && utils.isValidatable(valueAccessor())) {

                    exports.writeInputValidationAttributes(element, valueAccessor);
                }

                // if requested, add binding to decorate element
                if (config.decorateElement && utils.isValidatable(valueAccessor())) {
                    ko.applyBindingsToNode(element, { validationElement: valueAccessor() });
                }
            },

            update: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                // hook for future extensibility
            }
        };

    }());

    // override for KO's default 'value' binding
    (function () {
        var init = ko.bindingHandlers['value'].init;

        ko.bindingHandlers['value'].init = function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {

            init(element, valueAccessor, allBindingsAccessor);

            return ko.bindingHandlers['validationCore'].init(element, valueAccessor, allBindingsAccessor, viewModel, bindingContext);
        };
    } ());


    ko.bindingHandlers['validationMessage'] = { // individual error message, if modified or post binding
        update: function (element, valueAccessor) {
            var obsv = valueAccessor(),
                config = utils.getConfigOptions(element),
                val = ko.utils.unwrapObservable(obsv),
                msg = null,
                isModified = false,
                isValid = false;
                
            obsv.extend({ validatable: true });

            isModified = obsv.isModified();
            isValid = obsv.isValid();
            
            // create a handler to correctly return an error message
            var errorMsgAccessor = function () {
                if (!config.messagesOnModified || isModified) {
                    return isValid ? null : obsv.error;
                } else {
                    return null;
                }
            };

            //toggle visibility on validation messages when validation hasn't been evaluated, or when the object isValid
            var visiblityAccessor = function () {
                return (!config.messagesOnModified || isModified) ? !isValid : false;
            };

            ko.bindingHandlers.text.update(element, errorMsgAccessor);
            ko.bindingHandlers.visible.update(element, visiblityAccessor);
        }
    };

    ko.bindingHandlers['validationElement'] = {
        update: function (element, valueAccessor) {
            var obsv = valueAccessor(),
                config = utils.getConfigOptions(element),
                val = ko.utils.unwrapObservable(obsv),
                msg = null,
                isModified = false,
                isValid = false;

            obsv.extend({ validatable: true });

            isModified = obsv.isModified();
            isValid = obsv.isValid();

            // create an evaluator function that will return something like:
            // css: { validationElement: true }
            var cssSettingsAccessor = function () {
                var css = {};

                var shouldShow = (isModified ? !isValid : false);

                if (!config.decorateElement) { shouldShow = false; }

                // css: { validationElement: false }
                css[config.errorElementClass] = shouldShow;

                return css;
            };

            //add or remove class on the element;
            ko.bindingHandlers.css.update(element, cssSettingsAccessor);

            var origTitle = element.getAttribute('data-orig-title');
            var elementTitle = element.title;
            var titleIsErrorMsg = element.getAttribute('data-orig-title') == "true"

            var errorMsgTitleAccessor = function () {
                if (!config.errorsAsTitleOnModified || isModified) {
                    if (!isValid) {
                        return { title: obsv.error, 'data-orig-title': origTitle || elementTitle };
                    } else {
                        return { title: origTitle || elementTitle, 'data-orig-title': null };
                    }
                }
            };
            ko.bindingHandlers.attr.update(element, errorMsgTitleAccessor);
        }
    };

    // ValidationOptions:
    // This binding handler allows you to override the initial config by setting any of the options for a specific element or context of elements
    //
    // Example:
    // <div data-bind="validationOptions: { insertMessages: true, messageTemplate: 'customTemplate', errorMessageClass: 'mySpecialClass'}">
    //      <input type="text" data-bind="value: someValue"/>
    //      <input type="text" data-bind="value: someValue2"/>
    // </div>
    ko.bindingHandlers['validationOptions'] = (function () {
        return {
            init: function (element, valueAccessor, allBindingsAccessor, viewModel, bindingContext) {
                var options = ko.utils.unwrapObservable(valueAccessor());
                if (options) {
                    var newConfig = ko.utils.extend({}, configuration);
                    ko.utils.extend(newConfig, options);

                    //store the validation options on the node so we can retrieve it later
                    utils.setDomData(element, newConfig);
                }
            }
        };
    } ());
    //#endregion

    //#region Knockout Extenders

    // Validation Extender:
    // This is for creating custom validation logic on the fly
    // Example:
    // var test = ko.observable('something').extend{(
    //      validation: {
    //          validator: function(val, someOtherVal){
    //              return true;
    //          },
    //          message: "Something must be really wrong!',
    //          params: true
    //      }
    //  )};
    ko.extenders['validation'] = function (observable, rules) { // allow single rule or array
        ko.utils.arrayForEach(utils.isArray(rules) ? rules : [rules], function (rule) {
            // the 'rule' being passed in here has no name to identify a core Rule,
            // so we add it as an anonymous rule
            // If the developer is wanting to use a core Rule, but use a different message see the 'addExtender' logic for examples
            exports.addAnonymousRule(observable, rule);
        });
        return observable;
    };

    //This is the extender that makes a Knockout Observable also 'Validatable'
    //examples include:
    // 1. var test = ko.observable('something').extend({validatable: true});
    // this will ensure that the Observable object is setup properly to respond to rules
    //
    // 2. test.extend({validatable: false});
    // this will remove the validation properties from the Observable object should you need to do that.
    ko.extenders['validatable'] = function (observable, enable) {
        if (enable && !utils.isValidatable(observable)) {

            observable.error = null; // holds the error message, we only need one since we stop processing validators when one is invalid

            // observable.rules:
            // ObservableArray of Rule Contexts, where a Rule Context is simply the name of a rule and the params to supply to it
            //
            // Rule Context = { rule: '<rule name>', params: '<passed in params>', message: '<Override of default Message>' }
            observable.rules = ko.observableArray(); //holds the rule Contexts to use as part of validation

            //in case async validation is occuring
            observable.isValidating = ko.observable(false);

            //the true holder of whether the observable is valid or not
            observable.__valid__ = ko.observable(true);

            observable.isModified = ko.observable(false);

            // we use a computed here to ensure that anytime a dependency changes, the
            // validation logic evaluates
            var h_obsValidationTrigger = ko.computed(function () {
                var obs = observable(),
                    ruleContexts = observable.rules();

                exports.validateObservable(observable);

                return true;
            });

            // a semi-protected observable
            observable.isValid = ko.computed(function () {
                return observable.__valid__();
            });

            //subscribe to changes in the observable
            var h_change = observable.subscribe(function () {
                observable.isModified(true);
            });

            observable._disposeValidation = function () {
                //first dispose of the subscriptions
                observable.isValid.dispose();
                observable.rules.removeAll();
                observable.isModified._subscriptions['change'] = [];
                observable.isValidating._subscriptions['change'] = [];
                observable.__valid__._subscriptions['change'] = [];
                h_change.dispose();
                h_obsValidationTrigger.dispose();

                delete observable['rules'];
                delete observable['error'];
                delete observable['isValid'];
                delete observable['isValidating'];
                delete observable['__valid__'];
                delete observable['isModified'];
            };
        } else if (enable === false && utils.isValidatable(observable)) {

            if (observable._disposeValidation) {
                observable._disposeValidation();
            }
        }
        return observable;
    };

    function validateSync(observable, rule, ctx) {
        //Execute the validator and see if its valid
        if (!rule.validator(observable(), ctx.params === undefined ? true : ctx.params)) { // default param is true, eg. required = true

            //not valid, so format the error message and stick it in the 'error' variable
            observable.error = exports.formatMessage(ctx.message || rule.message, ctx.params);
            observable.__valid__(false);
            return false;
        } else {
            return true;
        }
    }

    function validateAsync(observable, rule, ctx) {
        observable.isValidating(true);

        var callBack = function (valObj) {
            var isValid = false,
                msg = '';

            if (!observable.__valid__()) {

                // since we're returning early, make sure we turn this off
                observable.isValidating(false);

                return; //if its already NOT valid, don't add to that
            }

            //we were handed back a complex object
            if (valObj['message']) {
                isValid = valObj.isValid;
                msg = valObj.message;
            } else {
                isValid = valObj;
            }

            if (!isValid) {
                //not valid, so format the error message and stick it in the 'error' variable
                observable.error = exports.formatMessage(msg || ctx.message || rule.message, ctx.params);
                observable.__valid__(isValid);
            }

            // tell it that we're done
            observable.isValidating(false);
        };

        //fire the validator and hand it the callback
        rule.validator(observable(), ctx.params || true, callBack);
    }

    validation.validateObservable = function (observable) {
        var i = 0,
            rule, // the rule validator to execute
            ctx, // the current Rule Context for the loop
            ruleContexts = observable.rules(), //cache for iterator
            len = ruleContexts.length; //cache for iterator

        for (; i < len; i++) {

            //get the Rule Context info to give to the core Rule
            ctx = ruleContexts[i];

            // checks an 'onlyIf' condition
            if (ctx.condition && !ctx.condition())
                continue;

            //get the core Rule to use for validation
            rule = exports.rules[ctx.rule];

            if (rule['async'] || ctx['async']) {
                //run async validation
                validateAsync(observable, rule, ctx);

            } else {
                //run normal sync validation
                if (!validateSync(observable, rule, ctx)) {
                    return false; //break out of the loop
                }
            }
        }
        //finally if we got this far, make the observable valid again!
        observable.error = null;
        observable.__valid__(true);
        return true;
    };

    //#endregion

    //#region Validated Observable

    ko.validatedObservable = function (initialValue) {
        if (!exports.utils.isObject(initialValue)) { return ko.observable(initialValue).extend({ validatable: true }); }

        var obsv = ko.observable(initialValue);
        obsv.errors = exports.group(initialValue);
        obsv.isValid = ko.computed(function () {
            return obsv.errors().length === 0;
        });

        return obsv;
    };

    //#endregion

    //#region Localization

    //quick function to override rule messages
    validation.localize = function (msgTranslations) {

        var msg, rule;

        //loop the properties in the object and assign the msg to the rule
        for (rule in msgTranslations) {
            if (exports.rules.hasOwnProperty(rule)) {
                exports.rules[rule].message = msgTranslations[rule];
            }
        }
    };
    //#endregion

    //#region ApplyBindings Added Functionality
    ko.applyBindingsWithValidation = function (viewModel, rootNode, options) {
        var len = arguments.length,
            node, config;

        if (len > 2) { // all parameters were passed
            node = rootNode;
            config = options;
        } else if (len < 2) {
            node = document.body;
        } else { //have to figure out if they passed in a root node or options
            if (arguments[1].nodeType) { //its a node
                node = rootNode;
            } else {
                config = arguments[1];
            }
        }

        exports.init();

        if (config) { exports.utils.setDomData(node, config); }

        ko.applyBindings(viewModel, rootNode);
    };

    //override the original applyBindings so that we can ensure all new rules and what not are correctly registered
    var origApplyBindings = ko.applyBindings;
    ko.applyBindings = function (viewModel, rootNode) {

        exports.init();

        origApplyBindings(viewModel, rootNode);
    };

    //#endregion
}));

define('AddToFavoritesModule',['knockout', 'knockoutValidations'],
    function (ko) {
        "use strict";
        return function (id, productName, productDescription, allowToShareWithCompanyUsers, allowToShareWithAllUsers, isSharedWithCompanyUsers, isSharedWithAllUsers, callback) {
            var self;
            self = this;

            self.description = ko.observable(productDescription);
            self.allowToShareWithCompanyUsers = allowToShareWithCompanyUsers;
            self.allowToShareWithAllUsers = allowToShareWithAllUsers;
            self.isSharedWithCompanyUsers = ko.observable(isSharedWithCompanyUsers);
            self.isSharedWithAllUsers = ko.observable(isSharedWithAllUsers);
            self.productId = id;
            // Defines name observable with validation rules
            self.name = ko.observable(productName).extend({
                required: { message: self.fieldRequiredValMessage }
            });

            // Defines validation errors collection observable
            self.valErrors = ko.validation.group(self);

            self.confirm = function () {
                if (self.valErrors().length > 0) {
                    return;
                } else {
                    self.closeModal();
                    callback(this.productId, this.name(), this.description(), this.isSharedWithCompanyUsers(), this.isSharedWithAllUsers());
                }
            };

            self.closeAddToFavorites = function(data) {
	            self.closeModal();
            };

            self.saveAddToFavorites = function(data) {
	            self.confirm();
            };
        };
    });

define('ChargesModel',['knockout', 'Utility'],
    function (ko, utility) {
        "use strict";
        
        return function (serverData, item, cellAndFieldManager) {
            var charge = this;

            charge.id = ko.observable(serverData.Id);

            if (serverData.ValueOfSubscriptionParameter) {
                charge.valueOfSubscriptionParameter = ko.observable(cellAndFieldManager.createCell(serverData.ValueOfSubscriptionParameter));
            }
            charge.type = ko.observable(serverData.Type);
            charge.blockSize = ko.observable(serverData.BlockSize);
            charge.minimumBlocks = ko.observable(serverData.MinimumBlocks);
            charge.ratePlanElement = ko.observable(serverData.RatePlanElement);
            charge.typeDisplayName = ko.observable(charge.typeDisplayNames[serverData.Type]);

            switch (serverData.Type) {
                case "OneTime":
                    charge.price = buildSbChargePrice(serverData.Price);
                    break;
                case "Recurring":
                    charge.price = buildSbChargePrice(serverData.Price);
                    break;
                case "AllUnitVolumeRate":
                case "TierRate":
                    buildSbTierdVolumePricing(charge, serverData, item.id);
                    break;
                case "BlockRate":
                    buildSbBlockRatePricing(charge, serverData, item.id);
                    break;
                case "PercentageRate":                    
                    charge.price = buildSbChargePrice(serverData.Price);
                    charge.ratioOperation = ko.observable(cellAndFieldManager.createCell(serverData.RatioOperation));
                    charge.ratioValue = ko.observable(cellAndFieldManager.createCell(serverData.RatioValue));
                    break;
                default:
                    throw new Error("Not supported ChargeType");
            }

            function buildSbChargePrice(serverItem) {
                var price = {};
                price.id = ko.observable(serverItem.Id);
                price.value = ko.observable(serverItem.Value);
                /**
                 * Discount will be null if pricing parameters are fixed (if value is not from param, this is set on SB side)
                 */
                if (serverItem.hasOwnProperty('Discount')) {
                    price.discount = ko.observable(cellAndFieldManager.createCell(serverItem.Discount));
                }
                price.total = ko.observable(serverItem.Total);
                return price;

            };

            function buildSbTierdVolumePricing(charge, serverItem, itemId) {
                charge.minimumBlocks = ko.observable(serverItem.MinimumBlocks);
                charge.blockSize = ko.observable(serverItem.BlockSize);
                charge.tiers = ko.observableArray([]);

                utility.rebuildObservableArray(charge.tiers, serverItem.Tiers, function (serverItem, index) {
                    var tier = this;
                    tier.id = serverItem.Id;
                    tier.upTo = ko.observable(serverItem.UpTo);
                    tier.pricePerBlock = ko.observable(buildSbChargePrice(serverItem.PricePerBlock));
                    if (serverItem.FixedPrice) {
                        tier.fixedPrice = ko.observable(buildSbChargePrice(serverItem.FixedPrice));
                    };

                    return tier;
                });
            };
            
            function buildSbBlockRatePricing(charge, serverItem) {
                charge.includedQuantity = serverItem.IncludedQuantity;
                charge.blockSize = serverItem.BlockSize;
                charge.price = ko.observable(buildSbChargePrice(serverItem.Price));
            }

            return charge;
        };

    });
/*global define*/
/*jslint browser: true*/
define('Consts',[], function () {
    return {
        quote: {
            actions: {
                reassignActionId: 6,
                approvalHistoryActionId: 28,
                createPartialOrderId: 34,
                acceptProposalActoinId: 41,
                rejectProposalActoinId: 42,
                proposeChangesActoinId: 43,
                upgradeActionId: 51,
                voidDocumentActionId: 59,
                makePrimaryActionId: 73,
                placeOrderToERPActionId: 1823,
                placeOrderActionId: 10
            },
            item: {
                actions: {
                    editActionId: 2,
                    copyActionId: 3,
                    deleteActionId: 4,
                    upgradeActionId: 7,
                    favoriteActionId: 6,
                    replaceItemsActoinId: 45
                },
                itemsRenderBatchSize: 10
            }
        }
    }
});
/*global define*/
/*jslint browser: true*/
define('CartItemsModel',['jquery', 'knockout', 'CartServerProxy', 'DealViewServerProxy', 'DealSectionModel', 'mediator-js', 'Utility', 'AddToFavoritesModule', 'Toastr', 'ChargesModel', 'Consts'],
    function ($, ko, serverProxy, dealViewServerProxy, DealSectionModel, mediator, utility, AddToFavoritesModuleFactory, toastr, ChargeModelFactory, consts) {
        "use strict";

        var setSelected, updateData, toggleExpandedCallback, isInitialized;

        setSelected = function (items, isSelected) {
            ko.utils.arrayForEach(items(), function (item) {
                if (item.canBeDeleted) {
                    item.isSelected(isSelected);
                } else {
                    item.isSelected(false);
                }

                setSelected(item.childItems, isSelected);
            });
        };

        updateData = function (serverData) {
            mediator.publish("cartItemsModel.updateData", serverData);
        };

        toggleExpandedCallback = function () {
            mediator.publish("cartItemsModel.toggleExpanded");
        };

        return function (cellAndFieldManager, canReorderMainItems, canReorderLineItems, expandItemsByDefault, canManageItems, canReplaceItems, activeEditableGroup, favoritesEnabled, allowToShareWithCompanyUsers, allowToShareWithAllUsers, areVariantAndAlternativeAllowd, quoteItemFilterCache) {
            var self, buildItemsArray, ActonFactory, createItemTypeEditModel, getCartItemAndNumberCollection,
            self = this;

            ActonFactory = function (serverAction, item) {
                var action, confirmAndExecuteAction, executeItemAction, executeUpgradeAndEditAction, handleItemActionResult;
                action = this;
                action.id = serverAction.Id;
                action.name = serverAction.Name;

                if (action.id === consts.quote.item.actions.upgradeActionId) {
                    item.hasNewVersion = true;
                }

                action.execute = function () {
                    if (action.id === consts.quote.item.actions.editActionId && cellAndFieldManager.isCellOrCustomFieldsDirty()) {
                        utility.confirm("", self.discardUnsavedValuesMsg, function () {
                            cellAndFieldManager.clearCellsAndFields();
                            confirmAndExecuteAction();
                        });
                    } else {
                        confirmAndExecuteAction();
                    }
                };

                confirmAndExecuteAction = function () {
                    if (action.id === consts.quote.item.actions.editActionId && item.hasNewVersion) {
                        serverProxy.getCartItemProductUpgradeConfirmationMessage(item.cartItem, function (confirmationMessage) {
                            utility.dialog(
                                "",
                                confirmationMessage,
                                executeUpgradeAndEditAction,
                                executeItemAction
                            );
                        });
                    } else if (action.id === consts.quote.item.actions.copyActionId) {
                        utility.confirm("", self.confirmItemCopyMsg, executeItemAction);
                    } else if (action.id === consts.quote.item.actions.deleteActionId) {
                        utility.confirm("", self.confirmItemDeleteMsg, executeItemAction);
                    } else if (action.id === consts.quote.item.actions.favoriteActionId) {
                        var productName, productDescription, callback;
                        callback = function (resultData) {
                            productName = resultData.Name;
                            productDescription = resultData.Description;
                            var addToFavoritesModule = new AddToFavoritesModuleFactory(item.cartItem, productName, productDescription, allowToShareWithCompanyUsers(), allowToShareWithAllUsers(), false, false,
                            function (productId, name, description, isSharedWithCompanyUsers, isSharedWithAllUsers)
                            {
                            serverProxy.saveFavoriteFromCart(productId, name, description, isSharedWithCompanyUsers, isSharedWithAllUsers, saveCallback);
                            });

                            utility.activateModalFromTemplate(addToFavoritesModule, "AddToFavoritesDialogTemplate");
                        };
                        serverProxy.getProductNameAndDescription(item.itemDescription.productId(), callback);
                    } else {
                        executeItemAction();
                    }
                };

                var saveCallback = function (resultData) {
                    if (resultData.Success) {
                        toastr.success(resultData.Message);
                    } else {
                        toastr.error(resultData.Message);
                    }
                };

                executeItemAction = function () {
                    serverProxy.executeItemAction(serverAction.Id, item.cartItem, quoteItemFilterCache.getFiltersCondition(), item.id, handleItemActionResult);
                };

                executeUpgradeAndEditAction = function () {
                    serverProxy.upgradeAndEditProduct(item.cartItem, quoteItemFilterCache.getFiltersCondition(), handleItemActionResult);
                };

                handleItemActionResult = function (serverData) {
                    if (action.id === consts.quote.item.actions.editActionId) {
                        if (serverData.Message) {
                            updateData(serverData); // if has message than edit didn't succeed and we are staying on page
                        } else if (!serverData.IsConfigurationValid) {
                            // ask user to confirm opening invalid configurator
                            // dialog is mandatory because use cannot not answer the question
                            // because we must destroy environment
                            utility.mandatoryDialog(
                                "",
                                self.confirmOpeningInvalidConfiguratorMsg,
                                function () { serverProxy.navigateToConfigurator(); },
                                function () { serverProxy.cancelItemEdit(); });
                        } else {
                            // if edit was ok go to configurator
                            serverProxy.navigateToConfigurator();
                        }
                    } else {
                        updateData(serverData);
                        if (action.id === consts.quote.item.actions.deleteActionId) {
                            mediator.publish("cartItemsModel.itemDeleted");
                        }
                    }
                };
            };

            buildItemsArray = function (observableItemsArray, serverItemsArray, cellColumns, parentItem, searchedCartItem) {
                utility.rebuildObservableArray(observableItemsArray, serverItemsArray, function (serverItem, index) {
                    var item = this;
                    
                    item.showPricing = ko.observable(false);
                    item.id = serverItem.Id;
                    item.index = index;
                    item.isMainItem = serverItem.IsMainItem;
                    item.parent = parentItem;
                    item.nestingLevel = serverItem.NestingLevel;
                    item.cartItem = serverItem.CartItem;
                    item.isSearchMatch = serverItem.CartItem === searchedCartItem;
                    item.itemDescription = {
                        productId: ko.observable(serverItem.ItemDescription.ProductId),
                        partNumber: ko.observable(serverItem.ItemDescription.PartNumber),
                        partNumberEditableGroup: serverItem.ItemDescription.PartNumberEditableGroup,
                        description: ko.observable(serverItem.ItemDescription.Description),
                        productTypeName: ko.observable(serverItem.ItemDescription.ProductTypeName),
                        comment: ko.observable(serverItem.ItemDescription.Comment),
                        isCommentEditable: ko.observable(serverItem.ItemDescription.IsCommentEditable),
                        productName: ko.observable(serverItem.ItemDescription.ProductName)
                    };
                    item.itemNumber = ko.observable(serverItem.ItemNumber);

                    item.isItemNumberEditable = ko.pureComputed(function () {
                        return item.isMainItem && canManageItems();
                    });
                    item.isItemNumberChanged = function() {
                        return item.itemNumber() !== serverItem.ItemNumber;
                    };
                    item.isPartNumberEditable = ko.pureComputed(function () {
                        return item.isMainItem && canManageItems() && canReplaceItems() && item.itemDescription.partNumberEditableGroup === activeEditableGroup();
                    });
                    item.isPartNumberChanged = function () {
                        return item.itemDescription.partNumber() !== serverItem.ItemDescription.PartNumber;
                    };
                    item.partNumberSuggestionUrl = ko.observable(serverProxy.getPartNumberSuggestions());

                    item.isRestricted = serverItem.IsRestricted;
                    item.itemType = serverItem.ItemType;
                    item.baseCartItem = serverItem.BaseCartItem;
                    item.baseItemNumber = serverItem.BaseItemNumber;
                    item.productTypeName = serverItem.ProductTypeName;
                    item.isOptional = item.itemType === 3;
                    item.isInvalid = serverItem.IsInvalid;
                    item.isSapItem = serverItem.IsSapItem;

                    item.itemClassificationType = serverItem.ItemClassificationType;
                    item.isSubscription = serverItem.IsSubscription;
                    item.isIncomplete = serverItem.IsIncomplete;
                    item.isInconsistent = serverItem.Inconsistent;
                    item.hasIncompleteChildren = serverItem.HasIncompleteChildren;

                    item.effectiveDate = serverItem.EffectiveDate;
                    item.startDate = serverItem.StartDate;
                    item.contractLength = serverItem.ContractLength;
                    item.contractLengthDate = serverItem.ContractLengthDate;
                    item.minimumContractLength = serverItem.MinimumContractLength;
                    item.minimumContractLengthDate = serverItem.MinimumContractLengthDate;

                    item.isExpanded = ko.observable(serverItem.IsExpanded);

                    if (!isInitialized) {
                        if (!utility.useNewQuoteEngine) {
                            if (expandItemsByDefault() && serverItem.HasChildren) {
                                serverProxy.expandItem(item.cartItem, null);
                            } else {
                                serverProxy.collapseItem(item.cartItem, null);
                            };
                        };
                    }
                    
                    isInitialized = true;

                    item.isVisible = ko.pureComputed(function () {
                        return !parentItem || (parentItem.isVisible() && parentItem.isExpanded());
                    });
                    item.isSelected = ko.observable(false);

                    item.canBeMoved = (item.isMainItem && canReorderMainItems()) || (!item.isMainItem && canReorderLineItems());
                    item.moveUp = function () {
                        window.lastActiveElementId = 'itemAction' + item.id;
                        serverProxy.moveItemUp(item.cartItem, quoteItemFilterCache.getFiltersCondition(), updateData);
                    };

                    item.moveDown = function () {
                        window.lastActiveElementId = 'itemAction' + item.id;
                        serverProxy.moveItemDown(item.cartItem, quoteItemFilterCache.getFiltersCondition(), updateData);
                    };

                    item.moveToPosition = function(upItem) {
                        serverProxy.moveToPosition(item.cartItem, upItem === undefined ? 0 : upItem.cartItem, function(serverData) {
                            updateData(serverData);
                            mediator.publish("CartModel.itemsLoaded", item);
                        });
                    };
                    mediator.subscribe("CartModel.itemsLoaded", function () {
                        if (window.lastActiveElementId) {
                            var actionToggle = $('#' + $.escapeSelector(window.lastActiveElementId))[0];
                            actionToggle ? actionToggle.focus() : $('#quickAddInput').focus();
                            if ($('.add-product .popover').length) {
                                $('.add-product .popover').popover('hide');
                            };
                        }
                    });

                    item.favoritesEnabled = favoritesEnabled;

                    item.showFavoritesForProduct = function () {
                        serverProxy.navigateToFavoritesForProduct(item.itemDescription.productId());
                    };

                    item.isInSystem = serverItem.IsInSystem;
                    item.isFirstInSystem = serverItem.IsFirstInSystem;
                    item.isLastInSystem = serverItem.IsLastInSystem;

                    item.values = ko.utils.arrayMap(serverItem.Values, function (value, index) {
                        
                        if (item.isRestricted && value.EditableGroup) {
                            value.EditableGroup = -1;
                        }
                        if (value === Object(value)) {
                            value.ItemId = item.id;
                            if (cellColumns()[index]) {
                                value.ColumnName = cellColumns()[index].name;
                            }
                            
                        }

                        var cell = cellAndFieldManager.createCell(value);
                        cell.column = cellColumns()[index];
                        return cell;
                    });

                    item.hiddenValues = ko.observableArray(ko.utils.arrayMap(serverItem.HiddenValues, function (value, index) {
                        return cellAndFieldManager.createCell(value);
                    }));

                    item.getValue = function (columnName) {
                        // this function is added so it can be used in custom responsive templates (don't remove it)
                        var cell = ko.utils.arrayFirst(item.values, function (value) {
                            return value.column.name === columnName;
                        });

                        return cell && cell.value; // return null if cell is null
                    };

                    item.getHiddenValue = function (columnName) {
                        // this function is added so it can be used in custom responsive templates (don't remove it)
                        var cell = this.hiddenValues.first(function (x) {
                            if (x.id) {
                                return x.id.substring(0, columnName.length) === columnName;
                            }
                        });
                        return cell && cell.value();
                    }

                    item.upc = serverItem.UPC;

                    item.hasNewVersion = false;

                    item.canBeEdited = false;
                    item.canBeDeleted = false;
                    item.editItem = function () {
                        var editAction = ko.utils.arrayFirst(item.actions(), function (action) {
                            return action.id === consts.quote.item.actions.editActionId;
                        });

                        if (editAction) {
                            editAction.execute();
                        }
                    };

                    item.actions = ko.observableArray();
                    if (serverItem.Actions) {
                        utility.rebuildObservableArray(item.actions, serverItem.Actions, function (serverAction) {
                            var action = new ActonFactory(serverAction, item);
                            if (action.id === consts.quote.item.actions.editActionId) {
                                item.canBeEdited = true;
                            }

                            if (action.id === consts.quote.item.actions.deleteActionId) {
                                item.canBeDeleted = true;
                            }

                            return action;
                        });
                    }

                    item.hasAnyActon = !item.isRestricted && (item.canBeMoved || item.actions().length > 0);

                    item.hasChildren = serverItem.HasChildren;
                    item.childItems = ko.observableArray();
                    if (serverItem.ChildItems) {
                        buildItemsArray(item.childItems, serverItem.ChildItems, cellColumns, item, searchedCartItem);
                    }

                    item.toggleExpanded = function () {
                        window.lastActiveElementId = document.activeElement.id
                        item.isExpanded(!item.isExpanded());

                        // notify server to sync client and server state
                        if (item.isExpanded()) {
                            if (utility.useNewQuoteEngine) {
                                toggleExpandedCallback();
                            } else {
                                serverProxy.expandItem(item.cartItem, toggleExpandedCallback);
                            }
                        } else {
                            if (utility.useNewQuoteEngine) {
                                toggleExpandedCallback();
                            } else {
                                serverProxy.collapseItem(item.cartItem, toggleExpandedCallback);
                            }
                        }
                    };

                    item.createItemTypeEditModel = function () {
                        return createItemTypeEditModel(item, observableItemsArray);
                    };
                    
                    item.editComment = function () {
                        var model = {
                            comment: ko.observable(item.itemDescription.comment()),
                            isCommentEditable: item.itemDescription.isCommentEditable(),
                            canClose: true,
                            save: function (id) {
                                serverProxy.setCartItemComment(item.cartItem, model.comment(), function () {
                                    // if all ok (server didn't broke)
                                    item.itemDescription.comment(model.comment());
                                    model.closeModal();
                                });
                            },
                            invokerElementId: 'cartComment_' + item.id,
                            close: function () {
                                if (!model.comment()) {
                                    $('#itemAction' + item.id).focus();
                                };
                            }
                        };
                        
                        utility.activateModalFromTemplate(model, 'itemCommentTemplate');
                    };

                    // applies higher z-index for item-column in quote items table
                    item.applyHigherZIndex = function (item, event) {
                        $("#itemsTable tr").children("td").removeClass("higher-zindex");
                        $(event.target).closest("td").addClass("higher-zindex");
                    };

                    item.openCollaborationDialog = function () {
                        mediator.publish('API:lineItems:AddCollaborationComment', { item: item });
                    };

                    //Subscription item
                    item.sbPricingModel = ko.observable();
                    var uniqueId = window.location.hostname + '_' + item.id;
                    
                    item.initSBPricingModel = function (data) {
                        if (data && item.itemClassificationType === 1) {
                            item.charges = ko.observableArray([]);
                            utility.rebuildObservableArray(item.charges, data, function(serverItem, index) {
                                return new ChargeModelFactory(serverItem, item, cellAndFieldManager);
                            });
                        }                        
                    }

                    item.initSBPricingModel(serverItem.Charges);

                    item.showSubscriptionDetails = function () {
                        if (!item.showPricing()) {
                            sessionStorage.setItem(uniqueId, 'true');
                            item.showPricing(true);
                        }
                        else {
                            sessionStorage.removeItem(uniqueId);
                            item.showPricing(false);
                        }
                    }

                    var sessionPricingModel = sessionStorage.getItem(uniqueId);
                    if (sessionPricingModel) {
                        item.showSubscriptionDetails();
                    }

                    item.getItemTooltipMessage = ko.pureComputed(function() {
                        if (item.isSapItem) {
                            if (item.isIncomplete && item.isInvalid) {
                                return self.notCompleteAndInvalidFromCPS;
                            }
                            else {
                                if (item.isIncomplete) {
                                    return self.notComplete;
                                }
                                else if (item.isInvalid) {
                                    return self.invalidCameFromCPS;
                                }
                            }
                        }
                        else {
                            return self.notComplete;
                        }
                    });

                    var sectionTitle = ko.observable();
                    item.titleOpened = ko.observable(false);
                    item.section = ko.observable(serverItem.Section);
                    item.sectionTitle = ko.computed({
                        read: function () {
                            if (!item.titleOpened())
                                return;

                            if (!item.section())
                                return self.notAllocatedInSection;

                            if (sectionTitle()) {
                                return sectionTitle();
                            }
                            setTimeout(function () {
                                dealViewServerProxy.getDealSectionByPath(item.section(), function (section) {
                                    var sectionModel = new DealSectionModel(section);
                                    sectionTitle(self.allocatedInSection + ': ' + sectionModel.getTitle());
                                });
                            }, 10)

                        },
                        write: function (value) {
                            sectionTitle(value);
                        }
                    });

                    item.recurringPricePeriod = ko.observable(serverItem.RecurringPricePeriod);
                    item.recurringPricePeriodDisplay = ko.pureComputed(function () {
                        return self.recurringPricePeriods[item.recurringPricePeriod()]
                    });
                    item.recurringCostPeriod = ko.observable(serverItem.RecurringCostPeriod);
                    item.recurringCostPeriodDisplay = ko.pureComputed(function () {
                        return self.recurringPricePeriods[item.recurringCostPeriod()];
                    });
                });
            };

            getCartItemAndNumberCollection = function (observableItemsArray, predicate) {
                var filteredArray, resultArray;
                filteredArray = ko.utils.arrayFilter(observableItemsArray(), predicate);
                resultArray = ko.utils.arrayMap(filteredArray, function (item) {
                    return {
                        id: item.cartItem,
                        value: item.itemNumber()
                    };
                });

                return ko.observableArray(resultArray);
            };

            createItemTypeEditModel = function (item, observableItemsArray) {
                var model, isBaseOrOptional, getSelectedBaseItem;

                model = {};
                isBaseOrOptional = item.itemType === 0 || item.itemType === 3;

                model.baseItemType = 0;
                model.alternativeItemType = 1;
                model.variantItemType = 2;
                model.optonalItemType = 3;

                model.alternativeOptions = getCartItemAndNumberCollection(observableItemsArray, function (currentItem) {
                    return currentItem !== item && currentItem.isMainItem && currentItem.itemType !== model.alternativeItemType;
                });
                model.selectedAlternativeBaseItem = ko.observable(item.baseItemNumber);
                model.variantOptions = getCartItemAndNumberCollection(observableItemsArray, function (currentItem) {
                    return currentItem !== item && currentItem.isMainItem && currentItem.itemType === model.baseItemType;
                });
                model.selectedVariantBaseItem = ko.observable(item.baseItemNumber);
                model.selectedItemType = ko.observable(item.itemType);

                model.showBaseItemType = item.isMainItem || isBaseOrOptional;
                model.showAlternativeItemType = item.isMainItem && areVariantAndAlternativeAllowd();
                model.showVariantItemType = item.isMainItem && areVariantAndAlternativeAllowd();
                model.showOptonalItemType = item.isMainItem || isBaseOrOptional;

                getSelectedBaseItem = function () {
                    if (model.selectedItemType() === model.alternativeItemType) {
                        return model.selectedAlternativeBaseItem();
                    } else if (model.selectedItemType() === model.variantItemType) {
                        return model.selectedVariantBaseItem();
                    } else {
                        return "0";
                    }
                };

                model.apply = function () {
                    mediator.publish("itemTypeEditModel.changeItemType", item.cartItem, model.selectedItemType(), getSelectedBaseItem());
                };

                return model;
            };

            self.buildItemsArray = function (observableItemsArray, serverItemsArray, cellColumns, searchedCartItem) {
                buildItemsArray(observableItemsArray, serverItemsArray, cellColumns, null, searchedCartItem);
            };

            self.selectAll = function (mainItems) {
                setSelected(mainItems, true);
            };

            self.deselectAll = function (mainItems) {
                setSelected(mainItems, false);
            };

            self.getSelectedCartItems = function (mainItems) {
                var selecteChildItems = [], selectdeItems = [];
                ko.utils.arrayForEach(mainItems(), function (item) {
                    if (item.isSelected()) {
                        selectdeItems.push(item.cartItem);
                    }

                    selecteChildItems = self.getSelectedCartItems(item.childItems);
                    ko.utils.arrayForEach(selecteChildItems, function (item) {
                        selectdeItems.push(item);
                    });
                });

                return selectdeItems;
            };

            self.getReorderItems = function(mainItems) {
                var childResult = [], result = [];
                ko.utils.arrayForEach(mainItems(), function(item) {
                    if (item.isItemNumberChanged()) {
                        result.push({
                            CartItem: item.cartItem,
                            ItemNumber: item.itemNumber()
                        });
                    }

                    childResult = self.getReorderItems(item.childItems);
                    ko.utils.arrayForEach(childResult, function(item) {
                        result.push(item);
                    });
                });

                return result;
            };
        };
    });

/*global define*/
/*jslint browser: true*/
define('CatalogServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getInitData: function (callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetInitData",
                    success: callback
                });
            },

            getData: function (data, callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetData",
                    data: data,
                    success: callback
                });
            },

            getProductsCount: function (data, callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetProductsCount",
                    data: data,
                    success: callback
                });
            },

            getReplacementProductId: function (data, callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetReplaceProductId",
                    method: 'GET',
                    data: { orginalProductId: data },
                    success: callback
                });
            },

            getQuickAddProductsAndFavorites: function (search, callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetQuickAdd",
                    method: 'GET',
                    data: { search: search },
                    success: callback,
                    global: false // don't show loader
                });
            },

            reset: function () {
                $.ajax({
                    url: "/api/rd/v1/Catalog/Reset",
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': csrfToken
                    }
                });
            },

            activateAbs: function (absId, categoryId) {
                if (!categoryId) {
                    categoryId = 0;
                }

                window.location.href = this.createConfigureUrl(absId, categoryId);
            },

            clearAbs: function (data, callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/clearAbs",
                    method: 'POST',
                    data: data,
                    headers: {
                        'X-CSRF-Token': csrfToken
                    },
                    success: callback
                });
            },

            addToQuote: function (productId, quantity, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Catalog/AddToQuote", { productId: productId, quantity: quantity }), callback);
            },

            addToQuoteWithSection: function (productId, quantity, section, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Catalog/AddToQuote", { productId: productId, quantity: quantity, section: section }), callback);
            },

            createConfigureUrl: function (prodId, categoryId, section) {
                var data = { pid: prodId, cid: categoryId };
                if (section) {
                    data.section = section;
                }

                return utility.buildUrl("/Configurator.aspx", data);
            },

            crateViewDetailsUrl: function (prodId, section) {
                if (section) {
                    return utility.buildUrl("/ProductDetails", { ProductId: prodId, section: section });
                }
                return utility.buildUrl("/ProductDetails", { ProductId: prodId });
            },

            crateViewDetailsNoMasterUrl: function (prodId) {
                return utility.buildUrl("/Catalogue/CompareCatalogueNoMasterPage.aspx", { productId: prodId });
            },

            createGetSearchSuggestionsUrl: function (categoryId) {
                var url = utility.buildUrl("/api/rd/v1/Catalog/GetSearchSuggestions", { c: categoryId });
                url += "&query=%QUERY";
                return url;
            },

            navigateToFavoritesPage: function (prodId) {
                window.location.href = utility.buildUrl("/Favorites/Favorites.aspx", { productId: prodId });
            },

            deleteFavoriteFromCatalog: function (favoriteId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/DeleteFavorite", {favoriteId: favoriteId}), callback);
            },

            saveFavoriteFromCatalog: function (productId, name, description, isSharedWithCompanyUsers, isSharedWithAllUsers, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/SaveFavoriteFromCatalog", { productId: productId, name: name, description: description, isSharedWithCompanyUsers: isSharedWithCompanyUsers, isSharedWithAllUsers: isSharedWithAllUsers }), callback);
            },

            createSearchUrl: function (search) {
                return utility.buildUrl("/Catalog", { search: search });
            },

            quickConfig: function (search, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Catalog/QuickConfig", { catalogCode: search }), callback);
            },

            getSBRatePlanByProduct: function (productId, callback) {
                $.getJSON("/api/rd/v1/Catalog/GetRatePlanForProductAndMarket", { productId: productId }, callback);
            }

        };
    });

/*global define*/
/*jslint browser: true*/
define('FavoritesServerProxy',['jquery', 'Utility'],
    function($, utility) {
        "use strict";

        return {

            getInitData: function (productId, nameFilter, callback) {
                $.ajax({
                    url: utility.buildUrl("/api/rd/v1/Favorites/GetInitData", { productId: productId, nameFilter: nameFilter }),
                    success: callback
                });
            },
            getData: function (filter, callback) {
                utility.postJson("/api/rd/v1/Favorites/GetData", filter, callback);
            },
            deleteFavorite: function (data, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/DeleteFavoriteFromFavoritesList", { favoriteId: data.favoriteId }), data.filter, callback);
            },
            addToQuote: function (favoriteId, quantity, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/AddToQuote", {
                    favoriteId: favoriteId,
                    quantity: quantity
                }), callback);
            },
            editFavoriteFromFavoritesList: function (favoriteId, name, description, isSharedWithCompanyUsers, isSharedWithAllUsers, filter, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/UpdateFavoriteFromFavoritesList", { favoriteId: favoriteId, name: name, description: description, isSharedWithCompanyUsers: isSharedWithCompanyUsers, isSharedWithAllUsers: isSharedWithAllUsers }), filter, callback);
            },
            createConfigureUrl: function (favoriteid) {
                return utility.buildUrl("/Configurator.aspx", { favId: favoriteid });
            },
            editConfigurableFavorite: function (favoriteId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Favorites/EditFavorite", {
                    favId: favoriteId
                }), callback);
            },
            createSearchUrl: function (nameFilter) {
                return utility.buildUrl("/Favorites/Favorites.aspx", { nameFilter: nameFilter });
            },
            navigateToConfiguratorPage: function () {
                window.location.href = "/Configurator.aspx";
            },
            navigateToProductConfigurator: function (url) {
                window.location.href = url;
            },
            getCategoriesData: function (callback) {
                $.ajax({
                    url: "/api/rd/v1/Catalog/GetCategoriesData",
                    success: callback
                });
            },
            getFavoritesViewDefaultData: function (callback) {
                $.ajax({
                    url: "/api/rd/v1/Favorites/GetFavoritesDefaultData",
                    success: callback
                });
            }
        };
    });

/*global define*/
/*jslint browser: true*/
define('Common',['jquery', 'mediator-js', 'Utility', 'CatalogServerProxy', 'Toastr'],
    function ($, mediator, utility, catalogServerProxy, toastr) {
        "use strict";

        var getDebuggerUrl, getSyntaxCheckerUrl, addToQuote, addToQuoteWithSection, viewDetails;

        getDebuggerUrl = function(debuggerPage) {
            return '../Debug/' + debuggerPage + '?rrr=' + Math.random();
        };

        getSyntaxCheckerUrl = function (syntaxCheckerPage, fldName) {
            return '../../Admin/' +
                syntaxCheckerPage +
                '?pfield=' +
                fldName +
                '&trigger=no&fieldName=Formula&ConditionField=NoCondition';
        };

        addToQuote = function(id, quantity) {
            var callback;
            callback = function(resultData) {
                if (!resultData.Ok) {
                    toastr.error(resultData.Message, self.errorOnAddingToCart);
                }
                if (resultData.RedirectionUrl) {
                    window.location.href = resultData.RedirectionUrl;
                } else if (resultData.Ok) {
                    toastr.success(resultData.Message);
                    mediator.publish("CartSummary.changeNoMainItems", resultData.MainItemsNumber);
                }
            };
            catalogServerProxy.addToQuote(id, quantity, callback);
        };

        addToQuoteWithSection = function (id, quantity, section, callback) {
            catalogServerProxy.addToQuoteWithSection(id, quantity, section, callback);
        }

        viewDetails = function (productId, fromCart) {
            // we are using lazy load for ProductDetailsModel to avoid circular reference confilict because ProductDetailsModel is also referencing Common
            require(['ProductDetailsModel'], function (ProductDetailsModel) {
                utility.activateModalFromTemplate(new ProductDetailsModel(productId, fromCart), "ProductDetailsModal");
            });

        };

        return {
            getDebuggerUrl: getDebuggerUrl,
            getSyntaxCheckerUrl: getSyntaxCheckerUrl,
            viewDetails: viewDetails,
            addToQuote: addToQuote,
            addToQuoteWithSection: addToQuoteWithSection
        };
    });

/*global define, requirejs*/
/*jslint browser: true*/
define('CartQuickAddModel',['knockout', 'CatalogServerProxy', 'FavoritesServerProxy', 'mediator-js', 'Utility', 'Toastr', 'Common'],
function (ko, catalogServerProxy, favoritesServerProxy, mediator, utility, toastr, common) {
        "use strict";
        return function () {

            var self, updateQuickAdd, ProductFactory, FavoriteFactory, quickConfigCallback;

            self = this;

            //#region Helpers

            ProductFactory = function (serverItem) {
                this.id = serverItem.Id;
                this.name = serverItem.Name;
                this.description = serverItem.Description;
                this.partNumber = serverItem.PartNumber;
                this.price = serverItem.Price;
                this.productTypeId = serverItem.ProductTypeId;
                this.productTypeName = serverItem.ProductTypeName;
                this.imageUrl = serverItem.ImageUrl;
                this.categoryId = serverItem.CategoryId;
                this.categoryName = serverItem.CategoryName;
                this.quantity = ko.observable(1);
                this.canAddToQuote = serverItem.CanAddToQuote;
                this.partNumberExistInPricebook = serverItem.PartNumberExistInPricebook;
                this.canAlterQuantity = serverItem.CanAlterQuantity;
                this.canConfigure = serverItem.CanConfigure;
                this.configuratorUrl = catalogServerProxy.createConfigureUrl(this.id, this.categoryId);
                this.isDiscontinued = serverItem.EndStatus === 1;
                this.isReplaced = serverItem.EndStatus === 2;

                this.addBtnDisabpledExplanation = '';

                if (!this.canAddToQuote) {
                    if (this.partNumberExistInPricebook) {
                        this.addBtnDisabpledExplanation = this.name + '&nbsp;' + self.cannotAddIncompleteMsg;
                    } else {
                        this.addBtnDisabpledExplanation = this.name + '&nbsp;' + self.cannotBeQuotedOrSoldMsg;
                    }
                }
                this.baseOnProductName = null;
            };

            FavoriteFactory = function (serverItem) {
                this.id = serverItem.FavoriteId;
                this.name = serverItem.FavoriteName;
                this.description = serverItem.FavoriteDescription;
                this.partNumber = serverItem.FavoritePartNumber;
                this.baseOnProductName = serverItem.BaseOnProductName;
                this.visibleForCompanyId = serverItem.VisibleForCompanyId;
                this.visibleToEveryone = serverItem.VisibleToEveryone;
                this.categoryName = serverItem.FavoriteCategory;
                this.quantity = ko.observable(1);
                this.canAlterQuantity = serverItem.CanEnterQty;
                this.canConfigure = !serverItem.IsSimple;
                this.configuratorUrl = favoritesServerProxy.createConfigureUrl(this.id);
                this.imageUrl = null;
                this.productTypeName = null;
                this.addBtnDisabpledExplanation = null;
                this.canAddToQuote = true;
                this.BaseOnProductId = serverItem.BaseOnProductId;
                this.isDiscontinued = serverItem.EndStatus === 1;
                this.isReplaced = serverItem.EndStatus === 2;
            };

            ProductFactory.prototype.addToQuote = function () {
                mediator.publish("CartQuickAddModel.addToQuote", this.id, this.quantity());
                if (self.close) {
                    self.close();
                }
                window.lastActiveElementId = 'quickAddInput';
            };

            ProductFactory.prototype.viewReplacement = function () {
                catalogServerProxy.getReplacementProductId(this.id, function (replacementProductId) {
                    common.viewDetails(replacementProductId, true);
                });
            };

            FavoriteFactory.prototype.viewReplacement = function () {
                catalogServerProxy.getReplacementProductId(this.BaseOnProductId, function (replacementProductId) {
                    common.viewDetails(replacementProductId, true);
                });
            };

            FavoriteFactory.prototype.addToQuote = function () {
                mediator.publish("CartQuickAddModel.addFavoriteToQuote", this.id, this.quantity());
                if (self.close) {
                    self.close();
                }
            };

            updateQuickAdd = function (serverData) {
                if (serverData) {
                    self.hasMoreQuickAddProducts(serverData.HasMoreProductsMatching);
                    utility.rebuildObservableArray(self.quickAddProducts, serverData.Products, ProductFactory);
                    self.isFavoriteSearchEnabled(serverData.IsFavoriteSearchEnabled);
                    if (self.isFavoriteSearchEnabled() === true) {
                        self.hasMoreQuickAddFavorites(serverData.HasMoreFavoritesMatching);
                        utility.rebuildObservableArray(self.quickAddFavorites, serverData.Favorites, FavoriteFactory);
                    }
                } else {
                    self.isFavoriteSearchEnabled(false);
                    self.hasMoreQuickAddProducts(false);
                    self.quickAddProducts([]);
                    self.hasMoreQuickAddFavorites(false);
                    self.quickAddFavorites([]);
                }

                self.isLoadingInProgress(false);
                mediator.publish("CartQuickAddModel.quickAddLoaded");
            };

            quickConfigCallback = function (serverData) {
                if (serverData.ErrorMessage) {
                    toastr.error(serverData.ErrorMessage);
                }
                else {
                    window.location.href = utility.buildUrl("/Configurator.aspx?xr=" + Math.random());
                }
            };

            //#endregion

            //#region State

            self.quickAddSearch = ko.observable("");
            self.quickAddSearchThrottled = ko.computed(function () {
                return self.quickAddSearch();
            }).extend({ rateLimit: { timeout: 300, method: "notifyWhenChangesStop" } });
            self.quickAddHasFocus = ko.observable(false);
            self.quickAddProducts = ko.observableArray([]);
            self.hasMoreQuickAddProducts = ko.observable(false);
            self.isFavoriteSearchEnabled = ko.observable(false);
            self.quickAddFavorites = ko.observableArray();
            self.hasMoreQuickAddFavorites = ko.observable(false);
            self.isLoadingInProgress = ko.observable(false);

            self.searchCatalogUrl = ko.computed(function () {
                return catalogServerProxy.createSearchUrl(self.quickAddSearch());
            });

            self.searchFavoritesUrl = ko.computed(function () {
                return favoritesServerProxy.createSearchUrl(self.quickAddSearch());
            });

            self.quickConfig = function () {
                return catalogServerProxy.quickConfig(self.quickAddSearch(), quickConfigCallback);
            };

            self.isLoadingInProgress(false);

            //#endregion

            //#region Handlers

            self.quickAddSearchThrottled.subscribe(function (newValue) {
                self.isLoadingInProgress(true);
                if (newValue) {
                    mediator.publish('RecommendationsModel.cancelRequest', true);
                    catalogServerProxy.getQuickAddProductsAndFavorites(newValue, updateQuickAdd);
                } else {
                    updateQuickAdd(null);
                }
            });

            //#endregion
        };
    }
);

/*global define, requirejs*/
/*jslint browser: true*/
define('CartItemsSearchModel',['knockout', 'CartServerProxy', 'FavoritesServerProxy', 'mediator-js', 'Utility'],
function (ko, cartServerProxy, favoritesServerProxy, mediator, utility) {
    "use strict";
    return function () {

        var self, updateSearchItems, ItemFactory;

        self = this;

        //#region Helpers

        ItemFactory = function (serverItem) {
            this.cartItem = serverItem.CartItem;
            this.itemNumber = serverItem.ItemNumber;
            this.partNumber = serverItem.PartNumber;
            this.description = serverItem.Description;
            this.productTypeName = serverItem.ProductTypeName;
            this.productName = serverItem.ProductName;
        };

        ItemFactory.prototype.jumpToItem = function () {
            mediator.publish("CartItemSearchModel.jumpToItem", this.cartItem);
            if (self.close) {
                self.close();
            }
        };

        ItemFactory.prototype.clickOnEnter = function (event) {
            if (event.key === "Enter") {
                this.jumpToItem();
            };
        };

        updateSearchItems = function (serverData) {
            serverData = serverData || [];
            utility.rebuildObservableArray(self.items, serverData, ItemFactory);
            self.isLoadingInProgress(false);
            mediator.publish("CartQuickAddModel.searchItemsLoaded");
        };

        //#endregion

        //#region State

        self.search = ko.observable("");
        self.searchThrottled = ko.computed(function () {
            return self.search();
        }).extend({ rateLimit: { timeout: 300, method: "notifyWhenChangesStop" } });
        self.hasFocus = ko.observable(false);
        self.items = ko.observableArray();
        self.isLoadingInProgress = ko.observable(false);

        //#endregion

        //#region Handlers

        self.searchThrottled.subscribe(function (newValue) {
            self.isLoadingInProgress(true);
            if (newValue) {
                cartServerProxy.searchItems(newValue, updateSearchItems);
            } else {
                updateSearchItems(null);
            };
        });

        //#endregion
    };
}
);

/*global define, requirejs*/
/*jslint browser: true*/
define('CartApprovalModel',['knockout', 'Utility', 'mediator-js', 'Slider'],
    function (ko, utility, mediator, SliderFactory) {
        "use strict";
        return function () {

            var self, ConditionFactory, ApprovalSliderFactory;

            self = this;

            ConditionFactory = function (serverCondition) {
                this.name = serverCondition.Name;
                this.description = serverCondition.Description;
                this.approvers = serverCondition.Approvers;
                if (serverCondition.Slider) {
                    this.slider = new ApprovalSliderFactory(serverCondition.Slider);
                }
            };

            ApprovalSliderFactory = function (serverSlider) {
                var that = this;
                that.sliderId = serverSlider.SliderId;
                that.bgColor = serverSlider.BgColor;
                that.bgImage = serverSlider.BgImage;
                that.isEditable = serverSlider.IsEditable;
                that.slider = new SliderFactory(serverSlider.Slider, function () {
                    mediator.publish("CartApproval.applySliderValue", that.sliderId, that.slider.value());
                });

                that.getSlider = function () {
                    return that.slider;
                };
            };

            //#region State

            self.errorMessage = ko.observable('');
            self.conditions = ko.observableArray();

            //#endregion

            //#region Methods

            self.update = function (serverData) {
                if (serverData) {
                    self.errorMessage(serverData.ErrorMessage);
                    utility.rebuildObservableArray(self.conditions, serverData.Conditions, ConditionFactory);
                } else {
                    self.errorMessage('');
                    self.conditions([]);
                }
            };

            //#endregion
        };
    }
);

/*global define*/
/*jslint browser: true*/
define('CartListServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getInitData: function (callback) {
                $.get("/api/rd/v1/CartList/GetInitData", null, callback);
            },

            getData: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/GetData", data, callback);
            },

            getDataByQuoteNumber: function (quoteNumber, callback) {
                $.getJSON("/api/rd/v1/CartList/GetDataByQuoteNumber", quoteNumber === null || quoteNumber.length === 0 ? {} : { quoteNumber: quoteNumber }, callback);
            },

            executeAction: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/ExecuteAction", data, callback);
            },

            executeApprovals: function(data, callback) {
                utility.postJson("/api/rd/v1/CartList/ExecuteApprovals", data, callback);
            },

            retractApproval: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/RetractApprovalProcess", data, callback);
            },

            executeGetUserTypesForReassign: function (callback) {
                utility.postJson("/api/rd/v1/CartList/GetUserTypesForReassign", null, callback);
            },

            executeGetUsersForReassign: function (userTypeId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/CartList/GetUsersForReassign", { userTypeId: userTypeId }), callback);
            },

            reassign: function (newUserId, ownerId, cartId, callback) {
                var urlData = {
                    newUserId: newUserId,
                    ownerId: ownerId,
                    cartId: cartId };

                utility.postJson(utility.buildUrl("/api/rd/v1/CartList/Reassign", urlData), callback);
            },

            changeStatus: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/ChangeStatus", {
                    ActionId: data.actionId,
                    CryptedOwnerId: data.cryptedOwnerId,
                    CryptedCartId: data.cryptedCartId,
                    NewStatus: data.newStatus,
                    GetDataRequest: data.GetDataRequest
                }, callback);
            },

            viewCart: function (ownerId, cartId) {
                var url = utility.buildUrl("/Quotation/QuoteView.aspx", { OwnerId: ownerId, CartId: cartId });
                utility.showLoaderAndOverlay();
                window.location = url;
                return false;
            },

            previewCart: function (ownerId, cartId) {
                var url = utility.buildUrl("/Quotation/QuotePreview.aspx", { OwnerId: ownerId, CartId: cartId });
                utility.showLoaderAndOverlay();
                window.location = url;
                return false;
            },

            viewHistory: function (ownerId, cartId) {
                var url = utility.buildUrl("/Quotation/CartHistory.aspx", { rc: cartId, ro: ownerId });
                utility.showLoaderAndOverlay();
                window.location = url;
                return false;
            },

            viewRevision: function (ownerId, cartId) {
                var url = utility.buildUrl("/Quotation/Revisions.aspx", { cr: 1, o: ownerId, c: cartId });
                window.location = url;
                return false;
            },

            approvalHistory: function (ownerId, cartId) {
                var url = utility.buildUrl("/quotation/ApprovalHistory.aspx", { rc: cartId, ro: ownerId });
                window.location = url;
                return false;
            },

            saveSettings: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/SaveSettings", data, callback);
            },

            saveData: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/SaveData", data, callback);
            },

            createNewCart: function (refer, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/CreateNew", { refer: refer }), callback);
            }
        };
    });

define('CartReassignModule',['knockout', 'CartListServerProxy', 'Utility', 'mediator-js', 'Toastr'],
    function (ko, serverProxy, utility, mediator, toastr) {
        "use strict";
        return function (ownerId, cartId) {
            var self;
            self = this;

            self.ownerId = ownerId;
            self.cartId = cartId;
            self.userTypes = ko.observableArray();
            self.users = ko.observableArray();
            self.selectedUserTypeId = ko.observable();
            self.selectedUserId = ko.observable();

            self.assign = function () {
                if (!self.selectedUserId()) {
                    toastr.error(self.noUserSelectedMsg);
                    return;
                }

                serverProxy.reassign(self.selectedUserId(), self.ownerId, self.cartId, function () {
                    self.closeModal();
                    mediator.publish("CartReassignModule.CartReassigned");
                });
            };

            self.selectedUserTypeId.subscribe(function () {
                if (self.selectedUserTypeId()) {
                    serverProxy.executeGetUsersForReassign(self.selectedUserTypeId(), function (serverData) {
                        utility.rebuildObservableArray(self.users, serverData, function (serverItem) {
                            this.id = serverItem.Id;
                            this.value = serverItem.Name;
                        });
                    });
                } else {
                    self.users([]);
                }
            });

            // get init data
            serverProxy.executeGetUserTypesForReassign(function (serverData) {
                utility.rebuildObservableArray(self.userTypes, serverData, function (serverItem) {
                    this.id = serverItem.Id;
                    this.value = serverItem.Name;
                });
            });
        };
    });

define('CreatePartialOrderModule',['knockout', 'Utility', 'CartServerProxy', 'Toastr', 'knockoutValidations'],
    function (ko, utility, cartServerProxy, toastr) {
        "use strict";
        return function () {
            var self, initData, getPartialOrderRequestData, setCollectionSelected, buildProductsArray, setChildsQty, setChildsSelected;
            self = this;
            self.products = ko.observableArray();
            self.selectAll = ko.observable(true);

            // Defines validation errors collection observable
            self.valErrors = ko.validation.group(self);

            buildProductsArray = function (observableArray, serverData, nestingLevel, parentQty) {
                utility.rebuildObservableArray(observableArray, serverData, function (serverItem) {
                    var that = this;
                    that.isSelectedEditable = serverItem.IsSelectedEditable;
                    that.cartItem = serverItem.CartItem;
                    that.rolledUpCartItem = serverItem.RolledUpCartItem;
                    that.partNumber = serverItem.PartNumber;
                    that.netPrice = serverItem.NetPrice;
                    that.negotiatedQtyInMasterQuote = serverItem.NegotiatedQtyInMasterQuote;
                    that.qtyOrderedInPreviousPartialOrders = serverItem.QtyOrderedInPreviousPartialOrders;
                    that.isSelected = ko.observable(true);
                    that.newQty = ko.observable(serverItem.NewQty).extend({
                        validation: {
                            validator: function (val) {
                                return !(that.isSelected() === true && val === 0);
                            },
                            message: self.qtyCantBeZero
                        }
                    });
                    if (parentQty) {
                        that.parentChildQtyRatio = that.newQty() / parentQty;
                    }
                    that.isQtyEditable = serverItem.IsQtyEditable;
                    that.nestingLevel = nestingLevel;

                    that.lineItemsList = ko.observableArray();
                    if (serverItem.PartialOrderLineItems) {
                        buildProductsArray(that.lineItemsList, serverItem.PartialOrderLineItems, nestingLevel + 1, that.newQty());
                    }
                    that.isSelected.subscribe(function (value) {
                        setChildsSelected(that.lineItemsList(), value);
                    });
                    that.newQty.subscribe(function (value) {
                        var numericValue = parseFloat(value);
                        if (isNaN(numericValue)) {
                            numericValue = 0;
                        }
                        that.newQty(numericValue);
                        setChildsQty(that.lineItemsList(), value);
                    });
                });
            };

            initData = function (serverData) {
                buildProductsArray(self.products, serverData, 0);
            };

            cartServerProxy.getPartialOrderInitialData(initData);

            self.selectAll.subscribe(function (newValue) {
                setCollectionSelected(self.products(), newValue);
            });

            self.confirm = function () {
                var rowsSelection = [];
                getPartialOrderRequestData(self.products(), rowsSelection);

                var callbackRedirect = function () {
                    self.closeModal();
                    cartServerProxy.navigateToNewCart();
                };

                if (self.valErrors().length > 0) {
                    return;
                }
                else if (rowsSelection.length > 0) {
                    cartServerProxy.createPartialOrder(rowsSelection, callbackRedirect);
                } else {
                    toastr.error(self.noItemsSelected);
                }
            };

            getPartialOrderRequestData = function (collection, rowsSelection) {
                ko.utils.arrayForEach(collection, function (item) {
                    var rowsObject = {};
                    if (item.isSelected()) {
                        rowsObject.cartItem = item.cartItem;
                        rowsObject.quantity = item.newQty();
                        rowsSelection.push(rowsObject);
                    }
                    getPartialOrderRequestData(item.lineItemsList(), rowsSelection);
                });
            };

            setCollectionSelected = function (collection, isSelected) {
                ko.utils.arrayForEach(collection, function (item) {
                    item.isSelected(isSelected);
                    setCollectionSelected(item.lineItemsList(), isSelected);
                });
            };

            setChildsSelected = function (collection, isSelected) {
                ko.utils.arrayForEach(collection, function (item) {
                    if (item.isSelectedEditable === false) {
                        item.isSelected(isSelected);
                    }
                    setChildsSelected(item.lineItemsList(), item.isSelected());
                });
            };
            setChildsQty = function (collection, qty) {
                ko.utils.arrayForEach(collection, function (item) {
                    if (item.isSelectedEditable === false) {
                        var newQtyCalculated = qty * item.parentChildQtyRatio;
                        item.newQty(newQtyCalculated);
                    }
                    setChildsQty(item.lineItemsList(), item.newQty());
                });
            };
        };
    });

define('CartPromotionsModel',['knockout', 'Utility', 'CartServerProxy', 'Toastr'],
    function (ko, utility, cartServerProxy, toastr) {
        "use strict";
        return function() {
            var self, initData, PromotionFactory, ActionOffersFactory, getApplyPromotionsRequestData,
                setCollectionSelection, PromoConditionFactory, buildPromoActionsArray;
            self = this;

            self.promotions = ko.observableArray();
            self.onePromoPerQuote = ko.observable(false);
            self.hasSomeUnappliedPromo = ko.observable(false);

            PromotionFactory = function(serverItem) {
                var that = this;
                that.promotionId = serverItem.PromotionId;
                that.description = serverItem.Description;
                that.startDate = serverItem.StartDate;
                that.endDate = serverItem.EndDate;
                that.isPromotionApplied = serverItem.IsPromotionApplied;
                that.isConditionsApplicable = serverItem.IsConditionsApplicable;
                that.promoConditions = ko.observableArray(serverItem.PromoConditions);
                that.promoActions = ko.observableArray();

                utility.rebuildObservableArray(that.promoConditions, serverItem.PromoConditions, PromoConditionFactory);
                buildPromoActionsArray(that.promoActions, serverItem.PromoActions, that.promotionId);
            };

            PromoConditionFactory = function (serverItem) {
                var that = this;
                that.productName = serverItem.ProductName;
                that.partNumber = serverItem.PartNumber;
                that.quantity = serverItem.Quantity;
                that.categoryName = serverItem.CategoryName;
                that.conditionTypeId = serverItem.ConditionTypeId;
                that.productTypeName = serverItem.ProductTypeName;
                that.andLogic = serverItem.AndLogic;
            };

            buildPromoActionsArray = function(observableArray, serverData, promotionId) {
                utility.rebuildObservableArray(observableArray, serverData, function (serverItem) {
                    var that = this;
                    that.actionRank = serverItem.ActionRank;
                    that.defaultQty = ko.observable(serverItem.DefaultQty);
                    that.canApplyPromoAction = serverItem.CanApplyPromoAction;
                    that.cannotApplyPromoInfo = serverItem.CannotApplyPromoInfo;
                    that.calculationType = serverItem.CalculationType;
                    that.productName = serverItem.ProductName;
                    that.partNumber = serverItem.PartNumber;
                    that.productDisplay = ko.computed(function () {
                        return that.productName || that.partNumber;
                    });
                    that.isActionApplied = serverItem.IsActionApplied;
                    that.itemQty = serverItem.ItemQty;
                    that.isLoop = serverItem.IsLoop;
                    that.loopQty = serverItem.LoopQty;
                    that.isSelected = ko.observable(false);
                    that.shouldShowRegularPrice = serverItem.ShouldShowRegularPrice;
                    that.regularPriceQty = serverItem.RegularPriceQty;
                    that.qtyLimit = serverItem.TotalAllowedQty;
                    that.actionTypeId = serverItem.ActionTypeId;
                    that.categoryName = serverItem.CategoryName;
                    that.productTypeName = serverItem.ProductTypeName;

                    that.actionOffers = ko.observableArray();
                    utility.rebuildObservableArray(that.actionOffers, serverItem.ActionOffers, ActionOffersFactory);

                    that.isSelected.subscribe(function (value) {
                        setCollectionSelection(value, that.actionRank, promotionId);
                    });
                });
            };

            ActionOffersFactory = function(serverItem) {
                var that = this;
                that.qtyColumn = serverItem.Quantity;
                that.modification = serverItem.Modification;
                that.currencySign = serverItem.CurrencySign;
                that.price = serverItem.Price;
                that.modificationType = serverItem.ModificationType;
                that.promoCode = serverItem.PromoCodeValue;
            };

            self.apply = function () {
                var rowsSelection = getApplyPromotionsRequestData(self.promotions());

                function isQuantityInvalid(element) {
                    return element.quantity > element.qtyLimit;
                }

                if (rowsSelection.some(isQuantityInvalid)) {
                    toastr.error(self.quantityNotAvailable);
                    return;
                }

                var callbackRedirect = function (result) {
                    self.closeModal();
                    if (result.ErrorInfo && result.ErrorInfo.length) {
                        toastr.error(result.ErrorInfo);
                    } else {
                        cartServerProxy.navigateToNewCart();
                    }
                };

                if (rowsSelection.length > 0) {
                    cartServerProxy.applyPromotions(rowsSelection, callbackRedirect);
                } else {
                    toastr.error(self.noItemsSelected);
                }
            };

            getApplyPromotionsRequestData = function (collection) {
                var array = [];
                ko.utils.arrayForEach(collection, function (promotion) {
                    ko.utils.arrayForEach(promotion.promoActions(), function (action) {
                        var rowsObject = {};
                        if (action.isSelected()) {
                            rowsObject.promoId = promotion.promotionId;
                            rowsObject.actionRank = action.actionRank;
                            rowsObject.quantity = action.defaultQty();
                            rowsObject.qtyLimit = action.qtyLimit;
                            array.push(rowsObject);
                        }
                    });
                });
                return array;
            };

            setCollectionSelection = function (isSelected, actionRank, promotionId) {
                if (isSelected && self.onePromoPerQuote()) {
                    ko.utils.arrayForEach(self.promotions(), function (promotion) {
                        ko.utils.arrayForEach(promotion.promoActions(), function (action) {
                            if (action.actionRank !== actionRank || promotion.promotionId !== promotionId) {
                                action.isSelected(false);
                            }
                        });
                    });
                }
            };

            initData = function (serverData) {
                self.onePromoPerQuote(serverData.OnePromoPerQuote);
                self.hasSomeUnappliedPromo(serverData.HasSomeUnappliedPromo);
                utility.rebuildObservableArray(self.promotions, serverData.Promotions, PromotionFactory);
            };

            cartServerProxy.getPromotions(initData);
        };
    });

define('KnockoutCustomValidations', ['jquery', 'knockout', 'Utility', 'knockoutValidations'],
    function ($, ko, util) {
        "use strict";
        ko.validation.rules['dateFormat'] = {
            validator: function (val, format) {
                return ko.validation.utils.isEmptyVal(val) || moment(val, format, true).isValid();
            },
            message: "Invalid date format."
        };

        ko.validation.rules['allowedExtensions'] = {
            validator: function (val, extensionsArray) {
                var file = val.toLowerCase();
                var extension = file.substring(file.lastIndexOf('.') + 1);
                return ($.inArray(extension, extensionsArray) >= 0);
            },
            message: "File type not allowed"
        };

        ko.validation.rules['requiredUnwrap'] = {
            validator: function (val, required) {
                var stringTrimRegEx = /^\s+|\s+$/g,
                    testVal;
                if (val === undefined || val === null) {
                    return !ko.unwrap(required);
                }

                testVal = val;
                if (typeof (val) == "string") {
                    testVal = val.replace(stringTrimRegEx, '');
                }

                if (!ko.unwrap(required)) // if they passed: { required: false }, then don't require this
                    return true;

                return ((testVal + '').length > 0);
            },
            message: util.requiredFieldMessage
        };

        ko.validation.rules['minLength'] = {
            validator: ko.validation.rules['minLength'].validator,
            message: util.minLengthMessage
        };

        ko.validation.rules['maxLength'] = {
            validator: ko.validation.rules['maxLength'].validator,
            message: util.maxLengthMessage
        };

        ko.validation.rules['required'] = {
            validator: ko.validation.rules['required'].validator,
            message: util.RequiredFieldMessage
        };

        ko.validation.registerExtenders();
    });

/*global define*/
/*jslint browser: true*/
define('QuoteTablesModel',['jquery', 'knockout', 'TabIndexModule', 'CartServerProxy', 'mediator-js', 'Utility', 'Toastr', 'underscore', 'Pager', 'FileUploadExtension', 'jQueryForm', 'KnockoutCustomValidations'],
function ($, ko, tabIndexModule, cartServerProxy, mediator, utility, toastr, _, Pager) {
    "use strict";

    return function (tabId) {
        var self, QuoteTable, QuoteTableAttributeValue, QuoteTableColumn, QuoteTableRow, QuoteTableCellRow, QuoteTableGroup, CustomAction, updateQuoteTableCallback, onQuoteTableCellChanged, calculateColspanForGroups;

        self = this;
        self.activeElementId = null;

        QuoteTableCellRow = function (tableId, rowId, columns) {
            return function (serverData, index) {
                var that = this;
                that.cellId = tableId + '_' + rowId + '_' + serverData.ColumnId;
                that.isEditable = serverData.IsEditable;
                that.isHidden = serverData.IsHidden;
                that.column = columns[index];
                that.value = ko.observable(serverData.Value);
                that.validationViolated = ko.observable();
                that.systemValidationMessage = serverData.ValidationMessage;
                that.validationMessages = ko.observableArray();
                that.brokenValidations = ko.observableArray(serverData.BrokenValidations);
                that.validationViolated = that.brokenValidations().length !== 0 ? true : false;
                that.column.validations.forEach(function(columnValidation) {
                    that.brokenValidations().forEach(function(brokenValidationId) {
                        if (columnValidation.Id === brokenValidationId) {
                            that.validationMessages.push(columnValidation.ValidationMessage);
                        }
                    });
                });

                that.isStringColumn = that.column.dataType === 0;
                that.hasValidationsFailed = ko.computed(function () {
                    var failed = that.validationViolated;
                    failed = failed || (that.isStringColumn && that.value().length > 2000);
                    return failed;
                });

                that.isMoneyColumn = that.column.dataType === 3;
                that.isNumberColumn = that.column.dataType === 1 || that.column.dataType === 3 || that.column.dataType === 6;
                switch (that.column.dataType) {
                    case 0:
                        that.value.extend({
                            maxLength: {
                                params: 2000,
                                message: utility.maxLengthErrorMessage
                            }
                        });
                    case 1:
                    case 3:
                    case 6:
                        if (that.isEditable) {
                            that.template = 'quoteTableInputTextCell';
                        } else {
                            that.template = 'quoteTableLabelCell';
                        }
                        break;
                    case 2:
                        that.template = 'quoteTableDateCell';
                        break;
                    case 4:
                        that.template = 'quoteTableCheckboxCell';
                        break;
                    case 5:
                        if (that.column.renderType === 2) {
                            that.template = 'quoteTableAttributeRadioCell';
                        }
                        else {
                            that.template = 'quoteTableAttributeCell';
                        }
                        break;
                    default:
                }

                that.selectRadioButton = function() {
                    document.activeElement.click();
                }

                that.value.subscribe(function (newValue) {
                    if (that.isStringColumn && newValue.length > 2000)
                        return;
                    onQuoteTableCellChanged(tableId, rowId, that.column, newValue);
                });
            };
        };

        QuoteTableAttributeValue = function (serverData) {
            var that = this;
            that.attributeValue = serverData.AttributeValue;
            that.displayValue = serverData.DisplayValue;
        };

        QuoteTableColumn = function(tableName){
            return function (serverData) {
                var that = this;
                that.id = serverData.Id;
                that.name = serverData.Name;
                that.label = serverData.Label;
                that.rank = serverData.Rank;
                that.dataType = serverData.DataType;
                that.className = 'QT-COL-' + tableName + '-' + that.name;
                that.validations = serverData.Validations;
                that.values = ko.observableArray();
                that.columnWidth = serverData.ColumnWidth;
                that.decimalPlaces = serverData.DecimalPlaces;
                that.decimalPlacesInCalculations = serverData.DecimalPlacesInCalculations;
                that.maxCharacters = serverData.MaxCharacters;
                that.renderType = serverData.RenderType;
                utility.rebuildObservableArray(that.values, serverData.Values, QuoteTableAttributeValue);
                that.values.unshift({ attributeValue: '', displayValue: '' });
                that.searchTerm = ko.observable();

                that.numberGroupSeparator = utility.numberGroupSeparator === "." ? "\\" + utility.numberGroupSeparator : utility.numberGroupSeparator;
                that.numberDecimalSeparator = utility.numberDecimalSeparator === "." ? "\\" + utility.numberDecimalSeparator : utility.numberDecimalSeparator;
                that.numberExpressionFormatted = "(^(?:[<>]?[-+]?)(?:(?:\\\d{1,3}(?:[" + that.numberGroupSeparator + "]\\\d{3})*)))";
                that.numberExpression = "(^(?:[<>]?[-+]?)(?:\\\d+))";

                that.decimalPartExpression = "(?:[" + that.numberDecimalSeparator + "]\\\d{" + (that.decimalPlaces > 1 ? "1,2" : "1") + "})";
                that.decimalExpressionFormatted = "(^(?:[<>]?[-+]?)(?:(?:\\\d{1,3}(?:[" + that.numberGroupSeparator + "]\\\d{3})*)" + that.decimalPartExpression + "?))";
                that.decimalExpression = "(^(?:[<>]?[-+]?)(?:\\\d+)" + (that.decimalPlaces > 0 ? that.decimalPartExpression + "?" : "") + ")";

                //when using format.js DD or MM will not work with numbers without leading zero
                that.momentDateFormat = utility.dateFormat.replace("DD", "D").replace("MM", "M");
                that.dateFormat = utility.dateFormat;

                that.checkFormat = function () {
                    if (that.dataType === 6) {
                        var newValue = that.searchTerm();
                        var formattedMatch = newValue.match(that.numberExpressionFormatted);
                        var match = newValue.match(that.numberExpression);
                        return that.getLongestMatch(formattedMatch, match);
                    } else if (that.dataType === 1 || that.dataType === 3) {
                        var newValue = that.searchTerm();
                        var formattedMatch = newValue.match(that.decimalExpressionFormatted);
                        var match = newValue.match(that.decimalExpression);
                        return that.getLongestMatch(formattedMatch, match);
                    } else if (that.dataType === 2) {
                        var newValue = that.searchTerm();
                        var dateMatch = moment(newValue, this.momentDateFormat, true);
                        if (dateMatch.isValid()) {
                            return dateMatch.format(this.dateFormat);
                        }
                    }
                    return undefined;
                };

                that.getLongestMatch = function (formattedMatch, match) {
                    if (formattedMatch || match) {
                        var result;
                        if (formattedMatch[0] && !match) {
                            result = formattedMatch[0];
                        } else if (match[0] && !formattedMatch){
                            result = match[0];
                        } else {
                            if (formattedMatch[0].replace(that.numberGroupSeparator, '').length > match[0].length) {
                                result = formattedMatch[0];
                            } else {
                                result = match[0];
                            }
                        }
                        return result;
                    }
                    return undefined;
                };

                that.updateSearchTerm = function (value) {
                    setTimeout(function() {
                        that.searchTerm(value);
                    }, 0);
                };

                that.isInHeader = ko.observable(serverData.isInHeader);
            };
        };
        QuoteTableGroup = function (tableName) {
            return function (serverData) {
                var that = this;
                that.id = serverData.Id;
                that.name = serverData.Name;
                that.rank = serverData.Rank;
                that.columns = ko.observableArray(serverData.Columns);
                that.groups = ko.observableArray(serverData.Groups);
                that.colSpan = that.columns().length;
            };
        };

        QuoteTableRow = function (tableId, columns) {
            return function (serverData) {
                var that = this;
                that.id = serverData.Id;
                that.cells = ko.observableArray([]);
                utility.rebuildObservableArray(that.cells, serverData.Cells, QuoteTableCellRow(tableId, that.id, columns));
                that.hasValidationsFailed = ko.computed(function () {
                    var failed = false;
                    that.cells().forEach(function (c) {
                        failed = failed || c.hasValidationsFailed();
                    });

                    return failed;
                });
            };
        };

        CustomAction = function(serverData) {
            var that = this;
            that.id = serverData.Id;
            that.name = serverData.Name;
            that.className = that.name.replace(/\s+/g, "-") + that.id;
        };

        QuoteTable = function (serverData) {
            var that = this;
            that.addRowTranslation = self.addRowTranslation;
            that.template = 'quoteTableTemplate';
            that.id = serverData.Id;
            that.name = serverData.Name;
            that.label = serverData.Label.replace(/</g, "&lt;").replace(/>/g, "&gt;");
            that.rank = serverData.Rank;
            that.hasValidationsFailed = ko.observable(serverData.HasValidationsFailed);
            that.rows = ko.observableArray([]);
            that.columns = ko.observableArray([]);
            that.groups = ko.observableArray();
            that.groupStructure = ko.observableArray();
            that.columnGroupLevels = ko.observableArray();
            that.hasColumnGroups = ko.observable();
            that.customActions = ko.observableArray();
            that.canAddRow = ko.observable(serverData.CanAddRow);
            that.canCopyRow = ko.observable(serverData.CanCopyRow);
            that.canDeleteRow = ko.observable(serverData.CanDeleteRow);
            that.isEditable = ko.observable(serverData.IsEditable);
            that.isSearchEnabled = ko.observable(serverData.EnableSearch);
            that.allowExcelUpload = ko.observable(serverData.AllowExcelUpload);
            that.reportFilePath = ko.observable();

            that.validationsFailed = ko.computed(function () {
                var failed = false;

                that.rows().forEach(function(r) {
                    failed = r.hasValidationsFailed() || failed;
                });

                return failed;
            });

            that.importExcel = function (data) {
                data.ajaxSubmit({
                    success: function (data) {
                        that.reportFilePath(data);
                        if (data.CartNotLoaded) {
                            utility.alert("", data.ErrorMessage, function () {
                                window.location.href = "/Quotation/LoadQuote.aspx";
                            });

                            return;
                        }
                        that.refreshData();
                    }
                });
            }

            that.uploadFileOnEnter = function() {
                $(document.activeElement).find('.file-input').click();
            }
            
            that.hasRowActions = ko.computed(function () {
                return that.canDeleteRow() || that.canCopyRow();
            });
            that.activeFilters = ko.observableArray(serverData.Filters);

            that.pageSize = serverData.PageSize;
            that.currentPage = serverData.CurrentPage;
            that.pager = new Pager(
                serverData.CurrentPage,
                serverData.NumberOfRows,
                serverData.PageSize,
                [10, 20, 50, 100],
                false, // don't autofix current page because server will so that and autocorrect could cause 2 calls to server
				false,
				that.id
            );

            that.pager.currentPage.subscribe(function () {
                that.refreshData();
            });
            that.pager.pageSize.subscribe(function () {
                that.refreshData();
            });

            that.refreshData = function () {
                cartServerProxy.filterQuoteTableRows(that.id, that.activeFilters(), that.pager.currentPage(), that.pager.pageSize(), $.isFunction(tabId) ? tabId() : tabId, updateQuoteTableCallback(that));
            };

            that.addRow = function () {
                mediator.publish("quoteTablesModel.addRow", that.id);
            };
            that.deleteRow = function (row) {
                var rowIndexToFocus = that.getNextRowIndexToFocus(row);
                var deleteRowIdToFocus = "";
                if (rowIndexToFocus === -1) {
                    deleteRowIdToFocus = that.name + "_addButton";
                } else {
                    deleteRowIdToFocus = "deleteRow_" + that.name + that.rows()[rowIndexToFocus].id;
                }
                mediator.publish("quoteTablesModel.deleteRow", that.id, row.id, deleteRowIdToFocus);
            };
            that.copyRow = function (row) {
                mediator.publish("quoteTablesModel.copyRow", that.id, row.id);
            };
            that.executeCustomAction = function(action) {
	            window.lastActiveElementId = document.activeElement.id;
                mediator.publish("quoteTablesModel.executeQuoteTableCustomAction", that.id, action.id);
            };

            that.addFilterData = function(columnId, value, updateValues) {
                var existingElement = that.findFilterElement(columnId);
                if (existingElement) {
                    that.activeFilters.remove(existingElement);
                }

                if (value && value !== "") {
                    that.activeFilters.push({colId: columnId, colValue: value});
                }

                if (updateValues) {
                    if (that.activeFilters().length === 0) {
                        if (that.pager.currentPage() === 1) {
                            that.pager.currentPage.notifySubscribers();
                        } else {
                            that.pager.currentPage(1);
                        }
                    }
                }
            };

            that.findFilterElement = function(columnId) {
                return that.activeFilters().find(function (item) {
                    return item.colId === columnId;
                });
            };

            that.checkColumn = function(columnRef, refreshIfChanged) {
                var result = columnRef.checkFormat();
                if (!result) {
                    var existingElement = that.findFilterElement(columnRef.id);
                    if (existingElement) {
                        that.activeFilters.remove(existingElement);
                        if (refreshIfChanged) {
                            that.pager.currentPage(1);
                            that.pager.currentPage.notifySubscribers();
                        }
                    }
                }
                return result;
            };

            that.addFilter = function(column) {
                var colObject = this;
                if (column) {
                    colObject = column;
                }
                var searchValue = colObject.searchTerm();
                if(searchValue && searchValue !== ""){
                    //Decimal, date, money and number
                    if (colObject.dataType === 1 || colObject.dataType === 2 || colObject.dataType === 3 || colObject.dataType === 6) {
                        searchValue = that.checkColumn(colObject);
                        if (!searchValue) {
                            colObject.updateSearchTerm(searchValue);
                            return;
                        }
                    }
                }
                that.addFilterData(colObject.id, searchValue, false);
                colObject.updateSearchTerm(searchValue);
            };

            that.addFilterAndApply = function() {
                that.addFilter(this);
                that.applyFilters();
            };

            that.addFilterDataDropdown = function (data, event) {
                var searchValue;
                if (this.searchTerm().hasOwnProperty('attributeValue')) {
                    searchValue = this.searchTerm().attributeValue;
                } else {
                    searchValue = event.currentTarget.value;
                }
                that.addFilterData(this.id, searchValue, true);
                that.applyFilters();
            };

            that.applyFilters = function() {
                if (that.activeFilters().length > 0) {
                    //Set current page to first page when filter is applied
                    cartServerProxy.filterQuoteTableRows(that.id, that.activeFilters(), 1, that.pager.pageSize(), $.isFunction(tabId) ? tabId() : tabId, updateQuoteTableCallback(that));
                }
                else
                {
                    that.pager.currentPage.notifySubscribers();
                }
            };

            that.getNextRowIndexToFocus = function(row) {
                var deletedRowIndex = -1;
                for (var i = 0; i < that.rows().length; i++) {
                    if (that.rows()[i].id === row.id) {
                        deletedRowIndex = i;
                        break;
                    }
                }
                
                if (that.rows().length > 1 && deletedRowIndex === that.rows().length - 1) {
                    return deletedRowIndex - 1; //if last element has been deleted
                }
                if(that.rows().length > 1){
                    return deletedRowIndex + 1; //if deleted element is not last in the array       
                }
                return -1; //if there is no more element in the array
            }

            that.hasColumnGroups(serverData.Groups.length > 1 && serverData.Groups.some(function (x) { return x.Columns.length > 0; }));

            var groupRow = calculateColspanForGroups(serverData);
            that.columnGroupLevels(groupRow);
            utility.rebuildObservableArray(that.groups, serverData.Groups, QuoteTableGroup(that.id, that.groups()));

            utility.rebuildObservableArray(that.columns, serverData.Columns, QuoteTableColumn(that.name));
            utility.rebuildObservableArray(that.rows, serverData.Rows, QuoteTableRow(that.id, that.columns()));
            utility.rebuildObservableArray(that.customActions, serverData.CustomActions, CustomAction);

            that.activeFilters().forEach(function(element) {
                var filteredColumn = that.columns().find(function (col) { return col.id == element.colId; });
                if (filteredColumn) {
                    filteredColumn.searchTerm(element.colValue);
                }
            }, this);

            that.downloadExcelTemplate = function (existing) {
                mediator.publish("quoteTablesModel.downloadExcelTemplate", that.id, that.name, existing);
            };

            that.downloadOnEnter = function (event, existing) {
                if (event.key === "Enter") {
                    that.downloadExcelTemplate(existing);
                }
            };
        };

        updateQuoteTableCallback = function (quoteTable) {
            return function (serverData) {
                var hasChangedColumns = false;
                quoteTable.canAddRow(serverData.CanAddRow);
                quoteTable.canCopyRow(serverData.CanCopyRow);
                quoteTable.canDeleteRow(serverData.CanDeleteRow);
                quoteTable.pageSize = serverData.PageSize;
                quoteTable.currentPage = serverData.CurrentPage;
                quoteTable.pager.currentPage(serverData.CurrentPage);
                quoteTable.pager.pageSize(serverData.PageSize);
                quoteTable.pager.totalItemCount(serverData.NumberOfRows);
                quoteTable.isSearchEnabled(serverData.EnableSearch);
                quoteTable.allowExcelUpload(serverData.AllowExcelUpload);
                if (quoteTable.columns().length !== serverData.Columns.length) {
                    hasChangedColumns = true;
                }
                if (!hasChangedColumns) {
                    for (var i = 0; i < serverData.Columns.length; i++) {
                        if (serverData.Columns[i].Id !== quoteTable.columns()[i].id) {
                            hasChangedColumns = true;
                            break;
                        }
                    }
                }
                if (hasChangedColumns) {
                    utility.rebuildObservableArray(quoteTable.columns, serverData.Columns, QuoteTableColumn(quoteTable.Name));
                }
                utility.rebuildObservableArray(quoteTable.rows, serverData.Rows, QuoteTableRow(quoteTable.id, quoteTable.columns()));
            };
        };

        onQuoteTableCellChanged = function (tableId, rowId, column, value) {
            var changedCell = [
                {
                    Id: tableId,
                    Rows: [
                        {
                            Id: rowId,
                            Cells: [{ ColumnId: column.id, Value: value }]
                        }
                    ]
                }
            ];
            var cellId = tableId + '_' + rowId + '_' + column.id;
            mediator.publish("quoteTablesModel.onQuoteTableCellChanged", tableId, changedCell, cellId, column.dataType);
        };

        calculateColspanForGroups = function (serverData) {
            serverData.Groups = serverData.Groups.filter(function (g) { return g.Name; });
            var groupRow = [];
            serverData.Columns.forEach(function (column) {
                var added = false;
                serverData.Groups.forEach(function (group) {
                    if (group.Columns.indexOf(column.Id) > -1) {
                        if (groupRow.some(function (x) { return x.Id === group.Id; })) {
                            groupRow.find(function (x) { return x.Id === group.Id; }).Colspan++;
                        }
                        else {
                            group.Colspan = 1;
                            groupRow.push(group);
                        }
                        added = true;
                    }
                });
                if (!added) {
                    groupRow.push({});
                }
            });
            return groupRow;
        };

        mediator.subscribe("quoteTablesModel.downloadExcelTemplate", function (tableId, tableName, existing) {
            self.quoteTableActiveElement = tableName + '_downloadExcelTemplateBtn';
            if (existing) {
                cartServerProxy.downloadQTDataTemplate(tableId, function (serverData) {
                    utility.alert("", serverData.Message, function () {
                        cartServerProxy.navigateToCartList();
                    });
                });
            } else {
                cartServerProxy.downloadQTEmptyTemplate(tableId, function (serverData) {
                    utility.alert("", serverData.Message, function () {
                        cartServerProxy.navigateToCartList();
                    });
                });
            } 
            mediator.publish('quoteTablesModel.AfterDownloadFocus');
        });
            
        mediator.subscribe('quoteTablesModel.AfterDownloadFocus', function() {
            $('#' + self.quoteTableActiveElement).focus();
            self.quoteTableActiveElement = null;
        });

        self.CreateQuoteTable = function (serverData) {
            return new QuoteTable(serverData);
        };
    };
});

define('RecommendationsServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        var baseUrl = "/api/rd/v1/Recommendations/";
        return {

            getData: function (callback) {
                return $.getJSON(baseUrl + 'GetData', { isInDisplayMode: false }, callback);
            },
            updateData: function(callback) {
                $.getJSON(baseUrl + 'GetData', { isInDisplayMode: true }, callback);
            },
            changeDiscount: function (changeDiscountRequest, callback) {
                utility.postJson(baseUrl + "ChangeDiscount", changeDiscountRequest, callback);
            },
            addProduct: function (addProductRequest, callback) {
                utility.postJson(baseUrl + "AddProduct", addProductRequest, callback);
            },
            decline: function (itemData, callback) {
                utility.postJson('/api/rd/v1/Recommendations/Decline', itemData, callback);
            }
        };
    });

define('RecommendationsModel',['jquery', 'knockout', 'Toastr', 'Utility', 'RecommendationsServerProxy', 'mediator-js'],
    function ($, ko, toastr, utility, recommendationsServerProxy, mediator) {
        "use strict";

        $(window).on('beforeunload', function () {
            mediator.publish('RecommendationsModel.cancelRequest', false);
        });

        return function () {
            var self = this;

            var ItemFactory, addProduct, changeDiscount, configure, initCallback,  ChangeDiscountRequestFactory,
                handleChangeDiscountResponse, AddProductRequestFactory, handleAddProductResponse, getData,
                createPricingItem, createAddProductItem, createConfigureItem, loadItems, createItemDescription, declineAndRemoveItem,
                recommendationRequest, updateData;

            recommendationRequest = {
                requests: [],
                resumeRequest: false
            };

            self.showPredictive = ko.observable(false);
            self.items = ko.observableArray();
            self.showList = ko.observableArray(false);

            self.totalCount = ko.observable(0);

            self.inProgress = ko.observable(false);

            var countOfApplied = 0;
            self.maxRowSpan = ko.observable(1);

            self.recommendationsTitle = ko.computed(function () {
                if (self.inProgress()) {
                    return self.recommendationsText;
                }
                else {
                    return self.recommendationsText + " (" + self.totalCount() + ")";
                }

            });

            self.enabled = ko.computed(function () {
                return self.totalCount() > 0;
            });

            var addProductRecommendation = "1";
            var configureProductRecommendation = "2";

            self.init = function () {
                self.items([]);
                
                self.totalCount(0);
                self.showList(false);

                return getData();

            };

            getData = function () {
                self.inProgress(true);
                utility.hideLoaderAndOverlay();
                return recommendationsServerProxy.getData(initCallback);
            };

            updateData = function () {
                recommendationsServerProxy.updateData(initCallback);
            };

            initCallback = function (recommendationsServerData) {
                if (recommendationsServerData.ErrorMessage) {
                    toastr.error(recommendationsServerData.ErrorMessage);
                } else {
                    loadItems(recommendationsServerData);
                }
                
                self.showList(true);
                self.inProgress(false);
            };

            loadItems = function (serverData) {
                var recommendations = ko.utils.arrayMap(serverData.Recommendations, function (serverItem) {
                    var item;
                    if (serverItem.RecommendationType === addProductRecommendation) {
                        item = createAddProductItem(serverItem);
                    } else if (serverItem.RecommendationType === configureProductRecommendation) {
                        item = createConfigureItem(serverItem);
                    } else {
                        item = createPricingItem(serverItem);
                    }
                    return item;
                });
                
                self.items(recommendations);
                self.totalCount(recommendations.length);
            };

            self.closeRecommendationsSideModal = function () {
                var sideModal = $('#recommendationsSideModal');

                if (sideModal) {
                    sideModal.removeClass('slide-in-from-left');
                    sideModal.addClass('slide-out-to-right');

                    setTimeout(function () {
                        sideModal.toggleClass('hidden');
                        self.closeModal();
                    }, 300);
                }

                countOfApplied = 0;
            };

            self.showRecommendations = function () {
                var $el, $modal;
                $el = $("<div>");
                $('body').append($el);
                ko.renderTemplate('recommendationsDialogTemplate', self, null, $el.get(0));
                $modal = $el.children(":first");

                self.sideModal = $('#recommendationsSideModal');

                self.closeModal = function () {
                    $el.remove();
                };

                if (self.sideModal && self.sideModal.hasClass('hidden')) {
                    self.sideModal.toggleClass('slide-out-to-right');
                    self.sideModal.toggleClass('slide-in-from-right');

                    if (self.sideModal.hasClass('slide-out-to-right')) {
                        setTimeout(function () {
                            self.sideModal.toggleClass('hidden');
                        }, 300);
                    } else {
                        self.sideModal.toggleClass('hidden');
                    }
                }

                countOfApplied = 0;
            };

            createItemDescription = function (itemDescriptionData, itemNo) {
                var itemNameValue;
                if (itemDescriptionData.PartNumber) {
                    itemNameValue = itemDescriptionData.PartNumber;
                } else {
                    itemNameValue = itemDescriptionData.ProductName;
                }

                var itemDescription = {
                    itemNumber: (itemNo ? ko.observable(itemNo) : ko.observable('')),
                    itemName: itemNameValue,
                    description: itemDescriptionData.Description,
                    productTypeName: itemDescriptionData.ProductTypeName,
                    productName: itemDescriptionData.ProductName
                };

                return itemDescription;
            };

            declineAndRemoveItem = function (declineItem) {
                recommendationsServerProxy.decline(declineItem, updateData);
            };

            createAddProductItem = function (itemData) {
                var item = new ItemFactory(itemData);
                item.apply = addProduct;
                item.actionName = self.actionNameAddProduct;
                item.hasPricingRecommendation = itemData.HasPricingRecommendation;
                item.productId = itemData.ProductId;
                item.appliedText = self.appliedTextProduct;
                item.recommendMessage = self.bottomTextProduct;
                item.isProduct = true;
                return item;
            };

            createConfigureItem = function (itemData) {
                var item = new ItemFactory(itemData);
                item.apply = configure;
                item.actionName = self.actionNameConfigure;
                item.appliedText = self.appliedTextProduct;
                item.recommendMessage = self.bottomTextProduct;
                item.configuratorQuery = itemData.ConfiguratorQuery;
                item.isProduct = true;

                return item;
            };

            createPricingItem = function (itemData) {
                var item = new ItemFactory(itemData);
                item.apply = changeDiscount;
                item.actionName = self.actionNameChangeDiscount;
                item.cartItem = itemData.CartItem;
                item.appliedText = self.appliedTextChangeDiscount;
                item.recommendMessage = self.bottomTextChangeDiscount;
                item.isProduct = false;

                return item;
            };

            ItemFactory = function (itemData) {
                var that = this;

                that.recommendedDiscountPercent = itemData.RecommendedDiscountDecimal;
                that.recommendedQuantityDecimal = itemData.RecommendedQuantityDecimal;

                that.applied = ko.observable(itemData.IsApplied);
                that.id = itemData.Id;
                that.recommendationDescription = itemData.RecommendationDescription;
                that.headingText = itemData.HeadingText;

                that.forcePopup = function (item, event) {
                    ($(event.target).parent().children("button.btn.btn-predictive-action-right.autoClosePopover")).trigger("click");

                };

                that.itemDescription = createItemDescription(itemData.ItemDescription, itemData.ItemNo);

                that.decline = function (item, event) {
                    var declineItem = {
                        ProductSystemId: itemData.ProductSystemId,
                        Quantity: itemData.RecommendedQuantityDecimal,
                        RecommendedDiscount: itemData.RecommendedDiscountDecimal,
                        RecommendationType: itemData.RecommendationType,
                        CartId: itemData.CartId,
                        UserId: itemData.UserId,
                        CartItemGuid: itemData.CartItemGuid
                    };
                    declineAndRemoveItem(declineItem);

                    ($(event.target).parent().parent().parent()).trigger("click");
                };
            };

            ChangeDiscountRequestFactory = function (item) {
                var that = this;
                that.id = item.id;
                that.CartItem = item.cartItem;
                that.DiscountPercent = item.recommendedDiscountPercent;
            };

            AddProductRequestFactory = function (item) {
                var that = this;
                that.HasPricingRecommendation = item.hasPricingRecommendation;
                that.ProductId = item.productId;
                that.Id = item.id;
                if (item.hasPricingRecommendation) {
                    that.Quantity = item.recommendedQuantityDecimal;
                    that.DiscountPercent = item.recommendedDiscountPercent;
                }
            };

            addProduct = function (item) {
                recommendationsServerProxy.addProduct(new AddProductRequestFactory(item), handleAddProductResponse(item));
                item.applied(true);
                mediator.publish('RecommendationsModel.recommendationsApplied');
            };

            handleAddProductResponse = function (item) {
                return function (serverResponse) {
                    if (serverResponse.ErrorMessage) {
                        toastr.error(serverResponse.ErrorMessage);
                        item.applied(false);
                    } else {
                        item.itemDescription.itemNumber(serverResponse.ItemNo);
                        countOfApplied = countOfApplied + 1;
                        if (serverResponse.WarningMessage) {
                            toastr.warning(serverResponse.WarningMessage);
                        }
                    }
                };
            };

            changeDiscount = function (item) {
                recommendationsServerProxy.changeDiscount(new ChangeDiscountRequestFactory(item), handleChangeDiscountResponse(item));
                item.applied(true);
                mediator.publish('RecommendationsModel.recommendationsApplied');
            };

            handleChangeDiscountResponse = function (item) {
                return function (serverResponse) {
                    if (serverResponse.ErrorMessage) {
                        toastr.error(serverResponse.ErrorMessage);
                        item.applied(false);
                    } else {
                        countOfApplied = countOfApplied + 1;
                        item.applied(true);
                    }
                };
            };

            configure = function (item) {
                item.applied(true);
                mediator.publish('RecommendationsModel.recommendationsApplied');
                countOfApplied = countOfApplied + 1;
                window.location.href = "/Configurator.aspx" + item.configuratorQuery;
            };
                                 
            mediator.subscribe('API:cart:updated', function () {
                var req = recommendationRequest.requests;
                if (self.showPredictive()) {
                    req.forEach(function (request) {
                        request.abort();
                    });
                    req.push(self.init());
                }
            });

            mediator.subscribe('RecommendationsModel.cancelRequest', function (resumeRequest) {
                if (recommendationRequest.requests.length > 0) {
                    recommendationRequest.requests.forEach(function (req) { req.abort(); });
                    if (resumeRequest) {
                        recommendationRequest.resumeRequest = resumeRequest;
                    } else {
                        recommendationRequest.requests = [];
                        recommendationRequest.resumeRequest = false;
                    }
                }
            });
        };
    });

define('InvalidAutocompleteNotificationModel',['jquery', 'knockout', 'Toastr', 'Utility', 'CartServerProxy', 'mediator-js'],
    function ($, ko, toastr, utility, cartServerProxy, mediator) {
        "use strict";

        return function (cellAndFieldManager) {
            var self = this;

            var NotificationItem, CartNotificationItem, EditConfigurationLinkItem, EditConfigurationItem, createAdditionalInfoText, createEditConfigurationNotification, createItemCustomFieldNotification, createQuoteCustomFieldNotification, editItemActionId, executeEditItemAction, handleItemActionResult, updateCartData;

            editItemActionId = 2;
            self.items = ko.observableArray([]);

            NotificationItem = function (template) {
                this.templateName = template;
            };

            CartNotificationItem = function(message, additionalInfo) {
                NotificationItem.call(this, 'msgAndInfoTemplate');
                this.message = message;
                this.additionalInfo = additionalInfo;
            };

            EditConfigurationLinkItem = function (itemNameText, linkText, cartItem, itemId) {
                NotificationItem.call(this, 'linkTemplate');
                var that = this;
                this.itemNameText = itemNameText;
                this.linkText = linkText;
                this.cartItem = cartItem;
                this.itemId = itemId;
                this.confirmAndEditConfiguration = function () {
                    if (cellAndFieldManager.isCellOrCustomFieldsDirty()) {
                        utility.confirm("", self.discardUnsavedValuesMsg, this.editConfiguration)
                    } else {
                        this.editConfiguration();
                    }
                };

                this.editConfiguration = function () {
                    executeEditItemAction(that.cartItem, that.itemId);
                }
            };

            EditConfigurationItem = function (message) {
                NotificationItem.call(this, 'msgTemplate');
                this.message = message;
            };

            executeEditItemAction = function (cartItem, itemId) {
                cartServerProxy.executeItemAction(editItemActionId, cartItem, null, itemId, handleItemActionResult);
            };

            handleItemActionResult = function (serverData) {
                if (serverData.Message) {
                    updateCartData(serverData);
                } else {
                    cartServerProxy.navigateToConfigurator();
                }
            };

            updateCartData = function (serverData) {
                mediator.publish("invalidAutocompvareNotificationModel.updateCartData", serverData);
            };

            createAdditionalInfoText = function (serverItemData) {
                var parameters;
                if(serverItemData.QuoteTableValue){
                    parameters = {
                        entityValue: serverItemData.EntityValue || '',
                        quoteTableName: serverItemData.QuoteTableName,
                        quoteTableValue: serverItemData.QuoteTableValue
                    }
                    return utility.getFormattedTranslation(self.additionalInfoTxtFormat, parameters);
                } else {
                    parameters = {
                        entityValue: serverItemData.EntityValue || '',
                        quoteTableName: serverItemData.QuoteTableName,
                    }

                    return utility.getFormattedTranslation(self.additionalInfoNoQTValueTxtFormat, parameters);

                }
                
               
            };

            createItemCustomFieldNotification = function (serverItemData) {
                var parameters = {
                    itemName: serverItemData.RolledUpCartItem,
                    displayName: serverItemData.DisplayName
                };

                var messageText = utility.getFormattedTranslation(self.itemCustomFieldMsgFormat, parameters);
                var additionalInfo = createAdditionalInfoText(serverItemData);
                return new CartNotificationItem(messageText, additionalInfo);
            };

            createQuoteCustomFieldNotification = function (serverItemData) {
                var messageText = utility.getFormattedTranslation(self.quoteCustomFieldMsgFormat, { displayName: serverItemData.DisplayName });
                var additionalInfo = createAdditionalInfoText(serverItemData);
                return new CartNotificationItem(messageText, additionalInfo);
            };

            createEditConfigurationNotification = function (serverItemData) {
                if (serverItemData.CanEdit) {
                    var messageText = utility.getFormattedTranslation(self.itemNameFormat, { itemName: serverItemData.RolledUpCartItem }) + ', ';
                    return new EditConfigurationLinkItem(messageText, self.editConfigurationText, serverItemData.CartItem, serverItemData.Id);
                } else {
                    var messageText = utility.getFormattedTranslation(self.itemNameFormat, { itemName: serverItemData.RolledUpCartItem }) + ', ' + self.editConfigurationText + '.';
                    return new EditConfigurationItem(messageText);
                }
            };

            self.updateData = function (serverData) {
                var notificationsArray = [];

                for (var i = 0; i < serverData.InvalidConfigurationEntities.length; i++) {
                    notificationsArray.push(createEditConfigurationNotification(serverData.InvalidConfigurationEntities[i]));
                }
                for (var i = 0; i < serverData.InvalidQuoteCustomFields.length; i++) {
                    notificationsArray.push(createQuoteCustomFieldNotification(serverData.InvalidQuoteCustomFields[i]));
                }

                for (var i = 0; i < serverData.InvalidItemCustomFields.length; i++) {
                    notificationsArray.push(createItemCustomFieldNotification(serverData.InvalidItemCustomFields[i]));
                }

                self.items(notificationsArray);

            };

            self.getTemplate = function (item) {
                return item.templateName;
            }
        };
    });

/*global define*/
/*jslint browser: true*/
define('QuoteItemsServerProxy',['jquery'],
    function($) {
        "use strict";
        return {
            getFilterableItemColumns: function (data, callback) {
                $.get("/api/rd/v1/Cart/GetFilterableItemColumns", data, callback);
            },
            getMinAndMaxForColumn: function (data, callback) {
                $.get("/api/rd/v1/Cart/GetMinAndMaxForColumn", data, callback);
            },
            getAutocompleteValues: function (data, callback) {
                $.get("/api/rd/v1/Cart/GetCustomFieldAutocomplete", data, callback);
            },
            getAutocompleteAttributeValues: function (data, callback) {
                $.get("/api/rd/v1/Cart/GetCustomFieldAutocompleteAttribute", data, callback);
            },
            getProductTypes: function (callback) {
                $.get("/api/rd/v1/Cart/GetProductTypes", null, callback);
            },
            getFieldDistinctValues: function (data, callback) {
                $.get("/api/rd/v1/Cart/GetFieldDistinctValues", data, callback);
            },
            getFiltersMetadata: function (callback) {
                $.get("/api/rd/v1/Cart/GetFiltersMetadata", null, callback);
            }
        };
    });
define('contextService',[], function () {
    function service() {
        var self = this;
        self.context = {};

        self.init = function (context) {
            self.context = context;
        };

        self.getItem = function (key) {
            return self.context[key];
        };
    }
    return new service();
});

define('DateFilterModel',['knockout', 'moment', 'Utility'], function (ko, moment, utility) {
    "use strict";
    var DateFilterModel = function (self, params) {
        $.extend(self, this);
        self.template = "DatePickerTemplate";
        self.rangeDelimiter = " - ";
        self.queryDateFormat = "YYYY-MM-DD";
        self.queryDateTimeFormat = "YYYY-MM-DD HH:mm:ss";
        self.displayValue = ko.observable(params.displayValue);

        var inputValue = ko.observable(),
            fromDate = ko.observable(),
            toDate = ko.observable();

        self.formatQueryDate = function (date, offset, unit) {
            if (offset) {
                return moment(new Date()).add(offset, unit || 'days').format(self.queryDateFormat);
            }
            return moment(new Date()).format(self.queryDateFormat);
        };

        self.formatDisplayDate = function (date, offset, unit) {
            if (offset) {
                return moment(new Date()).add(offset, unit || 'days').format(self.displayDateFormat);
            }
            return moment(new Date()).format(self.displayDateFormat);
        };

        self.dateFilterEditorExpanded = ko.observable();

        self.toggleDateFilterEditorExpanded = function () {
            self.dateFilterEditorExpanded(!self.dateFilterEditorExpanded());
            utility.setupTabGroups(['headerContainer', 'sideMenuContainer', 'cartListHeaderContainer', 'cartListHeaderContainer', 'mainGridContainer', 'filter-editor-content']);
        };

        self.availableDateFilterOptions = [
            {
                display: self.lastSevenDays,
                formattedValue: self.formatDisplayDate(new Date(), -7) + self.rangeDelimiter + self.formatDisplayDate(new Date()),
                value: self.formatQueryDate(new Date(), -7) + ";" + self.formatQueryDate(new Date())
            }, {
                display: self.lastThirtyDays,
                formattedValue: self.formatDisplayDate(new Date(), -30) + self.rangeDelimiter + self.formatDisplayDate(new Date()),
                value: self.formatQueryDate(new Date(), -30) + ";" + self.formatQueryDate(new Date())
            }, {
                display: self.lastSixMonths,
                formattedValue: self.formatDisplayDate(new Date(), -6, 'months') + self.rangeDelimiter + self.formatDisplayDate(new Date()),
                value: self.formatQueryDate(new Date(), -6, 'months') + ";" + self.formatQueryDate(new Date())
            }, {
                display: self.lastTwelveMonths,
                formattedValue: self.formatDisplayDate(new Date(), -1, 'years') + self.rangeDelimiter + self.formatDisplayDate(new Date()),
                value: self.formatQueryDate(new Date(), -1, 'years') + ";" + self.formatQueryDate(new Date())
            },
            {
                display: self.exactDate
            },
            {
                display: self.custom
            }
        ];

        self.operator = ko.computed(function () {
            var value = self.value();
            if (value) {
                if (value.split(';').length > 1) {
                    return self.operators.between;
                }
            }
            return self.operators.eq;
        });

        self.dateValidate = function (dateString) {
            var date = moment(dateString, self.displayDateFormat, true).toDate();
            return !isNaN(date.getTime());
        };

        self.errorValue = ko.observable();

        self.inputValue = ko.computed({
            read: function () {
                if (self.errorValue()) {
                    return self.errorValue();
                }
                if (self.value()) {
                    return inputValue();
                }
                return '';
            },
            write: function (newValue) {
                self.errorValue('');
                var valueParts = newValue ? newValue.split(self.rangeDelimiter) : [];
                for (var i = 0; i < valueParts.length; i++) {
                    if (!self.dateValidate(valueParts[i])) {
                        self.errorValue(newValue);
                        return;
                    }
                }
                var option = ko.utils.arrayFirst(self.availableDateFilterOptions, function (v) {
                    return v.formattedValue == newValue;
                });
                inputValue(newValue);
                if (option) {
                    self.displayValue(option.display);
                } else {
                    var formattedValueParts = valueParts.map(function (v) { return moment(v, self.displayDateFormat).format(self.queryDateFormat); });
                    self.value(formattedValueParts.join(';'));
                    self.displayValue(newValue);
                }
            }
        }).extend({ rateLimit: 100 });

        self.dropdownValue = ko.computed({
            read: function () {
                if (!self.displayValue()) {
                    return '';
                }
                var value = self.value();

                var option = ko.utils.arrayFirst(self.availableDateFilterOptions, function (v) {
                    return v.display == self.displayValue() || v.value == value;
                });
                if (!option) {
                    if (self.dateValidate(value))
                        return self.exactDate;
                    return self.custom;
                }

                return self.displayValue();
            },
            write: function (newValue) {
                self.errorValue('');
                var option = ko.utils.arrayFirst(self.availableDateFilterOptions, function (v) {
                    return v.display == newValue;
                });
                if (option) {
                    self.value(option.value);
                    self.displayValue(option.display);
                    inputValue(option.formattedValue);
                } else {
                    inputValue(newValue);
                }
            }
        }).extend({ rateLimit: 50 });

        self.dropdownValue(params.displayValue);

        self.rangeEndSelected = ko.observable();

        self.fromDate = ko.computed({
            read: function () {
                if (fromDate()) {
                    return fromDate();
                }
                var value = self.value() ? self.value().split(';')[0] : null;
                if (value) {
                    return moment(new Date(value)).format(self.displayDateFormat);
                }
            },
            write: function (value) {
                if (value && !self.dateValidate(value)) {
                    return;
                }
                fromDate(value);
                if (!self.rangeEndSelected()) {
                    self.applyDate();
                }
            }
        });

        self.toDate = ko.computed({
            read: function () {
                if (toDate()) {
                    return toDate();
                }
                var value = self.value() ? self.value().split(';')[1] : null;
                if (value) {
                    return moment(new Date(value)).format(self.displayDateFormat);
                }
            },
            write: function (value) {
                if (value && !self.dateValidate(value)) {
                    return;
                }
                toDate(value);
                if (!self.fromDate()) {
                    self.fromDate(value);
                }
                if (!self.rangeEndSelected()) {
                    self.applyDate();
                }
            }
        });

        self.pickerDate = ko.computed({
            read: function () {
                if (self.dropdownValue() == self.exactDate) {
                    return moment(self.value()).format(self.displayDateFormat);
                }
                else if (self.rangeEndSelected() == "to") {
                    return self.toDate();
                } else if (self.rangeEndSelected() == "from") {
                    return self.fromDate();
                }
            },
            write: function (value) {
                if (self.dropdownValue() == self.exactDate) {
                    if (value) {
                        self.inputValue(value);
                    } else {
                        self.value(null);
                    }
                }
                else if (self.rangeEndSelected() == "to") {
                    self.toDate(value);
                } else if (self.rangeEndSelected() == "from") {
                    self.fromDate(value);
                }
            }
        });

        self.applyDate = function () {
            if (!self.toDate() || !self.fromDate()) {
                return;
            }
            var toDisplayValue = self.toDate() ? moment(self.toDate(), self.displayDateFormat).format(self.displayDateFormat) : null;
            self.inputValue(moment(self.fromDate(), self.displayDateFormat).format(self.displayDateFormat) + (toDisplayValue ? self.rangeDelimiter + toDisplayValue : ""));
            self.rangeEndSelected(null);
        };

        self.cancelDate = function () {
            fromDate(null);
            toDate(null);
            self.rangeEndSelected(null);
        };

        self.cleanUp = function () {
            fromDate(null);
            toDate(null);
            self.rangeEndSelected(null);
            self.dateFilterEditorExpanded(null);
        };

        self.toCondition = function () {
            self.cleanUp();
            var value = self.value();
            var operator = self.operator();
            if (operator == "between") {
                var values = value.split(';');
                values[1] = moment(values[1], self.queryDateFormat).add(1, 'days').add(-1, 'seconds').format(self.queryDateTimeFormat);
                value = values[0] + ";" + values[1];
            }
            return [self.field, operator, value];
        };
    };
    return DateFilterModel;
});

/*global define*/
/*jslint browser: true*/
define('QuoteListServerProxy',['jquery', 'Utility'],
    function ($, utility) {
        "use strict";
        return {
            getinitData: function (tabId, callback) {
                $.get("/api/rd/v1/QuoteList/GetInitData", { TabId: tabId }, callback);
            },
            getData: function (data, callback) {
                $.get("/api/rd/v1/QuoteList/GetData", data, callback);
            },
            getFilterSuggestions: function (data, callback) {
                $.get("/api/rd/v1/QuoteList/GetFilterSuggestions", data, callback);
            },
            viewQuote: function (ownerId, quoteId) {
                var url = utility.buildUrl("/Quotation/QuoteView.aspx", { OwnerId: ownerId, CartId: quoteId });
                utility.showLoaderAndOverlay();
                window.location = url;
                return false;
            },
            viewRevision: function (ownerId, quoteId) {
                var url = utility.buildUrl("/Revisions/", { cr: 1, o: ownerId, c: quoteId });
                window.location = url;
                return false;
            },
            loadFilters: function (callback) {
                $.get("/api/rd/v1/QuoteList/LoadQuoteListFilters", {}, callback);
            },
            saveFilters: function (filters, callback) {
                utility.postJson("/api/rd/v1/QuoteList/SaveQuoteListFilters", filters, callback);
            },
            changeStatus: function (data, callback) {
                utility.postJson("/api/rd/v1/QuoteList/ChangeStatus", {
                    ActionId: data.actionId,
                    CryptedOwnerId: data.cryptedOwnerId,
                    CryptedCartId: data.cryptedCartId,
                    NewStatus: data.newStatus
                }, callback);
            },
            getMinAndMaxForColumn: function(data, callback) {
                $.get("/api/rd/v1/QuoteList/GetMinAndMaxForColumn", data, callback);
            },
            executeAction: function (data, callback) {
                utility.postJson("/api/rd/v1/QuoteList/ExecuteAction", data, callback);
            },
            approvalHistory: function (ownerId, quoteId) {
                var url = utility.buildUrl("quotation/ApprovalHistory.aspx", { rc: quoteId, ro: ownerId });
                window.location = url;
                return false;
            },
            retractApproval: function (data, callback) {
                utility.postJson("/api/rd/v1/CartList/RetractApprovalProcess", data, callback);
            },
            reassign: function (newUserId, ownerId, cartId, selectedTab, callback) {
                var urlData = {
                    newUserId: newUserId,
                    cryptedOwnerId: ownerId,
                    cryptedCartId: cartId,
                    selectedTab: selectedTab
                };

                utility.postJson(utility.buildUrl("/api/rd/v1/QuoteList/Reassign", urlData), callback);
            },
            executeGetUserTypesForReassign: function (callback) {
                utility.postJson("/api/rd/v1/QuoteList/GetUserTypesForReassign", null, callback);
            },
            executeGetUsersForReassign: function (userTypeId, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/QuoteList/GetUsersForReassign", { userTypeId: userTypeId }), callback);
            },
            getAutocompleteValues: function (data, callback) {
                callback([]);
            },
            getAutocompleteAttributeValues: function(data, callback) {
                callback([]);
            },
            getTeamsOnQuote: function (quoteId, callback) {
                $.ajax({
                    url: "/api/rd/v1/Cart/GetQuoteTeams",
                    method: 'GET',
                    data: { quoteId: quoteId },
                    success: callback,
                    global: false // don't show loader
                });
            },
            createNewCart: function (refer, callback) {
                utility.postJson(utility.buildUrl("/api/rd/v1/Cart/CreateNew", { refer: refer }), callback);
            }
        };
    });

define('NumericRangeFilterModel',['jquery', 'knockout', 'Utility', 'QuoteListServerProxy', 'contextService'], function ($, ko, utility, serverProxy, contextService) {
    "use strict";
    var NumericRangeFilterModel = function(self, params) {
        $.extend(self, this);
        self.template = 'NumericRangeTemplate';
        self.min = ko.observable(0);
        self.max = ko.observable(0);
        self.initialized = ko.observable(false);
        self.step = 1;
        self.decimalPlaces = 0;
        self.currencySign = params.currencySign || '';

        var displayValue = ko.observable(params.displayValue);
        self.displayValue.dispose();
        self.displayValue = ko.computed(function () {
            if (displayValue()) {
                return displayValue();
            }
            return self.value();
        });
        self.radixPoint = utility.numberDecimalSeparator;
        self.groupSeparator = utility.numberGroupSeparator;
        self.parseFormattedFloat = ko.bindingHandlers.rangeSlider.helper().parseFormattedFloat;

        // number with {0} for decimal point in case we parse formatted or the real value 
        var numberRegex = "^[\\-]?\\d*\\{0}?\\d+(?:\\d+)?";
        // dash with optional whitespace
        var dashRegex = "[\\s+]?-[\\s+]?";
        // used to group thousands in number to respect user format
        var thousandsGroupRegex = /\B(?=(\d{3})+(?!\d))/g;

        self.operator = ko.computed(function () {
            var value = self.value();
            if (value) {
                if ((value + "").split(';').length > 1) {
                    return self.operators.between;
                }
            }
            return self.operators.eq;
        });

        //workaround for not supported lookahead regex in ES5
        function getMinMaxParsedValue(value, resultType, delimiter, formatted) {
            var result = {};
            var currentNumberRegex = numberRegex.replace("{0}", formatted ? self.radixPoint : "."); 

            var min = new RegExp("^(" + currentNumberRegex + ")").exec(value);
            if (!min)
                return undefined;
            
            value = value.toString().replace(min[0], '');
            result.min = min[0];

            var testDelimiter = new RegExp(delimiter).exec(value);
            if (!testDelimiter)
                return undefined;

            value = value.replace(testDelimiter[0], '').trim();

            var max = new RegExp(currentNumberRegex + "$").exec(value);
            if (!max)
                return undefined;

            result.max = max[0];

            return result[resultType];
        }

        function tryParseMin(value, delimiter, formatted) {
            if (value) {
                var min = getMinMaxParsedValue(value, 'min', delimiter, formatted);
                if (min == undefined)
                    return undefined;

                var intValue = formatted ? self.parseFormattedFloat(min.trim()) : parseFloat(min.trim());
                if (!isNaN(intValue) && intValue < self.min()) {
                    intValue = self.min();
                }
                return intValue;

            }
            return undefined;
        }

        function tryParseMax(value, delimiter, formatted) {
            if (value) {
                var max = getMinMaxParsedValue(value, 'max', delimiter, formatted);
                if (max == undefined)
                    return undefined;

                var intValue = formatted ? self.parseFormattedFloat(max.trim()) : parseFloat(max.trim());
                if (!isNaN(intValue) && intValue > self.max()) {
                    intValue = self.max();
                }
                return intValue;
                
            }
            return undefined;
        }

        self.selectedMin = ko.observable();
        self.selectedMax = ko.observable();

        self.sliderEnabled = ko.computed(function() {
            return self.value() !== '' && self.selectedMin() !== undefined && self.selectedMax() !== undefined;
        });

        self.forceUpate = function() {
            self.value.valueHasMutated();
            self.selectedMin.valueHasMutated();
            self.selectedMax.valueHasMutated();
        }

        self.errorValue = ko.observable();

        self.inputValueNew = ko.observable();

        function groupNumberThousands(x, group) {
            var numberParts = (x + "").split('.');
            numberParts[0] = self.groupSeparator ? numberParts[0].replace(new RegExp("\\" + self.groupSeparator, 'g'), group) : numberParts[0];
            return numberParts.join(self.radixPoint);
        }

        function formatDisplay(value) {
            var minValue = (value + "").split('.');
            return minValue[0].toString().replace(thousandsGroupRegex, self.groupSeparator) + (minValue[1] ? self.radixPoint + minValue[1] : "");
        }

        function prepareDisplayValue(min, max) {
            var display = self.currencySign + formatDisplay(min);
            if (max) {
                display += " - " + self.currencySign + formatDisplay(max);
            }
            return display;
        }

        self.inputValue = ko.computed({
            read: function () {
                if (self.errorValue()) {
                    return self.errorValue();
                }
                if (self.value() == '') {
                    return self.value();
                }
                if (self.selectedMin() !== undefined && self.selectedMax() !== undefined) {
                    return groupNumberThousands(self.selectedMin(), "") + ' - ' + groupNumberThousands(self.selectedMax(), "");
                }
                return self.value();
            },
            write: function (newValue) {
                self.errorValue('');
                var min = tryParseMin(newValue, dashRegex, true);
                var max = tryParseMax(newValue, dashRegex, true);
                if (!isNaN(min) && !isNaN(max)) {
                    if (min > max) {
                        var tempMax = max;
                        max = min;
                        min = tempMax;
                    }
                    self.selectedMin(min);
                    self.selectedMax(max);
                } else {
                    self.selectedMin(undefined);
                    self.selectedMax(undefined);
                    if (!isNaN(newValue) || !isNaN(self.parseFormattedFloat(newValue))) {
                        if (newValue < self.min()) {
                            newValue = self.min();
                        }
                        if (newValue > self.max()) {
                            newValue = self.max();
                        }
                        self.value(newValue);
                        displayValue(prepareDisplayValue(newValue));
                    } else {
                        self.errorValue(newValue);
                    }
                }
                self.forceUpate();
            }
        }).extend({ rateLimit: 100 });

        self.toCondition = function () {
            var value = self.value();
            if (value.toString().split(';').length === 1) {
                value = self.parseFormattedFloat(value);
            }
            var operator = self.operator();
            return [self.field, operator, value];
        };

        function setValue() {
            if (!isNaN(self.selectedMin()) && !isNaN(self.selectedMax())) {
                self.errorValue('');
                if (self.selectedMin() <= self.min() && self.selectedMax() >= self.max()) {
                    self.value('');
                } else {
                    self.value(self.selectedMin() + ';' + self.selectedMax());
                    displayValue(prepareDisplayValue(self.selectedMin(), self.selectedMax()));
                }
            }
        }

        self.displayMin = ko.observable();
        self.displayMax = ko.observable();

        self.getMinAndMaxForColumn = contextService.getMinAndMaxForColumn;
        if (self.getMinAndMaxForColumn) {
            self.getMinAndMaxForColumn(self.field, function (serverData) {
                self.decimalPlaces = ko.bindingHandlers.rangeSlider.helper().getDecimalPlaces(serverData.Max);

                self.displayMin(self.currencySign + " " + serverData.Min);
                self.displayMax(self.currencySign + " " + serverData.Max);
                self.min(self.parseFormattedFloat(serverData.Min));
                self.max(self.parseFormattedFloat(serverData.Max));
                var stepDivider = (self.max() - self.min()) / 20;
                self.step = stepDivider > 1 ? stepDivider.toFixed(0) : stepDivider;

                self.selectedMin(tryParseMin(self.value(), ';'));
                self.selectedMax(tryParseMax(self.value(), ';'));

                self.selectedMin.subscribe(setValue);
                self.selectedMax.subscribe(setValue);
                self.initialized(true);
            });
        }

    };
    return NumericRangeFilterModel;
});

define('StatusFilterModel',['knockout', 'contextService'],
    function (ko, contextService) {
        "use strict";
        var StatusFilterModel = function (self, params) {
            $.extend(self, this);
            self.template = "StatusTemplate";
            self.availableStatuses = contextService.availableStatuses;

            self.selectedValues = ko.observableArray();

            self.value = ko.computed({
                read: function () {
                    if (self.selectedValues().length) {
                        return self.selectedValues()[0].id;
                    }
                    return null;
                },
                write: function (value) {
                    var selectedValues = contextService.availableStatuses
                        .filter(function (f) { return value == f.orderStatusId.toString() })
                        .map(function (f) { return { id: f.orderStatusId, value: f.orderStatusName } });
                    self.selectedValues(selectedValues);
                }
            });

            self.displayValue = ko.computed(function () {
                var selectedStatus = ko.utils.arrayFirst(self.availableStatuses,
                    function (s) { return s.orderStatusId == self.value(); });
                if (selectedStatus) {
                    return selectedStatus.orderStatusName;
                }
                return '';
            });

            self.value(params.value);
        }
        return StatusFilterModel;
    });
define('AutocompleteModel',['knockout', 'contextService', 'Utility'],
    function (ko, contextService, utility) {
        "use strict";
        function AutocompleteModel(self, params) {
            $.extend(self, this);
            self.autocompleteValues = ko.observableArray([]);
            self.selectedValues = ko.observableArray([]);
            self.itemsCount = ko.observable(0);

            self.getAutocompleteValues = params.getAutocompleteValues;
            self.getFieldDistinctValues = params.getFieldDistinctValues;

            self.searchString = ko.observable('').extend({ rateLimit: { timeout: 300, method: "notifyWhenChangesStop" } });

            self.searchLocally = ko.computed(function () {
                return self.itemsCount() > 0 && self.itemsCount() < 11;
            });

            var suggestionsMenuOpen = ko.observable(false);
            self.suggestionsMenuOpen = ko.computed({
                read: function () {
                    return suggestionsMenuOpen() && self.availableValues().length;
                }, write: function (value) {
                    suggestionsMenuOpen(value);
                }
            }).extend({ notify: 'always' });

            self.availableValues = ko.pureComputed(function () {
                return self.autocompleteValues().filter(function (v) {
                    return self.selectedValues().indexOf(v) < 0 &&
                        (!self.searchLocally() || v.toLowerCase().startsWith(self.searchString()));
                });
            });

            self.value = ko.computed({
                read: function () {
                    return self.selectedValues().join(';');
                },
                write: function (value) {
                    if (!value)
                        self.selectedValues([]);
                    else
                        self.selectedValues(value.split(';'));
                }
            });

            self.toCondition = function () {
                var value = self.value();
                var operator = self.operator();
                return [self.field, operator, value];
            };

            self.displayValue = ko.computed(function () {
                return self.selectedValues().join(', ');
            });

            self.isValid = ko.computed(function () {
                return self.selectedValues().length;
            });

            self.openOnFocus = function () {
                if (self.availableValues().length && (self.searchLocally() || self.searchString().length > 1))
                    suggestionsMenuOpen(true);
            };

            self.setSuggestionsMenuOpen = function (value) {
                suggestionsMenuOpen(value);
            };

            self.getSuggestions = ko.computed(function () {
                var searchString = self.searchString();
                if (searchString && searchString.length > 1) {
                    if (!self.searchLocally()) {
                        self.getAutocompleteValues(self.field,
                            searchString,
                            function (data) {
                                self.autocompleteValues(data);
                                suggestionsMenuOpen(true);
                            });
                    } else {
                        suggestionsMenuOpen(true);
                    }
                } else {
                    suggestionsMenuOpen(false);
                }
            });

            self.operator = ko.computed(function () {
                if (self.selectedValues().length > 1) {
                    return self.operators.in;
                }
                return self.operators.eq;
            });

            if (self.getFieldDistinctValues) {
                self.getFieldDistinctValues(self.field, function (serverData) {
                    self.itemsCount(serverData.ItemsCount);
                    self.autocompleteValues(serverData.DistinctValues);
                });
            }
        }
        return AutocompleteModel;
    });
define('AutocompleteAttributeModel',['knockout', 'contextService', 'AutocompleteModel'],
    function (ko, contextService, AutocompleteModel) {
        "use strict";
        var AutocompleteAttributeModel = function (self, params) {
            $.extend(self, this);
            $.extend(self, new AutocompleteModel(self, params));

            self.availableValues.dispose();
            self.availableValues = ko.pureComputed(function () {
                return self.autocompleteValues().filter(function (v) {
                    return self.selectedValues().map(function (v) { return v.Id }).indexOf(v.Id) < 0 && (!self.searchLocally() || v.Name.toLowerCase().startsWith(self.searchString().toLowerCase()));
                });
            });

            self.value = ko.computed({
                read: function () {
                    return JSON.stringify(self.selectedValues());
                },
                write: function (value) {
                    if (!value)
                        self.selectedValues([]);
                    else
                        self.selectedValues(JSON.parse(value));
                }
            });

            self.toCondition = function () {
                var operator = self.operator();
                return [self.field, operator, self.selectedValues().map(function (v) { return v.Id; }).join(';')];
            };

            self.displayValue = ko.computed(function () {
                return self.selectedValues().map(function (v) { return v.Name }).join(', ');
            });

        }
        return AutocompleteAttributeModel;
    });
define('DescriptionFilterModel',['knockout', 'contextService'],
    function(ko, contextService) {
        "use strict";
        var DescriptionFilterModel = function(self, params) {
            $.extend(self, this);

            self.endsWithMatch = ko.computed(function () {
                return self.value() && self.value().endsWith("%");
            });

            self.startsWithMatch = ko.computed(function () {
                return self.value() && self.value().startsWith("%");
            });

            self.operator = ko.computed(function () {
                if (self.startsWithMatch() || self.endsWithMatch()) {
                    return self.operators.like;
                }
                return self.operators.eq;
            });

            self.displayValue = ko.computed(function () {
                return self.value();
            });
        }
        return DescriptionFilterModel;
    });
define('ProductTypeFilterModel',['knockout', 'contextService', 'Utility', 'mediator-js'],
    function (ko, contextService, utility, mediator) {
        "use strict";
        function ProductTypeFilterModel(self, params) {
            $.extend(self, this);
            self.autocompleteValues = ko.observableArray([]);
            self.selectedValues = ko.observableArray();

            self.searchString = ko.observable('');

            self.operator = ko.observable(self.operators.eq);

            var suggestionsMenuOpen = ko.observable(false);
            self.suggestionsMenuOpen = ko.computed({
                read: function () {
                    return suggestionsMenuOpen() && self.availableValues().length;
                }, write: function (value) {
                    suggestionsMenuOpen(value);
                }
            });

            self.availableValues = ko.pureComputed(function () {
                return self.autocompleteValues().filter(function (v) {
                    var searchString = self.searchString();
                    return v.Name.toLowerCase().startsWith(searchString.toLowerCase()) &&
                        self.selectedValues().map(function (v) { return v.Id; }).indexOf(v.Id) < 0;
                });
            });

            self.value = ko.computed({
                read: function () {
                    return self.selectedValues();
                },
                write: function (value) {
                    self.selectedValues(value || []);
                }
            });

            self.displayValue = ko.computed(function () {
                return self.selectedValues().map(function (v) { return v.Name; }).join(', ');
            });

            self.isValid = ko.computed(function () {
                return self.selectedValues().length;
            });

            self.openOnFocus = function () {
                if (self.searchString().length > 1 && self.availableValues().length || self.autocompleteValues().length < 11)
                    suggestionsMenuOpen(true);
            };

            self.closeOnFocusOut = function (data, event) {
                if (event.relatedTarget && event.relatedTarget.parentElement.id !== 'availableSuggestionsContainer')
                    suggestionsMenuOpen(false);
            };

            self.getSuggestions = ko.computed(function () {
                var searchString = self.searchString();
                if (searchString && searchString.length > 1) {
                    suggestionsMenuOpen(true);
                } else {
                    suggestionsMenuOpen(false);
                }
            });

            self.toCondition = function () {
                var operator = self.operator();
                return [self.field, operator, self.selectedValues().map(function (v) { return v.Id; }).join(';')];
            };

            self.operator = ko.computed(function () {
                if (self.selectedValues().length > 1) {
                    return self.operators.in;
                }
                return self.operators.eq;
            });

            if (contextService.getProductTypes) {
                contextService.getProductTypes(self.field, function (serverData) {
                    self.autocompleteValues(serverData);
                });
            }

            self.selectedValues.subscribe(function () {
                $('#productTypeField').focus();
            });

            suggestionsMenuOpen.subscribe(function () {
                if (suggestionsMenuOpen()) {
                    var animationDuration = 160;
                    setTimeout(function () {
                        utility.makeArrowsAccessible('#productTypeSuggestionsContainer', '#productTypeField');
                        $('#productTypeSuggestionsContainer').on('keydown', function (event) {
                            if (event.key === 'Escape' || event.key === "Esc") {
                                suggestionsMenuOpen(false);
                                $('#productTypeField').focus();
                            };
                        });
                    }, animationDuration);
                };
            });

            mediator.subscribe('cartModel.toggleProductTypeSuggestions', function () {
                suggestionsMenuOpen(false);
            });
        };

        return ProductTypeFilterModel;
    });
define('PartNumberFilterModel',['knockout', 'contextService'],
    function (ko, contextService) {
        "use strict";
        var PartNumberFilterModel = function (self, params) {
            $.extend(self, this);

            self.endsWithMatch = ko.computed(function () {
                return self.value() && self.value().endsWith("%");
            });

            self.startsWithMatch = ko.computed(function () {
                return self.value() && self.value().startsWith("%");
            });

            self.operator = ko.computed(function () {
                if (self.startsWithMatch() || self.endsWithMatch()) {
                    return self.operators.like;
                }
                return self.operators.eq;
            });

            self.displayValue = ko.computed(function () {
                return self.value();
            });
        }
        return PartNumberFilterModel;
    });
define('SectionNameFilterModel',['knockout', 'AutocompleteModel', 'DealViewServerProxy', 'Utility'],
    function (ko, AutocompleteModel, DealViewServerProxy, utility) {
        "use strict";
        var SectionNameFilterModel = function (self, params) {
            $.extend(self, this);
            $.extend(self, new AutocompleteModel(self, params));

            self.enableHierarchyOption = params.enableHierarchyOption;
            self.exact = ko.observable(params.exact != undefined ? params.exact : true);

            self.getAutocompleteValues = DealViewServerProxy.getSectionPaths;
            self.getFieldDistinctValues = null;

            self.value = ko.computed({
                read: function () {
                    return JSON.stringify(self.selectedValues());
                },
                write: function (value) {
                    if (!value)
                        self.selectedValues([]);
                    else
                        self.selectedValues(JSON.parse(value));
                }
            });

            self.toCondition = function () {
                var condition = [];
                self.selectedValues().forEach(function (v) {
                    if (self.exact()) {
                        condition.push([self.field, '=', v.name]);
                    }
                    else {
                        var path = '';
                        v.paths.forEach(function (p) {
                            path = (path ? path + '\\' + p : p);
                            condition.push([self.field, '=', path]);
                        });
                        condition.push([self.field, 'like', path + '\\%']);
                    }
                });
                return condition;
            };

            self.displayValue = ko.computed(function () {
                return self.selectedValues().map(function (v) { return v.name }).join(', ');
            });

            function findSuggestion(array, name) {
                return array.find(function (s) { return s.name.toLowerCase() == name.toLowerCase(); });
            }

            function prepareSuggestions(data) {
                var suggestions = [];
                data.forEach(function (d) {
                    var parts = d.split('\\');
                    var name = parts[parts.length - 1];
                    if (!findSuggestion(suggestions, name) && !findSuggestion(self.selectedValues(), name)) {
                        suggestions.push({ name: name, paths: parts, root: parts[0] });
                    }
                });
                return suggestions;
            }

            self.getSuggestions.dispose();
            self.getSuggestions = ko.computed(function () {
                var searchString = self.searchString();
                if (searchString && searchString.length > 0) {
                    if (!self.searchLocally()) {
                        self.getAutocompleteValues({ searchString: searchString },
                            function (data) {
                                self.autocompleteValues(prepareSuggestions(data));
                                self.setSuggestionsMenuOpen(true);
                            });
                    } else {
                        self.setSuggestionsMenuOpen(true);
                    }
                } else {
                    self.setSuggestionsMenuOpen(false);
                }
            });

            self.operator = ko.computed(function () {
                if (self.selectedValues().length > 1) {
                    return self.operators.in;
                }
                return self.operators.eq;
            });

            self.toJS = function () {
                return {
                    field: self.field,
                    dataType: self.dataType,
                    label: self.label,
                    operator: self.operator(),
                    value: self.value(),
                    displayValue: self.displayValue(),
                    template: self.template,
                    select: self.select,
                    exact: self.exact()
                };
            };

            self.addSelectedValueSectionName = function(sectionId) {
	            var selectedSectionName = sectionId;
	            self.selectedValues.push(self.availableValues()[sectionId]);
				if (self.availableValues().length) {
					if (self.availableValues().length === sectionId) {
						selectedSectionName = selectedSectionName - 1;
					}
					$("#section_" + selectedSectionName).focus();
				} else {
					$("#addedSection_0").focus();
                }
                self.setSuggestionsMenuOpen(false);
            };

            self.removeSelectedValue = function(sectionId) {
	            var removedSectionName = sectionId;
	            self.availableValues().push(self.selectedValues()[sectionId]);
	            var n = self.availableValues().length;
	            self.selectedValues.remove(self.availableValues()[n-1]);
	            if (self.selectedValues().length) {
		            if (self.selectedValues().length === sectionId) {
						removedSectionName = removedSectionName - 1;
					}
					$("#addedSection_" + removedSectionName).focus();
				} else {
					$("#sectionName").focus();
				}
            };

            self.closeCustomDropDown = function(event) {
                if (event.key === 'Escape' || event.key === 'Esc') {
                    event.stopPropagation();
		            $("#sectionName").focus();
					self.setSuggestionsMenuOpen(false);
	            }
            };

            self.onKeyUpSectionName = function(data, event) {
				var dropdownContent = $('.filter-suggestion a.section-names');
				
				dropdownContent.on("keydown", function(event) {
					var index = $.inArray(event.target, dropdownContent);
					var isItFirst = index === 0;
					var isItLast = index === (dropdownContent.length - 1);

					if (!event.shiftKey && event.key === 'Tab') {
						event.preventDefault();
						if (isItLast) {
							dropdownContent.first().focus();
						} else {
							dropdownContent[index + 1].focus();
						}
					} else if (event.shiftKey && event.key === 'Tab') {
						event.preventDefault();
						if (isItFirst) {
							dropdownContent.last().focus();
						} else {
							dropdownContent[index - 1].focus();
						}
					}
				});
            };

            self.suggestionsMenuOpen.subscribe(function (val) {
                if (val) {
                    setTimeout(function () { // popup opens after this observable the first time. therefore we need that timeout
                        utility.makeDropdownAccessible('.custom-dropdown-menu', '#sectionName');
                        $('#sectionName').focus();
                        $('.custom-dropdown-menu').on('keydown', self.closeCustomDropDown);
                        $('#sectionName').on('keydown', function (event) {
                            if (self.suggestionsMenuOpen() && (event.key === "Escape" || event.key === "Esc")) {
                                event.stopPropagation();
                                self.suggestionsMenuOpen(false);
                            };
                        });
                    }, 150)
                }
            })
        }
		
        return SectionNameFilterModel;
    });
define('UnallocatedFilterModel',['knockout'],
    function (ko) {
        "use strict";
        function UnallocatedFilterModel(self, params) {
            $.extend(self, this);

            var value = ko.observable();
            self.value = ko.computed({
                read: function () {
                    return value();
                },
                write: function (selectedValue) {
                    if (selectedValue)
                        value(selectedValue);
                    else
                        value(null);
                }
            });

            self.toCondition = function () {
                if (value())
                    return [self.field, 'is', 'NULL'];

                return null;
            };

            self.displayValue = ko.computed(function () {
                if (value()) {
                    return 'Yes';
                }
                return '';
            });
        }
        return UnallocatedFilterModel;
    });
define('OnlyMineSectionsFilterModel',['knockout'],
    function (ko) {
        "use strict";
        function OnlyMineSectionsFilterModel(self, params) {
            $.extend(self, this);
            self.visitorId = params.visitorId;

            var value = ko.observable();
            self.value = ko.computed({
                read: function () {
                    return value();
                },
                write: function (selectedValue) {
                    if (selectedValue)
                        value(selectedValue);
                    else
                        value(null);
                }
            });

            self.toCondition = function () {
                if (value())
                    return [self.field, '=', self.visitorId];

                return null;
            };

            self.displayValue = ko.computed(function () {
                if (value()) {
                    return 'Yes';
                }
                return '';
            });


            var defaultToJS = self.toJS;
            self.toJS = function () {
                var obj = defaultToJS();
                obj.visitorId = self.visitorId;
                return obj;
            };
        }
        return OnlyMineSectionsFilterModel;
    });
define('DistributionSectionsFilterModel',['knockout'],
    function (ko) {
        "use strict";
        function DistributionSectionsFilterModel(self, params) {
            $.extend(self, this);

            self.options = [{ id: '1', display: self.regularSection }, { id: '2', display: self.distributedSection }, { id: '3', display: self.distributionSection }];

            self.selectedOptions = ko.computed({
                read: function () {
                    if (self.value()) {
                        return self.value().split(';');
                    }
                    return [];
                },
                write: function (value) {
                    self.value(value.join(';'));
                }
            });

            self.toCondition = function () {
                return [self.field, 'in', self.selectedOptions().join(';')];
            };

            self.isValid = function () {
                return self.selectedOptions().length > 0 && self.selectedOptions().length < 3;
            };

            self.displayValue = ko.computed(function () {
                if (!self.isValid()) {
                    return self.all;
                }

                var selected = self.options.filter(function (o) { return self.selectedOptions().find(function (sel) { return o.id === sel; }); });
                return selected.map(function (s) { return s.display; }).join(', ');
            });

            self.openShowSectionsDropdown = function(data, event) {
	            if (event.key === 'Enter' || event.key === 'NumpadEnter') {
		            $("#showSections").click();
	            }
            };

            self.onKeyUpShowSections = function (data, event) {
				if (event.key === ' ') {
					event.target.click();
                }
            };
        }

        return DistributionSectionsFilterModel;
    });
define('OnlySectionsFilterModel',['knockout'],
    function (ko) {
        "use strict";
        function OnlySectionsFilterModel(self, params) {
            $.extend(self, this);

            var value = ko.observable();
            self.value = ko.computed({
                read: function () {
                    return value();
                },
                write: function (selectedValue) {
                    if (selectedValue)
                        value(selectedValue);
                    else
                        value(null);
                }
            });

            self.toCondition = function () {
                if (value())
                    return [self.field, 'is', 'NULL'];

                return null;
            };

            self.displayValue = ko.computed(function () {
                if (value()) {
                    return 'Yes';
                }
                return '';
            });
        }
        return OnlySectionsFilterModel;
    });
define('ContainItemsFilterModel',['knockout'],
    function (ko) {
        "use strict";
        function ContainItemsFilterModel(self, params) {
            $.extend(self, this);

            var value = ko.observable();
            self.value = ko.computed({
                read: function () {
                    return value();
                },
                write: function (selectedValue) {
                    if (selectedValue)
                        value(selectedValue);
                    else
                        value(null);
                }
            });

            self.displayValue = ko.computed(function () {
                if (value()) {
                    return 'Yes';
                }
                return '';
            });
        }
        return ContainItemsFilterModel;
    });
define('QuoteListFilter',['jquery', 'knockout', 'contextService', 'DateFilterModel', 'NumericRangeFilterModel', 'StatusFilterModel', 'AutocompleteModel', 'AutocompleteAttributeModel', 'DescriptionFilterModel', 'ProductTypeFilterModel', 'PartNumberFilterModel', 'SectionNameFilterModel', 'UnallocatedFilterModel', 'OnlyMineSectionsFilterModel', 'DistributionSectionsFilterModel', 'OnlySectionsFilterModel', 'ContainItemsFilterModel'],
    function ($, ko, contextService, DateFilterModel, NumericRangeFilterModel, StatusFilterModel, AutocompleteModel, AutocompleteAttributeModel, DescriptionFilterModel, ProductTypeFilterModel, PartNumberFilterModel, SectionNameFilterModel, UnallocatedFilterModel, OnlyMineSectionsFilterModel, DistributionSectionsFilterModel, OnlySectionsFilterModel, ContainItemsFilterModel) {
    "use strict";
    function QuoteListFilter(params) {
        var self = this;
        self.operators = {
            eq: "=",
            neq: "<>",
            like: "like",
            gt: ">",
            gte: ">=",
            lt: "<",
            lte: "<=",
            between: "between",
            "in": "in"
        };

        function resolveOperator() {
            if (!params.operator) {
                switch(params.dataType) {
                    case 0:
                    case 5:
                        return self.operators.eq;
                    default:
                        return self.operators.like;
                }
            }

            return params.operator;
        }

        self.field = params.field;
        self.dataType = params.dataType;
        self.label = params.label;
        self.operator = ko.observable(resolveOperator());
        self.value = ko.observable(params.value);
        self.template = params.template;
        self.select = params.select;

        self.placeholder = params.dataType === 0 ? self.enterSearchPhrase : self.enterExactValue;

        self.toCondition = function () {
            var value = self.value();
            var operator = self.operator();
            return [self.field, operator, value];
        };

        self.displayValue = ko.computed(function () {
            if (self.operator() === self.operators.like) {
                return self.value() ? self.value() + "*" : '';
            }
            return self.value();
        });

        self.toJS = function () {
            return {
                field: self.field,
                dataType: self.dataType,
                label: self.label,
                operator: self.operator(),
                value: self.value(),
                displayValue: self.displayValue(),
                template: self.template,
                select: self.select,
                currencySign: self.currencySign
            };
        };

        self.isValid = function() {
            return self.value();
        };

        switch (self.dataType) {
            case 9:
            case 2:
                $.extend(self, new NumericRangeFilterModel(self, params));
                break;
            case 3:
                $.extend(self, new DateFilterModel(self, params));
                break;
            case 5:
                params.getFieldDistinctValues = contextService.getFieldDistinctValues;
                params.getAutocompleteValues = contextService.getAutocompleteAttributeValues;
                $.extend(self, new AutocompleteAttributeModel(self, params));
                break;
            case 6:
                $.extend(self, new PartNumberFilterModel(self, params));
                break;
            case 7:
                $.extend(self, new ProductTypeFilterModel(self, params));
                break;
            case 8:
                $.extend(self, new DescriptionFilterModel(self, params));
                break;      
            case 10:
                $.extend(self, new SectionNameFilterModel(self, params));
                break;
            case 11:
                $.extend(self, new UnallocatedFilterModel(self, params));
                break;
            case 12:
                $.extend(self, new OnlyMineSectionsFilterModel(self, params));
                break;
            case 13:
                $.extend(self, new DistributionSectionsFilterModel(self, params));
                break;
            case 14:
                $.extend(self, new OnlySectionsFilterModel(self, params));
                break;
            case 15:
                $.extend(self, new ContainItemsFilterModel(self, params));
                break;
            default:
                break;
        }

        if (self.template === 'AutocompleteTemplate') {
            params.getFieldDistinctValues = contextService.getFieldDistinctValues;
            params.getAutocompleteValues = contextService.getAutocompleteValues;
            $.extend(self, new AutocompleteModel(self, params));
        } else if (self.template === 'StatusTemplate') {
            $.extend(self, new StatusFilterModel(self, params));
        }

        self.value(params.value);
    }
    return QuoteListFilter;
});

define('filterService',['knockout', 'QuoteListFilter'], function (ko, QuoteListFilter) {
    function service() {
        var self = this;
        self.originalFilters = [];

        self.filters = ko.observableArray([]);
        self.createFilter = function (data) {
            var filterModel = new QuoteListFilter(data);
            return filterModel;
        };

        self.resolveValue = function (value, operator, filterModel) {
            return [filterModel.field, operator, value];
        };

        self.getDefaultOperator = function (data) {
            switch (data.dataType) {
                case 0:
                    return self.operators.like;
                case 3:
                    return self.operators.between;
                default:
                    return self.operators.eq;
            }
        };

        self.clearFilters = function () {
            self.filters().forEach(function (f) {
                f.value(null);
            });
            self.saveOriginal();
        };

        self.saveOriginal = function () {
            self.originalFilters = ko.toJS(self.filters());
        };

        self.initializeFilters = function (filtersData) {
            filtersData = filtersData || self.originalFilters;

            var filterModels = [];
            filtersData.forEach(function (f) {
                filterModels.push(self.createFilter(f));
            });
            self.filters(filterModels);
            self.saveOriginal();
        }

        self.removeFilterFromSessionStorage = function (storageKey) {
            sessionStorage.removeItem(storageKey);
        }

        self.saveFilterToSessionStorage = function (storageKey) {
            var filterData = ko.toJS(self.filters());
            var filterItems = [];
            filterData.forEach(function (item) {
                filterItems.push(item.toJS());
            });
            sessionStorage.setItem(storageKey, JSON.stringify(filterItems));
        }

        self.loadFilterFromSessionStorage = function (storageKey) {
            var storageItem = sessionStorage.getItem(storageKey);
            if (storageItem) {
                var filterData = JSON.parse(storageItem);
                self.initializeFilters(filterData);
                return true;
            }
            return false;
        };

        self.getCriteria = function () {
            var validFilters = self.filters().filter(function (filter) { return filter.isValid(); });
            return validFilters.map(function (filter) { return filter.toCondition() });
        }
    }

    return new service();
});

define('QuoteItemsFilterEditor',['knockout', 'QuoteItemsServerProxy', 'filterService', 'contextService', 'mediator-js'],
    function (ko, serverProxy, filterService, contextService, mediator) {
    "use strict";
    function QuoteItemsFilterEditor(params) {
        var self = this;
        self.filters = ko.observableArray([]);
        self.filterPills = params.filterPills;
        serverProxy = params.serverProxy || serverProxy;

        self.filtersMetadata = {};

        self.initContextService = function () {
            contextService.getMinAndMaxForColumn = function (field, callback) {
                callback(self.filtersMetadata[field]);
            };

            contextService.getAutocompleteValues = function (field, searchString, callback) {
                serverProxy.getAutocompleteValues({ column: field, searchString: searchString }, callback);
            };

            contextService.getAutocompleteAttributeValues = function (field, searchString, callback) {
                serverProxy.getAutocompleteAttributeValues({ column: field, searchString: searchString }, callback);
            };

            contextService.getProductTypes = function (field, callback) {
                callback(self.filtersMetadata[field]);
            };

            contextService.getFieldDistinctValues = function (field, callback) {
                callback(self.filtersMetadata[field]);
            };
        };

        self.actionEnabled = ko.computed(function () {
            return ko.utils.arrayFirst(self.filters(), function (f) { return f.isValid(); });
        });

        function resolveFilterTemplate(dataType) {
            switch (dataType) {
                case 3:
                case 1:
                    return 'NumericRangeTemplate';
                case 2:
                    return 'DatePickerTemplate';
                case 5:
                    return 'AutocompleteAttributeTemplate';
                case 6:
                    return 'PartNumberTemplate';
                case 7:
                    return 'ProductTypeTemplate';
                case 8:
                    return 'DescriptionTemplate';
                case 10:
                    return 'SectionNameTemplate';
                case 11:
                case 12:
                case 14:
                case 15:
                    return 'CheckboxFilterTemplate';
                case 13:
                    return 'ShowDistributedFilterTemplate';
                default:
                    return 'AutocompleteTemplate';
            }
        }

        // Discrepancy between quote list field types and quote item custom field types
        function resolveDataType(dataType) {
            switch (dataType) {
                case 1:
                    return 2;
                case 2:
                    return 3;
                case 3:
                    return 9;
                default:
                    return dataType;
            }
        }

        function resolveOperator(dataType) {
            return null;
        }

        self.init = function (filterableColumns) {
            var qicfModels = filterableColumns.map(function (cf) {
                return {
                    dataType: resolveDataType(cf.Type),
                    label: cf.Label,
                    template: resolveFilterTemplate(cf.Type),
                    field: cf.Name,
                    select: cf.Name,
                    operator: resolveOperator(cf.Type),
                    currencySign: cf.CurrencySign,
                    teamsVisible: params.teamsVisible
                };
            });
            qicfModels.forEach(function (qicf) {
                var existingFilter = self.filterPills().find(function (f) { return f.field === qicf.field; });
                if (existingFilter) {
                    qicf.value = existingFilter.value();
                    qicf.displayValue = existingFilter.displayValue();
                }
                qicf.visitorId = params.visitorId;
                self.filters.push(filterService.createFilter(qicf));
            });

            $('#filter-editor-content').on('keydown', function(event) {
                if (event.key === 'Escape' || event.key === 'Esc') {
	                $(this).click();
                    return false;
                };
                return true;
            });

            $('#sectionsDropdown').on('keyup', function(event) {
	            if (event.key === 'Escape' || event.key === 'Esc') {
		            $("#showSections").focus();
		            $("#sectionsDropdown").click();
	            };
            });
        };

        self.cancel = function () {
            params.toggleFilterEditor();
        };

        self.applyFilters = function () {
            var newFilters = self.filters().filter(function (f) { return f.isValid(); });
            var existingFilters = self.filterPills().filter(function (f) { return f.dataType > 0; }).map(function (ef) { return ef.field; });
            existingFilters.forEach(function (ef) {
                if (!newFilters.find(function (nf) { return nf.field === ef; })) {
                    self.filterPills.remove(function (fp) { return fp.field === ef; });
                }
            });

            newFilters.forEach(function (nf) {
                var index = self.filterPills.indexOf(function (ef) { return ef.field === nf.field; });
                if (index < 0) {
                    self.filterPills.push(nf);
                } else {
                    self.filterPills.splice(index, 1, nf);
                }
            });

            params.toggleFilterEditor();
            params.applyFilter();
        };

        self.initMetaData = function (callback) {
            self.filters([]);
            serverProxy.getFiltersMetadata(function (serverData) {
                serverData.MetadataItems.forEach(function (data) {
                    self.filtersMetadata[data.Column] = data.Metadata;
                });
                self.init(serverData.FilterableColumns);
                if (callback)
                    callback();
                mediator.publish('quoteItemsFilterEditor.metaDataInitialized');
            });
        };
    }
    return QuoteItemsFilterEditor;
});
define('cartService',['knockout', 'Utility', 'DealViewServerProxy'], function (ko, utility, dealViewServerProxy) {
    function service() {
        var self = this;

        self.buildColumnsArray = function (observableArray, serverArray, useRecurringPriceAndCost) {
            return utility.rebuildObservableArray(observableArray, serverArray, function (serverItem) {
                this.id = serverItem.Id;
                this.name = serverItem.Name;
                this.headerLabel = serverItem.HeaderLabel;
                this.isComplex = useRecurringPriceAndCost && serverItem.IsPrice;
            });
        };

        self.buildCellColumns = function (columns, useRecurringPriceAndCost) {
            var result = [];
            ko.utils.arrayForEach(columns, function (column) {
                if (useRecurringPriceAndCost && column.isComplex) {
                    result.push({ headerLabel: column.headerLabel + " NRC", name: column.name, isNRC: true, isMRC: false });
                    result.push({ headerLabel: column.headerLabel + " MRC", name: column.name, isNRC: false, isMRC: true });
                } else {
                    result.push({ headerLabel: column.headerLabel, name: column.name, isNRC: false, isMRC: false });
                }
            });
            return result;
        };

        self.getProductSectionsSuggestions = function (dealSections, productToRelocate, searchNewSectionName) {
            var items = dealSections.filter(function (ds) { return ds.sectionName().toLowerCase().startsWith(searchNewSectionName); });
            items = items.concat(dealSections.filter(function (ds) { return ds.hierarchyId().toLowerCase().startsWith(searchNewSectionName); }));
            items = items.concat(dealSections.filter(function (ds) { return ds.sectionName().toLowerCase().includes(searchNewSectionName); }));

            if (!items.length)
                return [];

            return items.reduce(function (a, b) {
                if (a.indexOf(b) == -1 &&
                    b.canContainProducts() &&
                    b.sectionPath() != productToRelocate.section())
                    a.push(b);
                return a;
            }, []);
        }

        self.resolveSectionSuggestionName = function (name) {
            return name.replace(/\\/g, ' / ');
        }

        self.loadDealViewFilters = function (quoteId, visitorId, callback) {
            var filtersKey = quoteId + "_" + visitorId;
            dealViewServerProxy.loadFilters(filtersKey,
                function (filterObject) {
                    filterObject = filterObject || { filters: [], collapsedSections: [], pageSize: 10 };
                    if (callback) {
                        callback(filterObject);
                    }
                });            
        }

        self.saveDealViewFilters = function (quoteId, visitorId, filters, collapsedSections, pageSize) {
            var filterObject = {
                filters: filters,
                collapsedSections: collapsedSections,
                pageSize: pageSize
            }
            dealViewServerProxy.saveFilters(quoteId + "_" + visitorId, filterObject);
        }

        self.removeCollapsedSection = function (quoteId, visitorId, id) {
            self.loadDealViewFilters(quoteId, visitorId, function (filterObject) {
                var index = filterObject.collapsedSections.indexOf(id);
                if (index > -1) {
                    filterObject.collapsedSections.splice(index, 1);
                    self.saveDealViewFilters(quoteId, visitorId, filterObject.filters, filterObject.collapsedSections, filterObject.pageSize);
                }                
            })
        }
    }

    return new service();
});
/*global define*/
/*jslint browser: true*/
define('QuoteItemFilterCache', ['Utility'], function (utility) {
    "use strict";
    return function() {
        var self;

        self = this;

        self.cartIdentity = null;
        self.filtersCondition = null;
        self.filterJS = null;
        
        self.getCartIdentity = function () {
            return self.cartIdentity;
        };

        self.getFiltersCondition = function () {
            return self.filtersCondition;
        };

        self.setFiltersCondition = function (filtersCondition) {
            self.filtersCondition = filtersCondition;
        };

        self.getFilterJS = function (callback) {
            var filters = utility.getTenantStorageItem("itemsFilter_" + self.cartIdentity) || "[]";
            callback(JSON.parse(filters));
        };

        self.setFilterJS = function (filterJS) {
            utility.setTenantStorageItem("itemsFilter_" + self.cartIdentity, JSON.stringify(filterJS));
        }

        self.setCartIdentity = function (cartIdentity) {
            self.deleteFilters();
            self.cartIdentity = cartIdentity;
        };

        self.deleteFilters = function () {
            utility.removeTenantStorageItem("itemsFilter_" + self.cartIdentity);
            self.filtersCondition = null;
            self.filterJS = null;
        };
    };
});
/*global define*/
/*jslint browser: true*/
define('CartModel',['jquery', 'knockout', 'CartTabs', 'CartCellAndFieldManager', 'CartItemsModel', 'CartQuickAddModel', 'CartItemsSearchModel', 'CartApprovalModel', 'TabIndexModule', 'CartReassignModule',
    'CartServerProxy', 'mediator-js', 'Utility', 'Toastr', 'moment', 'Common', 'CreatePartialOrderModule', 'CartPromotionsModel', 'Pager', 'QuoteTablesModel',
    'RecommendationsModel', 'RevisionsServerProxy', 'InvalidAutocompleteNotificationModel', 'QuoteItemsFilterEditor', 'filterService', 'cartService', 'DealViewServerProxy', 'DealSectionModel', 'QuoteItemFilterCache', 'Consts'],
    function ($, ko, CartTabsFactory, CartCellAndFieldManagerFactory, CartItemsModelFactory, CartQuickAddModelFactory, CartItemsSearchModelFactory, CartApprovalModelFactory, tabIndexModule,
        CartReassignModuleFactory, cartServerProxy, mediator, utility, toastr, moment, common, CreatePartialOrderModuleFactory, CartPromotionsModelFactory, Pager, QuoteTablesModelFactory,
        RecommendationsModelFactory, RevisionsServerProxy, InvalidAutocompleteNotificationModelFactory, QuoteItemsFilterEditor, filterService, cartService, dealViewServerProxy, DealSectionFactory, QuoteItemFilterCache, consts) {
        "use strict";

        var buildIdNameArray, buildColumnsArray, addReferenceToValues, buildColumLabels, buildCellColumns, setExpanded, getFilterQuery, previousMarketId, productsForUpgrade, upgradeProductsDialogModule,
            constantCartPageTabGroups = ['headerContainer', 'sideMenuContainer', 'cartHeader'], filterSidebarAnimationDuration = 500, makeHomeEndKeysAccessibleInSections, makeItemTypeAccessible, focusCorrespondingEditableGroupElement, itemSearchKeydownHandler,
            brimCells = ['ExtendedAmount', 'ExtendedCost', 'DiscountAmount', 'ExtendedListPrice'];

        $('body').scroll(function () {
            $('.datepicker.datepicker-dropdown').remove();
        });

        buildIdNameArray = function (observableArray, serverArray) {
            return utility.rebuildObservableArray(observableArray, serverArray, function (serverItem) {
                this.id = serverItem.Id;
                this.name = serverItem.Name;
            });
        };

        buildColumnsArray = cartService.buildColumnsArray;

        buildCellColumns = cartService.buildCellColumns;

        buildColumLabels = function (columns, useRecurringPriceAndCost) {
            var result = [];
            ko.utils.arrayForEach(columns, function (column) {
                if (useRecurringPriceAndCost && column.isComplex) {
                    result.push(column.headerLabel + ' NRC');
                    result.push(column.headerLabel + ' MRC');
                } else {
                    result.push(column.headerLabel);
                }
            });
            return result;
        };

        addReferenceToValues = function (observableArray, serverArray, useRecurringPriceAndCost) {
            return utility.rebuildObservableArray(observableArray, serverArray, function (serverItem) {
                this.headerLabel = serverItem.HeaderLabel;
                this.isComplex = useRecurringPriceAndCost && serverItem.IsPrice;
                this.values = ko.observableArray();
            });
        };

        setExpanded = function (items, isExpanded) {
            ko.utils.arrayForEach(items(), function (item) {
                item.isExpanded(isExpanded);
                setExpanded(item.childItems, isExpanded);
            });
        };

        return function (cartMode) {
            var self, updateData, updateDataProductVersions, updateDataQuoteTable, updateMessages, updateLandingMessages, initData, buildRows, getCellsArray, attachColumnReference, buidProductRows, buildProductTotals,
                buildAdditionalDiscountRows, suppressUpdates, exeucteWithotUpdates, executeWithRefocus,
                executeCalculateAction, buildActionsArray, ActionFactory, replaceItemAction, getCartUpdateParams, executeUpgradeProductsAction,
                executeAction, executeActionOnServer, cellAndFieldManager, itemsModel, queryString, createCellWithTabIndexGroup, activateEditableGroup,
                loadItems, itemsPagingHandler, quoteTablesModel, publishCartServerProxyEvents, checkIfCartIsInconsistentOrIncomplete, loadProductVersionProgress;

            self = this;
            suppressUpdates = false;

            self.currencySign = ko.observable();
            self.isInViewMode = ko.observable(cartMode === 1 || cartMode === 2);
            self.activeEditableGroup = ko.observable();
            self.canReorderMainItems = ko.observable(false);
            self.canReorderLineItems = ko.observable(false);
            self.expandItemsByDefault = ko.observable(true);
            self.partNumberEditableGroup = 0;
            self.canManageItems = ko.observable(false);
            self.selectAll = ko.observable(false);
            self.canReplaceItems = ko.observable(false);
            self.favoritesEnabled = ko.observable(false);
            self.allowToShareWithCompanyUsers = ko.observable(false);
            self.allowToShareWithAllUsers = ko.observable(false);
            self.showDebugger = ko.observable(false);
            self.debuggerUrl = ko.observable('');
            self.areVariantAndAlternativeAllowd = ko.observable(true);
            self.tabId = ko.observable();
            self.cartSections = [];
            self.hasDealsViewTab = ko.observable(false);
            self.areProductsUpgrading = ko.observable(false);
            self.visitorId = null;
            self.currentActiveElementId = null;
            self.quoteTableActiveElement = null;
            self.lastActiveQuoteTable = null;
            self.shouldCartCommentBeAutomaticallySaved = ko.observable(true);
            self.tabGroups = [];
            self.quoteItemFilterCache = null;
            self.errorMessage = ko.observable();
            self.useNewQuoteEngine = utility.useNewQuoteEngine;
            self.useSubscriptionTotalQuoteTemplates = utility.useSubscriptionTotalQuoteTemplates;
            self.saveOnTabChange = utility.saveOnTabChange;
            self.availableRevisions = ko.observableArray([]);
            self.itemsLoading = ko.observable(true);
            self.hasAnyActions = ko.observable(false);
            self.canDeleteAnyItems = ko.observable(false);
            self.allowReorderingItems = utility.allowReorderingItems;
            self.displayFirstColumn = ko.computed(function () {
                return self.hasAnyActions() || self.canDeleteAnyItems() || self.allowReorderingItems;
            });
            self.upgradedProductCount = ko.observable(0);
            self.productsForUpgrading = ko.observable(0);
            self.filterPills = ko.observableArray([]);
            self.displayFilterPills = ko.pureComputed(function () {
                return self.filterPills().filter(function (f) { return f.dataType !== 0; }); //do not show system filters
            });

            self.itemToAllocate = ko.observable();
            self.searchNewSectionName = ko.observable('').extend({ rateLimit: { timeout: 300, method: "notifyWhenChangesStop" } });
            self.relocateSuggestions = ko.observableArray([]);
            self.relocateSectionParent = ko.observable();
            self.dealStructureModelsCount = ko.observable(0);

            self.dealViewEnabled = ko.computed(function () {
                return self.useNewQuoteEngine &&
                    utility.useDealStructure &&
                    self.dealStructureModelsCount() &&
                    self.hasDealsViewTab();
            });

            if (self.useNewQuoteEngine && utility.useDealStructure) {
                dealViewServerProxy.dealStructureModelsCount(function (count) {
                    self.dealStructureModelsCount(count);
                });
            }

            self.resolveSectionSuggestionName = cartService.resolveSectionSuggestionName;

            var sectionSearchInitData = null;

            self.searchSectionsByName = function (searchString) {
                if (sectionSearchInitData.ItemsCount < 11) {
                    var sectionSuggestions = sectionSearchInitData.DistinctValues.filter(function (s) {
                        var pathParts = s.SectionPath.toLowerCase().split('\\');
                        var name = pathParts[pathParts.length - 1];
                        return name.startsWith(searchString.toLowerCase()) || s.HierarchyId.startsWith(searchString);
                    });
                    utility.rebuildObservableArray(self.relocateSuggestions, sectionSuggestions, function (serverItem) {
                        return new DealSectionFactory(serverItem);
                    });
                } else if (searchString.length) {
                    dealViewServerProxy.searchSectionsByName(searchString, function (serverData) {
                        utility.rebuildObservableArray(self.relocateSuggestions, serverData, function (serverItem) {
                            return new DealSectionFactory(serverItem);
                        });
                    });
                } else {
                    self.relocateSuggestions([]);
                }
            };

            self.getHeaderRowSpan = function (isComplex) {
                if (self.useSubscriptionTotalQuoteTemplates && !isComplex) {
                    return 3;
                } else if (isComplex) {
                    return 1;
                }
                return 2;
            }

            self.getHeaderColSpan = function (isComplex, name) {
                if (self.useSubscriptionTotalQuoteTemplates && self.isBrimCell(name)) {
                    return 3;
                } else if (isComplex) {
                    return 2;
                }
                return 1;
            }
            

            self.isBrimCell = function (cellName) {
                return brimCells.indexOf(cellName) > -1;
            }

            function getSectionSearchInit() {
                if (sectionSearchInitData === null) {
                    dealViewServerProxy.getSectionSearchInit(function (data) {
                        sectionSearchInitData = data;
                        if (sectionSearchInitData.ItemsCount < 11) {
                            utility.rebuildObservableArray(self.relocateSuggestions, data.DistinctValues, function (serverItem) {
                                return new DealSectionFactory(serverItem);
                            });
                        }
                    });
                }
            }

            function setItemToAllocate(item, serverData) {
                self.relocateSectionParent(serverData ? new DealSectionFactory(serverData) : null);
                self.searchNewSectionName('');
                self.itemToAllocate(item);
                getSectionSearchInit();
                var animationDuration = 200;
                if ($('#relocateSuggestionsSearch').length) {
                    $('#relocateSuggestionsSearch').focus();
                    setTimeout(function () {
                        $('#relocateSuggestionsSearch').mouseenter();
                    }, animationDuration);
                } else if ($('#relocateSectionCancel').length) {
                    $('#relocateSectionCancel').focus();
                }
            }

            self.setItemToAllocate = function (item) {
                sectionSearchInitData = null;
                if (item.section()) {
                    dealViewServerProxy.getDealSectionByPath(item.section(), function (serverData) {
                        setItemToAllocate(item, serverData);
                    });
                } else {
                    setItemToAllocate(item);
                }
            };

            self.relocateSectionParentOnEnter = function (event, data) {
                if (event.key === 'Enter' || event.key === 'NumpadEnter') {
                    self.relocateSectionParent(data);
                    self.searchNewSectionName('');
                    $('#relocateSectionCancel').focus();
                };
            };

            self.searchNewSectionName.subscribe(function (value) {
                self.searchSectionsByName(value);
                $('#relocateSuggestionsSearch').mouseenter();
            });

            self.cancelRelocate = function () {
                var id = self.relocateSectionParent().id;
                cartService.removeCollapsedSection(self.cartId(), self.visitorId, id);
                self.relocateSectionParent(null);
                if ($('#relocateSuggestionsSearch').length) {
                    $('#relocateSuggestionsSearch').focus();
                }
            };

            self.cancelAllocate = function (id) {
                self.itemToAllocate(null);
                self.relocateSectionParent(null);
                self.relocateSuggestions([]);
                if (id && typeof id === 'string') {
                    $('#' + id).focus();
                }
            };

            self.allocateSection = function (id) {
                if (self.relocateSectionParent()) {
                    dealViewServerProxy.moveItemToSection(self.itemToAllocate().id, self.relocateSectionParent().sectionPath(), function () {
                        self.itemToAllocate().section(self.relocateSectionParent().sectionPath());
                        self.itemToAllocate().sectionTitle('');
                        self.itemToAllocate(null);
                        self.relocateSectionParent(null);
                    });
                } else {
                    dealViewServerProxy.moveItemToSection(self.itemToAllocate().id, '', function () {
                        self.itemToAllocate().section('');
                        self.itemToAllocate(null);
                    });
                }
                self.relocateSuggestions([]);
                if ($('#' + id).length) {
                    $('#' + id).focus();
                }
            };

            //#region Helpers

            cellAndFieldManager = new CartCellAndFieldManagerFactory(self.isInViewMode, self.activeEditableGroup);

            self.quoteItemFilterCache = new QuoteItemFilterCache();

            itemsModel = new CartItemsModelFactory(
                cellAndFieldManager,
                self.canReorderMainItems,
                self.canReorderLineItems,
                self.expandItemsByDefault,
                self.canManageItems,
                self.canReplaceItems,
                self.activeEditableGroup,
                self.favoritesEnabled,
                self.allowToShareWithCompanyUsers,
                self.allowToShareWithAllUsers,
                self.areVariantAndAlternativeAllowd,
                self.quoteItemFilterCache);
            quoteTablesModel = new QuoteTablesModelFactory(self.tabId);

            self.invalidAutocompleteNotification = new InvalidAutocompleteNotificationModelFactory(cellAndFieldManager);

            exeucteWithotUpdates = function (action) {
                try {
                    suppressUpdates = true;
                    action();
                } finally {
                    suppressUpdates = false;
                }
                self.setTooltips();

            };

            executeWithRefocus = function (action) {
                action();
                self.setVerticalTabbingEventsForAutocomplete();
            };

            getCellsArray = function (serverValues) {
                return ko.utils.arrayMap(serverValues, function (value) {
                    return cellAndFieldManager.createCell(value);
                });
            };

            buildRows = function (observableArray, serverArray) {
                utility.rebuildObservableArray(observableArray, serverArray, function (serverRow) {
                    this.values = getCellsArray(serverRow.Values);
                });
            };

            buidProductRows = function (observableArray, serverArray, cellColumns) {
                utility.rebuildObservableArray(observableArray, serverArray, function (serverRow) {
                    this.productTypeName = serverRow.ProductTypeName;
                    this.values = ko.utils.arrayMap(serverRow.Values, function (value, index) {
                        var cell = cellAndFieldManager.createCell(value);
                        cell.column = cellColumns()[index];
                        cell.tabId = cell.id + '_' + index;
                        return cell;
                    });
                });
            };

            buildProductTotals = function (observableArray, serverValues, cellColumns) {
                observableArray(ko.utils.arrayMap(serverValues, function (value, index) {
                    var cell = cellAndFieldManager.createCell(value);
                    cell.column = cellColumns()[index];
                    return cell;
                }));
            };

            attachColumnReference = function (columns, rows) {
                ko.utils.arrayForEach(rows, function (row) {
                    var currentCellIndex = 0;
                    ko.utils.arrayForEach(columns, function (column) {
                        var newColumns = [];
                        newColumns.push(row.values[currentCellIndex]);
                        if (column.isComplex) {
                            currentCellIndex++;
                            newColumns.push(row.values[currentCellIndex]);
                        }

                        column.values(newColumns);
                        currentCellIndex++;
                    });
                });
            };

            buildAdditionalDiscountRows = function (observableArray, serverArray) {
                utility.rebuildObservableArray(observableArray, serverArray, function (serverRow) {
                    var that = this;
                    that.id = serverRow.Id;
                    that.deleteDiscount = function () {
                        cartServerProxy.deleteAdditionalDiscount(that.id, getCartUpdateParams(), updateData);
                    };
                    that.values = ko.utils.arrayMap(serverRow.Values, function (value) {
                        return cellAndFieldManager.createCell(value);
                    });
                });
            };

            self.checkAndReturnValidDate = function (dateTime) {
                if (dateTime.length > 0 && dateTime.indexOf(' ') > -1) {
                    return dateTime.substring(0, dateTime.indexOf(' '));
                } else if (dateTime.length > 0) {
                    return dateTime;
                } else {
                    return "";
                }
            };

            createCellWithTabIndexGroup = function (serverCell, tabIndexGroup) {
                var cell = cellAndFieldManager.createCell(serverCell);
                cell.tabIndexGroup = tabIndexGroup;
                return cell;
            };

            self.onChange = function (caller) {
                if (caller.id == 'CartComment') {
                    if (self.shouldCartCommentBeAutomaticallySaved() && self.cartComment().isEditable()) {
                        cartServerProxy.saveCartComment(self.cartComment().value(), getFilterQuery());
                        // to register that the field is no longer dirty after saving the comment
                        self.cartComment().serverValue = self.cartComment().value();
                    }
                }
            }

            initData = function (serverInitData) {
                if (!serverInitData) {
                    // there might be no data if cart wasn't loaded
                    return;
                }

                exeucteWithotUpdates(function () {
                    self.favoritesEnabled(serverInitData.FavoritesEnabled);
                    if (self.favoritesEnabled()) {
                        self.allowToShareWithCompanyUsers(serverInitData.AllowToShareWithCompanyUsers);
                        self.allowToShareWithAllUsers(serverInitData.AllowToShareWithAllUsers);
                    }

                    self.ownerId(serverInitData.OwnerId);
                    self.cartId(serverInitData.CartId);
                    self.opportunityId(serverInitData.OpportunityId);
                    self.opportunityName(serverInitData.OpportunityName);
                    self.origin(serverInitData.Origin);
                    if (serverInitData.IsPrimaryOnOpportunity) {
                        self.isPrimaryOnOpportunity(self.yesMessage);
                    } else {
                        self.isPrimaryOnOpportunity(self.noMessage);
                    }
                    self.errorMessage(serverInitData.ErrorMessage);
                    self.ownerIdCrypted(serverInitData.OwnerIdCrypted);
                    self.cartIdCrypted(serverInitData.CartIdCrypted);
                    self.showQuickConfig(serverInitData.ShowQuickConfig);
                    self.areVariantAndAlternativeAllowd(serverInitData.AreVariantAndAlternativeAllowd);
                    self.useRecurringPriceAndCost(serverInitData.UseRecurringPriceAndCost);
                    self.cartCompositeNumber(serverInitData.CartCompositeNumber);
                    self.dateTimeCreated(serverInitData.DateCreated);
                    self.dateCreated(self.checkAndReturnValidDate(self.dateTimeCreated()));
                    self.orderId(serverInitData.OrderId);
                    self.externalId(serverInitData.ExternalId);
                    //this field is kept for backward compatibility
                    self.isEffectiveDateVisible(true);
                    self.revisionNumber(serverInitData.RevisionNumber);
                    self.canReorderMainItems(serverInitData.CanReorderMainItems);
                    self.canReorderLineItems(serverInitData.CanReorderLineItems);
                    self.expandItemsByDefault(serverInitData.ExpandItemsByDefault);
                    self.partNumberEditableGroup = serverInitData.PartNumberEditableGroup;
                    buildIdNameArray(self.markets, serverInitData.Markets);
                    buildIdNameArray(self.shippingOptions, serverInitData.ShippingOptions);
                    self.displayImagesForCartActions(serverInitData.DisplayImagesForCartActions);
                    self.areItemsPaged(serverInitData.AreItemsPaged);
                    self.pager.pageSize(serverInitData.ItemsPageSize);
                    self.isItemTypeEditable(serverInitData.IsItemTypeEditable);
                    self.shouldCartCommentBeAutomaticallySaved(serverInitData.ShouldCartCommentBeAutomaticallySaved);

                    self.changeCurrentActiveElement = function(element) {
                        $(element).focusin(function(event) {
                            if (!$(element).hasClass('select2-selection--single')) {
                                self.currentActiveElementId = event.target.id;
                            } else {
                                self.currentActiveElementId = $(element).parent().parent().prev().attr('id') + ' ~ .select2-container .select2-selection--single';
                            }
                        });
                    };

                    if (self.areItemsPaged()) {
                        self.pager.handleKeyboarShortcuts();
                    }

                    //  If item columns are undefined do not build column array
                    if (serverInitData.ItemColumns) {
                        buildColumnsArray(self.items.columns, serverInitData.ItemColumns, self.useRecurringPriceAndCost());
                        self.items.cellColumns(buildCellColumns(self.items.columns(), self.useRecurringPriceAndCost()));
                    }

                    //  If product type columns are undefined do not build column array
                    if (serverInitData.ProductTypeColumns) {
                        buildColumnsArray(self.productTypes.columns, serverInitData.ProductTypeColumns, self.useRecurringPriceAndCost());
                        self.productTypes.cellColumns(buildCellColumns(self.productTypes.columns(), self.useRecurringPriceAndCost()));
                        self.productTypes.columnLabels(buildColumLabels(self.productTypes.columns(), self.useRecurringPriceAndCost()));
                    }

                    //  If sub total with discounts columns are undefined do not build column array
                    if (serverInitData.SubTotalWithDiscountColumns) {
                        addReferenceToValues(
                            self.subTotalsWithDiscounts.columns,
                            serverInitData.SubTotalWithDiscountColumns,
                            self.useRecurringPriceAndCost());
                    }

                    //  If total columns are undefined do not build column array
                    if (serverInitData.TotalColumns) {
                        addReferenceToValues(self.totals.columns, serverInitData.TotalColumns, self.useRecurringPriceAndCost());
                    }

                    if (serverInitData.Proposal) {
                        self.proposal.display(true);
                        self.proposal.message(serverInitData.Proposal.Message);
                        self.proposal.docType(serverInitData.Proposal.DocType);
                        self.proposal.docDownloadLink(serverInitData.Proposal.DocDownloadLink);
                        self.proposal.additionalDocuments(serverInitData.Proposal.AdditionalDocuments)
                    }

                    utility.rebuildObservableArray(self.cartUsage, serverInitData.CartUsage, function (serverItem) {
                        this.user = serverItem.User;
                        this.openedMinutesAgo = moment.duration(serverItem.OpenedMinutesAgo * -1, 'minutes').humanize(true);
                    });
                    self.sections(serverInitData.Sections);
                    self.tabId(serverInitData.TabsData.CurrentTabId);
                    self.hasDealsViewTab(serverInitData.TabsData.Tabs.find(function (x) {
                        return x.Url.startsWith('/Cart/DealView');
                    }));

                    if (!utility.useNewQuoteEngine) {
                        self.areItemsCollapsed(!serverInitData.ExpandItemsByDefault);
                    }

                    self.initCollapsedSections();
                    self.isInitalized(true);
                });

                cartServerProxy.getSections(function (sections) {
                    self.cartSections = sections;
                    self.tabGroups = constantCartPageTabGroups.concat(sections);
                    utility.setupTabGroups(self.tabGroups);
                    makeHomeEndKeysAccessibleInSections();

                    setTimeout(function () {
                        var cartFocusableElements = utility.getAllFocusableElements('#cartSectionsWrapper');
                        if ($('#cartSectionsWrapper').length && cartFocusableElements.length) {
                            $(cartFocusableElements[1]).focus();
                        };
                    });
                });
            };

            mediator.subscribe("cartItemsModel.isExpandedSet", function (isExpanded) {
                self.areItemsCollapsed(isExpanded);
                self.toggleItemsState();
            });

            updateData = function (serverData) {
                cellAndFieldManager.clearCellsAndFields();

                // if result is redirecting do redirect
                // else update model and show message
                if (serverData.RedirectionUrl) {
                    utility.handleRedirectionResult(serverData);
                    return;
                }

                if (serverData.CartNotLoaded) {
                    utility.alert("", serverData.ErrorMessage, function () {
                        cartServerProxy.navigateToCartList();
                    });

                    return;
                }

                if (serverData.ActionRejected) {
                    // do nothing
                    return;
                }

				if (serverData.SuccessInfo) {
                    toastr.success(serverData.SuccessInfo);
                }

				if (serverData.ErrorInfo) {
                    toastr.error(serverData.ErrorInfo);
                }

                if (self.useNewQuoteEngine && serverData.InitData && serverData.InitData.IsInitializeData) {
                    loadItems();
                } else {
                    self.itemsLoading(false);
                }

                executeWithRefocus(function () {
                    exeucteWithotUpdates(function () {
                        self.tabsData.init(serverData.TabsData);

                        $('.fiori3-tabdrop').tabdrop();
                        $(window).resize();

                        // when custom templates are rendered, but fiori3 is on
                        utility.removeContainerTopMargin();

                        self.recommendationsData.showPredictive(serverData.TabsData.ShowPredictive);
                        if (self.recommendationsData.showPredictive()) {
                            publishCartServerProxyEvents(cartServerProxy);
                        }
                        self.workflowClientData(serverData.WorkflowClientData);
                        self.hasUpdatableProducts(serverData.HasUpdatableProducts);
                        updateMessages(serverData.Message, serverData.ScriptingMessages);
                        updateLandingMessages(serverData.MessageOnLanding);
                        self.activeEditableGroup(serverData.ActiveEditableGroup);

                        // reset focus again because changing activity group will trigger cell
                        // update and rendering which will increase current tab index

                        self.currencySign(serverData.CurrencySign);
                        self.dateTimeModified(serverData.DateModified);
                        self.dateModified(self.checkAndReturnValidDate(self.dateTimeModified()));
                        self.effectiveDate(serverData.EffectiveDate);
                        if (serverData.IsPrimaryOnOpportunity) {
                            self.isPrimaryOnOpportunity(self.yesMessage);
                        } else {
                            self.isPrimaryOnOpportunity(self.noMessage);
                        }
                        buildIdNameArray(self.orderStatuses, serverData.OrderStatuses);
                        self.orderStatusId(serverData.OrderStatusId);
                        self.marketId(serverData.MarketId);
                        previousMarketId = self.marketId();

                        self.IsPricingProcedureVisible(serverData.IsPricingProcedureVisible);
                        self.pricingProcedure(serverData.PricingProcedure);
                        self.documentPricingProcedure(serverData.DocumentPricingProcedure);
                        self.customerPricingProcedure(serverData.CustomerPricingProcedure);

                        utility.rebuildObservableArray(self.pricebooks, serverData.Pricebooks, function (serverItem) {
                            this.text = serverItem.Name;
                            this.value = serverItem.Id;
                        });

                        self.diplayAddProdSection(serverData.DiplayAddProdSection);
                        self.pricebookId(serverData.PricebookId);
                        self.isPricebookAvailable(serverData.IsPricebookAvailable);
                        self.shippingOptionId(serverData.ShippingOptionId);
                        self.totalShippingCost(createCellWithTabIndexGroup(serverData.TotalShippingCost, 'totals'));
                        self.totalStateTax(createCellWithTabIndexGroup(serverData.TotalStateTax, 'totals'));
                        self.totalVat(createCellWithTabIndexGroup(serverData.TotalVat, 'totals'));
                        self.nrcTotalStateTax(createCellWithTabIndexGroup(serverData.NRCTotalStateTax, 'totals'));
                        self.nrcTotalVat(createCellWithTabIndexGroup(serverData.NRCTotalVat, 'totals'));
                        buildActionsArray(self.primaryActions, serverData.PrimaryActions);
                        buildActionsArray(self.nonPrimaryActions, serverData.NonPrimaryActions);
                        self.canUndo(serverData.CanUndo);
                        self.canRedo(serverData.CanRedo);
                        self.externalId(serverData.ExternalId);

                        if (serverData.Items) {
                            serverData.Items.forEach(function (s) {
                                if (s.Actions && s.Actions.length > 0) {
                                    self.hasAnyActions(true);

                                    for (var i = 0; i < s.Actions.length; i++) {
                                        if (s.Actions[i].Id === consts.quote.item.actions.deleteActionId) {
                                            self.canDeleteAnyItems(true);
                                        }
                                    }
                                }
                            });
                            itemsModel.buildItemsArray(self.items.mainItems, serverData.Items, self.items.cellColumns, serverData.CartItemToHighlight);

                            var hasExpanded = false;
                            for (var i = 0; i < self.items.mainItems().length; i++) {
                                if (self.items.mainItems()[i].isExpanded() == true) {
                                    hasExpanded = true;
                                    break;
                                }
                            }

                            self.areItemsCollapsed(!hasExpanded);

                            self.hasAnyActions(serverData.Items.some(function (item) {
                                if (item.Actions) {
                                    return item.Actions.length > 0;
                                }
                            }));

                            if (self.hasAnyActions()) {
                                self.canDeleteAnyItems(serverData.Items.some(function (item) {
                                    if (item.Actions) {
                                        return item.Actions.some(function (action) {
                                            return action.Id === consts.quote.item.actions.deleteActionId;
                                        });
                                    } else {
                                        return false;
                                    }
                                }));
                            } else {
                                self.canDeleteAnyItems(false);
                            }

                            self.pager.totalItemCount(serverData.TotalItems);
                            self.pager.currentPage(serverData.CurrentPage);
                        }

                        if (serverData.ProductTypes) {
                            buidProductRows(self.productTypes.rows, serverData.ProductTypes, self.productTypes.cellColumns);
                            buildProductTotals(self.productTypes.totals, serverData.ProductTypesTotal.Values, self.productTypes.cellColumns);
                        }

                        if (serverData.SubTotalsWithDiscounts) {
                            buildRows(self.subTotalsWithDiscounts.rows, serverData.SubTotalsWithDiscounts);
                            attachColumnReference(self.subTotalsWithDiscounts.columns(), self.subTotalsWithDiscounts.rows());
                        }

                        if (serverData.Totals) {
                            buildRows(self.totals.rows, serverData.Totals);
                            attachColumnReference(self.totals.columns(), self.totals.rows());
                        }

                        self.totalAmount(cellAndFieldManager.createCell(serverData.TotalAmount));

                        if (serverData.MRCTotalAmount) {
                            self.mrcTotalAmount(cellAndFieldManager.createCell(serverData.MRCTotalAmount));
                        }

                        if (serverData.EstimatedContractTotalValue) {
                            self.estimatedContractTotalValue(cellAndFieldManager.createCell(serverData.EstimatedContractTotalValue));
                        }

                        if (serverData.MRCTotalStateTax) {
                            self.mrcTotalStateTax(cellAndFieldManager.createCell(serverData.MRCTotalStateTax));
                        }

                        if (serverData.MRCTotalVat) {
                            self.mrcTotalVat(cellAndFieldManager.createCell(serverData.MRCTotalVat));
                        }

                        self.areAdditionalDiscountsEditable(serverData.AreAdditionalDiscountsEditable);

                        if (serverData.AdditionalDiscounts) {
                            buildAdditionalDiscountRows(self.additionalDiscounts, serverData.AdditionalDiscounts);
                        }

                        if (serverData.InvalidAutocompleteEntities) {
                            self.invalidAutocompleteNotification.updateData(serverData.InvalidAutocompleteEntities);
                        }

                        self.cartComment(createCellWithTabIndexGroup(serverData.CartComment, 'header'));

                        utility.rebuildObservableArray(self.customFields, serverData.CustomFields, cellAndFieldManager.CreateCustomField);
                        utility.rebuildObservableArray(self.quoteTables, serverData.QuoteTables, quoteTablesModel.CreateQuoteTable);

                        var tmpCustomFieldsAndQuoteTables = self.customFields().concat(self.quoteTables());
                        tmpCustomFieldsAndQuoteTables.sort(function(a, b) { return a.rank - b.rank; });

                        self.customFieldsAndQuoteTables(tmpCustomFieldsAndQuoteTables);
                        mediator.publish('quoteTableModels.checkQuoteTableFocus');

                        self.approval.update(serverData.Approval);

                        if (serverData.PromotionsCartInfo) {
                            self.promosInfo.shouldShowPromotionsInfo(serverData.PromotionsCartInfo.ShouldShowPromotionsInfo);
                            self.promosInfo.hasSomeUnappliedSuggest(serverData.PromotionsCartInfo.HasSomeUnappliedSuggest);
                            self.promosInfo.hasSomeAppliedSuggest(serverData.PromotionsCartInfo.HasSomeAppliedSuggest);
                            if (serverData.PromotionsCartInfo.TopDescription) {
                                self.promosInfo.topDescription(serverData.PromotionsCartInfo.TopDescription);
                            }
                        };
                    });

                    $('#cartCustomFields input').each(function(index, element) {
                        self.changeCurrentActiveElement(element);
                    });

                    $('#cartCustomFields select').each(function(index, element) {
                        self.changeCurrentActiveElement(element);
                    });

                    $('#cartCustomFields .select2-selection--single').each(function(index, element) {
                        self.changeCurrentActiveElement(element);
                    });

                    $('#cartActionsDropdownMenu').on('shown.bs.dropdown', function () {
                        var animationDuration = 300;
                        setTimeout(function () {
                            utility.makeDropdownAccessible('#cartActionsDropdownMenuContainer', '#actionsDropdown');
                        }, animationDuration);
                    });

                    $('#searchInput2').on('shown.bs.popover', function () {
                        var animationDuration = 150,
                            searchInput = $('#searchInput2');
                        utility.makeFocusTrap('#searchItemsDropdown');
                        utility.makeArrowsAccessible('#searchItemsDropdown', '#searchInput2');
                        searchInput.on('keydown', itemSearchKeydownHandler);
                        $('#searchItemsDropdown .item-search-result-element').each(function (index, element) {
                            $(element).on('keydown', function (event) {
                                if (event.key === "Escape" || event.key === "Esc" || event.key === "Enter") {
                                    setTimeout(function () {
                                        searchInput.focus();
                                        searchInput.popover('hide');
                                    }, animationDuration);
                                };
                            });
                        });
                    });

                    $('#searchInput2').on('hidden.bs.popover', function () {
                        $('#searchInput2').unbind('keydown', itemSearchKeydownHandler);
                    });

                    self.makeTabdropAccessible();
                    utility.setupTabGroups(self.tabGroups);
                    utility.makeHomeEndKeysAccessibleInContainer('#cartTabsContainer');
                    makeHomeEndKeysAccessibleInSections();
                    makeItemTypeAccessible();
                });

                // refresh cart summary because items might have been added/deleted/copied
                if (!self.isInViewMode()) {
                    mediator.publish("CartSummary.changeNoMainItems", serverData.MainItemsNumber);
                } else {
                    mediator.publish("CartSummary.changeNoMainItems", -1);
                }

                if ($('.cart-warning-group.last-visible')) {
                    $('.cart-warning-group.last-visible').removeClass('last-visible');
                }
                $('.cart-warning-group:visible:last').addClass('last-visible');

                mediator.publish('CartModel.dataRefreshed');
                mediator.publish("API:cart:updated", { model: self });
                self.initializeRevisions(self.ownerIdCrypted(), self.cartIdCrypted());

                focusCorrespondingEditableGroupElement();
			};

            mediator.subscribe('CartModel.dataRefreshed', function() {
				if (self.currentActiveElementId) {
					$('#' + self.currentActiveElementId).focus();
				}
                if ($('#quickAddInput ~ .popover').length) {
                    $('#quickAddInput').popover('hide');
                };
            });

            mediator.subscribe('cartCellManager.CellFocusUpdated', function () {
                utility.focusLastActiveElementByIdIfExists();
            });

            itemSearchKeydownHandler = function (event) {
                if (event.key === "Tab") {
                    setTimeout(function () {
                        utility.getFirstFocusableElementInContainer('#searchItemsDropdown').focus();
                    });
                };
            };

            updateDataProductVersions = function(serverData) {
				productsForUpgrade = serverData;
				self.productsForUpgrading(productsForUpgrade.length);
				if (productsForUpgrade.length > 0) {
					var cartItem = productsForUpgrade[0].Key;
                    var itemId = productsForUpgrade[0].Value;
                    cartServerProxy.executeUpgradeItemAction(cartItem, itemId, getFilterQuery(), function (data) {
						if (data.ErrorInfo) {
							upgradeProductsDialogModule.closeModal();
							toastr.error(data.ErrorInfo);
						} else {
							loadProductVersionProgress(data, productsForUpgrade.length);
						}
					});
				}
			};

			loadProductVersionProgress = function (serverData, numberOfUpgradedProducts) {
                self.upgradedProductCount(self.upgradedProductCount() + 1);
                if (self.upgradedProductCount() === numberOfUpgradedProducts) {
                    var emptyUpdateParam = {
                        DirtyCells: {},
                        DirtyCustomFields: {}
                    };

                    // after all items have been upgraded, execute upgrade to new product version main action in order to trigger notifications and post actions
                    cartServerProxy.executeAction(51, emptyUpdateParam, getFilterQuery(), updateData);

                    self.areProductsUpgrading(false);
                }
                updateData(serverData);

                // Recursively call upgrade to keep the order in which items are upgraded. They have to be upgraded starting from the last and going up to the first!
                // This is necessary because when product is upgraded it can change the number of items in a quote - for example in version 1 product could have 5 line items and version 2 just one.
                // This can cause a problem as prepared item# for upgrade will be changed and will not point to the original products! The solution is to always do the upgraded starting from the last
                // item as this will not affect the position of all items above it!
                if (productsForUpgrade.length > self.upgradedProductCount()) {
                    var cartItem = productsForUpgrade[self.upgradedProductCount()].Key;
                    var itemId = productsForUpgrade[self.upgradedProductCount()].Value;
                    cartServerProxy.executeUpgradeItemAction(cartItem, itemId, getFilterQuery(), function (data) {
                        loadProductVersionProgress(data, productsForUpgrade.length);
                    });
                }
            };

            updateDataQuoteTable = function (serverData) {
                if (serverData.Message) {
                    toastr.error(serverData.Message.Title);
                    return;
                }

                if (self.isDirty()) {
                    self.calculate();
                } else {
                    if (self.quoteTableActiveElement) {
                        self.currentActiveElementId = self.quoteTableActiveElement;
                        self.quoteTableActiveElement = null;
                    } else {
                        self.currentActiveElementId = document.activeElement.id;
                    }
                    updateData(serverData);
                }
            };

            getFilterQuery = function () {
                self.items.mainItems().forEach(function (item) {
                    var existingFilter = self.filterPills().find(function (f) { return f.value() === item.id; });
                    if (self.filterPills().find(function (f) { return f.operator() === "collapseall"; })) {
                        if (item.isExpanded()) {
                            if (!existingFilter) {
                                self.filterPills.push(filterService.createFilter({
                                    field: 'RolledUpItemNumber',
                                    operator: 'expand',
                                    value: item.id,
                                    dataType: 0,
                                    template: null
                                }));
                            }
                        } else {
                            if (existingFilter) {
                                self.filterPills.remove(existingFilter);
                            }
                        }
                    } else {
                        if (!item.isExpanded()) {
                            if (!existingFilter) {
                                self.filterPills.push(filterService.createFilter({
                                    field: 'RolledUpItemNumber',
                                    operator: 'collapse',
                                    value: item.id,
                                    dataType: 0,
                                    template: null
                                }));
                            }
                        } else {
                            if (existingFilter) {
                                self.filterPills.remove(existingFilter);
                            }
                        }
                    }
                });

                var filterQuery = self.filterPills().map(function (f) { return f.toJS(); });
                var filterQueryCondition = self.filterPills().map(function (f) { return f.toCondition(); });
                if (self.filterPills().length) {
                    self.quoteItemFilterCache.setFilterJS(filterQuery);
                    self.quoteItemFilterCache.setFiltersCondition(filterQueryCondition);
                } else {
                    self.quoteItemFilterCache.deleteFilters();
                }

                return filterQueryCondition;
            };

            loadItems = function (cartItem) {
                var filterQuery = getFilterQuery();
                cartServerProxy.getItemsPost(self.pager.currentPage(), self.pager.pageSize(), filterQuery, cartItem, function (serverData) {
                    if (serverData.CartNotLoaded) {
                        utility.alert("", serverData.ErrorMessage, function () {
                            cartServerProxy.navigateToCartList();
                        });

                        return;
                    }

                    serverData.Items.forEach(function (s) {
                        if (s.Actions && s.Actions.length > 0) {
                            self.hasAnyActions(true);

                            for (var i = 0; i < s.Actions.length; i++) {
                                if (s.Actions[i].Id === consts.quote.item.actions.deleteActionId) {
                                    self.canDeleteAnyItems(true);
                                }
                            }
                        }
                    });

                    exeucteWithotUpdates(function () {
                        self.filteredTotalAmount(serverData.FilteredTotalAmount);
                        itemsModel.buildItemsArray(self.items.mainItems, serverData.Items, self.items.cellColumns, cartItem);

                        var hasExpanded = false;
                        for (var i = 0; i < self.items.mainItems().length; i++) {
                            if (self.items.mainItems()[i].isExpanded() == true) {
                                hasExpanded = true;
                                break;
                            }
                        }

                        self.areItemsCollapsed(!hasExpanded);

                        self.pager.totalItemCount(serverData.TotalItems);
                        self.pager.currentPage(serverData.CurrentPage);
                        self.itemsLoading(false);
                        mediator.publish("CartModel.itemsLoaded", cartItem);
                        makeHomeEndKeysAccessibleInSections();
                        makeItemTypeAccessible();
                    });
                });
            };

            itemsPagingHandler = function () {
                if (!suppressUpdates) {
                    loadItems();
                    mediator.publish("CartModel.itemsPaged");
                }
            };

            updateMessages = function (serverMessage, scriptingMessages) {
                if (serverMessage) {
                    self.messageTitle(serverMessage.Title);
                    utility.rebuildObservableArray(self.messageItems, serverMessage.Items, function (serverItem) {
                        this.title = serverItem.Title;
                        this.description = serverItem.Description;
                    });

                } else {
                    self.messageTitle('');
                    self.messageItems.removeAll();
                }

                if (scriptingMessages) {
                    utility.rebuildObservableArray(self.scriptingMessages, scriptingMessages, function (serverItem) {
                        this.scriptingMessage = serverItem;
                    });
                } else {
                    self.scriptingMessages.removeAll();
                }
            };

            updateLandingMessages = function (landingMessages) {
                if (landingMessages) {
                    self.landingMessageTitle(landingMessages.Title);
                    utility.rebuildObservableArray(self.landingMessages, landingMessages.Items, function (serverItem) {
                        this.title = serverItem.Title;
                        this.description = serverItem.Description;
                    });
                } else {
                    self.landingMessageTitle("");
                    self.landingMessages.removeAll();
                }
            };

            getCartUpdateParams = function (editableGroup, saveChanges) {
                var dirtyCells, dirtyCustomFields, cartUpdateParams, i;
                dirtyCells = cellAndFieldManager.getDirtyCells();
                dirtyCustomFields = cellAndFieldManager.getDirtyCustomFields();

                cartUpdateParams = {
                    GroupToActivate: editableGroup,
                    DirtyCells: {},
                    DirtyCustomFields: {},
                    ItemsFilterQuery: getFilterQuery()
                };

                for (i = 0; i < dirtyCells.length; i++) {
                    //if type of quote item custom field is autocomplete attribute, send id of selected content row
                    cartUpdateParams.DirtyCells[dirtyCells[i].id] = dirtyCells[i].isAttribute || dirtyCells[i].isSubscriptionAttribute ?
                        dirtyCells[i].valueId.toString() : dirtyCells[i].value();
                }
                // add dirty part numbers becuase they are not threated as cells
                ko.utils.arrayForEach(self.items.mainItems(), function (item) {
                    if (item.isPartNumberChanged()) {
                        cartUpdateParams.DirtyCells["PartNumber_" + item.cartItem] = item.itemDescription.partNumber();
                    }
                });


                if (saveChanges === undefined || saveChanges) {
                    for (i = 0; i < dirtyCustomFields.length; i++) {
                        if (utility.useNewQuoteEngine && dirtyCustomFields[i].type === 2) {
                            cartUpdateParams.DirtyCustomFields[dirtyCustomFields[i].id] = dirtyCustomFields[i].values.find(function (item) { return item.value === dirtyCustomFields[i].content(); }).id;
                        } else {
                            cartUpdateParams.DirtyCustomFields[dirtyCustomFields[i].id] = dirtyCustomFields[i].content();
                        }
                        if (utility.useNewQuoteEngine && dirtyCustomFields[i].autocompleteResults.results instanceof Array) {
                            var valueObj = dirtyCustomFields[i].autocompleteResults.results.find(function (r) { return r.selected; });
                            cartUpdateParams.DirtyCustomFields[dirtyCustomFields[i].id] = valueObj ? valueObj.id : null;
                        }
                    }
                }
                return cartUpdateParams;
            };

            executeUpgradeProductsAction = function() {
                // timeout to allow bootstrap to toggle modal-open class on body
                setTimeout(function() {
                        self.areProductsUpgrading(true);
                        cartServerProxy.getProductsForUpgrade(updateDataProductVersions);

                        upgradeProductsDialogModule = {
                            areProductsUpgrading: self.areProductsUpgrading,
                            upgradedProductCount: self.upgradedProductCount,
                            productsForUpgrading: self.productsForUpgrading
                        };
                        utility.activateModalFromTemplate(upgradeProductsDialogModule, "UpgradeProductsProgressBarTemplate");
                    }, 500);
            };

            executeAction = function (actionId, propmptsUserForVersionUpdate, saveChanges) {
                var cartUpdateParams = getCartUpdateParams(self.activeEditableGroup(), saveChanges);
                if (self.hasUpdatableProducts() && propmptsUserForVersionUpdate) {
                    cartServerProxy.getCartProductsUpgradeConfirmationMessage(function (confirmationMessage) {
                        utility.dialog(
                            "",
                            confirmationMessage,
                            function () {
                                executeUpgradeProductsAction();
                            },
                            function () { return; }
                        );
                    });
                } else {
                    if (actionId === consts.quote.actions.placeOrderActionId) {
                        self.errorMessage("");
                    }
                    if (actionId === consts.quote.actions.placeOrderToERPActionId && checkIfCartIsInconsistentOrIncomplete()) {
                        utility.alert("", self.placeOrderToERPWarning);
                        return;
                    }
                    if (actionId === consts.quote.actions.approvalHistoryActionId) {
                        cartServerProxy.approvalHistory(self.ownerIdCrypted(), self.cartIdCrypted());
                    } else if (actionId === consts.quote.actions.reassignActionId) {
                        var reassignModle = new CartReassignModuleFactory(self.ownerId(), self.cartId());
                        reassignModle.canClose = true;
                        utility.activateModalFromTemplate(reassignModle, "ReassignCartDialogTemplate");
                    }
                    else if (actionId === consts.quote.actions.createPartialOrderId) {
                        var createPartialOrderModule = new CreatePartialOrderModuleFactory();
                        utility.activateModalFromTemplate(createPartialOrderModule, "CreatePartialOrderDialogTemplate");
                    } else if (actionId === consts.quote.actions.voidDocumentActionId) {
                        utility.confirm("", self.confirmVoidDocument, function () {
                            executeActionOnServer(actionId, cartUpdateParams, updateData);
                        });
                    } else {
                        executeActionOnServer(actionId, cartUpdateParams, updateData);
                    }
                }
            };

            checkIfCartIsInconsistentOrIncomplete = function () {
                if (self.items && self.items.mainItems) {
                    for (var i = 0; i < self.items.mainItems().length; i++) {
                        if (self.items.mainItems()[i].isInconsistent === true || self.items.mainItems()[i].isIncomplete === true) {
                            return true;
                        }
                    }
                    return false;
                }
            };

            executeActionOnServer = function (actionId, cartUpdateParams, updateData) {
                if (self.actionComment()
                    && (actionId === consts.quote.actions.acceptProposalActoinId
                        || actionId === consts.quote.actions.rejectProposalActoinId
                        || actionId === consts.quote.actions.proposeChangesActoinId)) {
                    // send comment and reset it
                    cartUpdateParams.ActionComment = self.actionComment();
                    self.actionComment('');
                };

                if (actionId === consts.quote.actions.upgradeActionId) {
                    executeUpgradeProductsAction();
                } else {
                    cartServerProxy.executeAction(actionId, cartUpdateParams, updateData);
                };
            };
            self.initializeRevisions = function (ownerId, cartId, callback) {
                RevisionsServerProxy.getRevisions(ownerId, cartId, function (serverRevisionsData) {
                    self.availableRevisions(serverRevisionsData);
                    var maxRevisionNumber = serverRevisionsData.map(function (r) { return r.RevisionId; }).reduce(function (a, b) { return Math.max(a, b); });
                    self.newRevisionName('Revision ' + (maxRevisionNumber + 1));
                    if (callback) {
                        callback();
                    }
                });
            };

            makeHomeEndKeysAccessibleInSections = function () {
                self.cartSections.forEach(function (elementId) {
                    utility.makeHomeEndKeysAccessibleInContainer('#' + elementId);
                });

                $('#cartCustomFields table').each(function (index, element) {
                    if (element.id) {
                        utility.makeHomeEndKeysAccessibleInContainer('#' + element.id);
                    };
                });

                if ($('#itemsTable').length) {
                    utility.makeHomeEndKeysAccessibleInContainer('#itemsTable');
                }
            };

            makeItemTypeAccessible = function () {
                $('.item-type-column').each(function (index, element) {
                    if (element.id) {
                        $('#' + element.id).on('shown.bs.popover', function () {
                            utility.makeFocusTrap('.item-type-popover');
                            utility.getFirstFocusableElementInContainer('.item-type-popover').focus();
                            window.lastActiveElementId = element.id;
                            $('.popover-content input, .popover-content button').each(function (index, element) {
                                $(element).on('keydown', function (event) {
                                    if (event.key === "Escape" || event.key === "Esc") {
                                        utility.focusLastActiveElementByIdIfExists();
                                    }
                                });
                            });
                        });
                    };
                });
            };

            function getEditOrViewAction(actions) {
                var action = ko.utils.arrayFirst(actions, function (a) { return a.ActionId === 13; });
                if (!action) {
                    action = ko.utils.arrayFirst(actions, function (a) { return a.ActionId === 1; });
                }
                if (action) {
                    return action.ActionId;
                }
                return -1;
            }

            self.selectRevision = function (data) {
                if (data.RevisionId !== self.selectedRevision().RevisionId) {
                    self.executeRevisionAction(data);
                }
            };

            self.executeRevisionAction = function (data, actionId) {
                var quoteId = data.QuoteId;
                var ownerId = data.OwnerId;
                var revisionId = data.RevisionId;
                if (!actionId) {
                    actionId = getEditOrViewAction(data.Actions);
                }
                if (actionId > 0) {
                    switch (actionId) {
                        case 1:
                            RevisionsServerProxy.viewQuote(ownerId, quoteId);
                            break;
                        case 15:
                            RevisionsServerProxy.executeAction({
                                actionId: actionId,
                                cryptedOwnerId: ownerId,
                                cryptedCartId: quoteId
                            },
                                function (serverData) {
									if (serverData.ErrorMessage) {
                                        toastr.error(serverData.ErrorMessage);
                                    } else {
                                        self.initializeRevisions(ownerId,
                                            quoteId,
                                            function () {
                                                var revision = ko.utils.arrayFirst(self.availableRevisions(),
                                                    function (r) {
                                                        return r.RevisionId === revisionId;
                                                    });
                                                if (revision) {
                                                    self.executeRevisionAction(revision);
                                                }
                                            });
                                    }
                                });
                            break;
                        default:
                            self.showNewRevisionDialog(false);
                            self.showRevisionNameDialog(false);
                            RevisionsServerProxy.executeAction({
                                NewRevisionName: self.newRevisionName(),
                                actionId: actionId,
                                cryptedOwnerId: ownerId,
                                cryptedCartId: quoteId
                            },
                                function (serverData) {
                                    if (serverData) {
                                        if (serverData.RedirectionUrl) {
                                            window.location.href = serverData.RedirectionUrl;
                                        } else {
                                            utility.hideLoaderAndOverlay();

											if (serverData.ErrorMessage) {
                                                toastr.error(serverData.ErrorMessage);
                                            }
                                            else if (actionId === 14) {
                                                self.executeRevisionAction({ QuoteId: quoteId, OwnerId: ownerId }, self.isInViewMode() ? 1 : 13);
                                            }
                                        }
                                    }
                                });
                            break;
                    }
                }
            };

            self.saveRevisionDialog = function () {
                if (self.showNewRevisionDialog()) {
                    self.executeRevisionAction(self.selectedRevision(), 14);
                    makeHomeEndKeysAccessibleInSections();
                } else if (self.showRevisionNameDialog()) {
                    RevisionsServerProxy.renameRevision(self.ownerIdCrypted(), self.cartIdCrypted(), self.selectedRevision().Name, function () {
                        self.executeRevisionAction(self.selectedRevision());
                        makeHomeEndKeysAccessibleInSections();
                    });
                }
            };

            self.cancelRevisionsDialog = function () {
                self.initializeRevisions(self.ownerIdCrypted(), self.cartIdCrypted());
                self.showNewRevisionDialog(false);
                self.showRevisionNameDialog(false);
                $('#quoteCustomDropdownMenu').focus();
            };

            self.goToRevisionsPage = function () {
                window.location.href = self.viewRevisionsUrl();
            };

            self.toggleCartActions = function () {
                var quotePageMainContainer = $(".quote-page-main-container");
                var actionsSidebarToggle = $(".actions-sidebar-toggle");
                var actionsContainerChildren = $("#actionsContainer > div:not(.actions-sidebar-toggle)");
                var animationDuration = 500;

                if (quotePageMainContainer && actionsSidebarToggle) {
                    quotePageMainContainer.toggleClass("actions-toggled");
                    actionsSidebarToggle.toggleClass("rotated-toggle-sidebar-icon");

                    if (quotePageMainContainer.hasClass('actions-toggled') && actionsContainerChildren) {
                        actionsContainerChildren.remove("hidden");
                    } else {
                        // timeout for animation
                        setTimeout(function () {
                            actionsContainerChildren.add("hidden");
                        }, animationDuration);
                    }
                }
            };

            self.toggleQuoteSectionOnKeypress = function(event, sectionMainContainerId) {
                event.preventDefault();
                if (event.key === "Enter" || event.key === "Spacebar" || event.key === " ") {
                    self.toggleQuoteSection(sectionMainContainerId);
                }
            };

            self.clickOnEnter = function (event) {
                if (event.key === "Enter") {
                    event.stopPropagation();
                    event.preventDefault();
                    event.target.click();
                    return false;
                }
                return true;
            };

            self.keydownEditableGroupsCellHandler = function(data, event) {
                var result = true;
                self.setVerticalTabbingEvents(data,event)
                return result;
            }

            self.setVerticalTabbingEvents = function(data, event) {
                if (event.shiftKey && event.key == 'Tab') {
                    var currentPosition =
                        jQuery.inArray(document.activeElement, $(".items-table .form-control:visible"));
                    if(currentPosition == -1){
                        return;
                    }
                    event.preventDefault();
                    if (currentPosition == 0) {
                        $(".items-table .form-control:visible").last().focus();
                    } else {
                        $(".items-table .form-control:visible")[currentPosition - 1].focus();
                    }
                    return false;
                }
                if (!event.shiftKey && event.key == 'Tab') {
                    var currentPosition =
                        jQuery.inArray(document.activeElement, $(".items-table .form-control:visible"));
                    if(currentPosition == -1){
                        return;
                    }
                    event.preventDefault();
                    if ($(".items-table .form-control:visible").length == currentPosition + 1) {
                        $(".items-table .form-control:visible").first().focus();
                    } else {
                        $(".items-table .form-control:visible")[currentPosition + 1].focus();
                    }
                    return false;
                }
                if (event.key == 'Escape') {
                    executeCalculateAction(0, false);
                }
                return true;
            }

            self.setVerticalTabbingEventsForAutocomplete = function(index) {
                $('.selection', $(".items-table .form-control:visible").parent()).children().on("keydown", function (event) {
                    if (event.shiftKey && event.key == 'Tab') {
                        event.preventDefault();
                        var currentPosition =
                            jQuery.inArray(document.activeElement, $('.selection', $(".items-table .form-control:visible").parent()).children());
                        if (currentPosition == 0) {
                            $('.selection', $(".items-table .form-control:visible").parent()).children().last().focus();
                        } else {
                            $('.selection', $(".items-table .form-control:visible").parent()).children()[currentPosition - 1].focus();
                        }
                        return false;
                    }
                    if (!event.shiftKey && event.key == 'Tab') {
                        event.preventDefault();
                        var currentPosition =
                            jQuery.inArray(document.activeElement, $('.selection', $(".items-table .form-control:visible").parent()).children());
                        if ($('.selection', $(".items-table .form-control:visible").parent()).children().length == currentPosition + 1) {
                            $('.selection', $(".items-table .form-control:visible").parent()).children().first().focus();
                        } else {
                            $('.selection', $(".items-table .form-control:visible").parent()).children()[currentPosition + 1].focus();
                        }
                        return false;
                    }
                    if (event.key == 'Escape') {
                        executeCalculateAction(0, true, $(this)[0].parentElement.parentElement.previousSibling.id);
                    }
                    return true;
                });
            }


            self.onKeypressItemsActionsHandler = function (data, event, index) {
                if (event.key === "Enter") {
                    var popoverTrigger = event.target;
                    $(popoverTrigger).click()
                    var popoverContent = $(".popover-content li:visible");

                    popoverContent.on("keydown", function (event) {
                        if (event.key == "Enter") {
                            event.target.click();
                            var id = event.target.id;
                            if (id.split('_')[0] == "collaborationComments") {
                                window.lastActiveElementId = "customerCommentsTitle";
                            } else if (id.split('_')[0] !== "moveUp" && id.split('_')[0] !== "moveDown") {
                                window.lastActiveElementId = popoverTrigger.id;
                            };
                        };
                    });

                    utility.makeDropdownAccessible('#itemActionsDropdown', '#' + popoverTrigger.id);
                };

                return true;
            }


            $(function() {self.setVerticalTabbingEventsForAutocomplete(0)})

            self.toggleQuoteSection = function (sectionMainContainerId) {
                if (sectionMainContainerId) {
                    $('#' + sectionMainContainerId + ' .fiori3-quote-section-container').show(500);
                    self.determineSectionsHeight(sectionMainContainerId);
                    if (self.isSectionCollapsed(sectionMainContainerId)) {
                        var collapsedSectionIndex = self.collapsedSections.indexOf(sectionMainContainerId);
                        if (collapsedSectionIndex >= 0) {
                            self.collapsedSections.splice(collapsedSectionIndex, 1);
                        }
                    } else {
                        self.collapsedSections.push(sectionMainContainerId);
                        $('#' + sectionMainContainerId + ' .fiori3-quote-section-container').hide(500);
                    }

                    localStorage.setItem("collapsedQuoteSections", self.collapsedSections().toString());
                }
            };

            self.makeTabdropAccessible = function () {
                if ($('.tabdrop .dropdown-toggle').length) {
                    $('.dropdown.tabdrop').on('shown.bs.dropdown', function () {
                        utility.makeDropdownAccessible('.tabdrop .dropdown-menu', '.tabdrop .dropdown-toggle');
                    });
                };
            };

            $(window).on('resize', self.makeTabdropAccessible);

            self.isSectionCollapsed = function (sectionMainContainerId) {
                return ko.pureComputed(function () {
                    return self.collapsedSections && self.collapsedSections.indexOf(sectionMainContainerId) >= 0;
                })();
            };

            self.initCollapsedSections = function () {
                var collapsedSectionCsv = localStorage.getItem('collapsedQuoteSections');
                if (collapsedSectionCsv) {
                    this.collapsedSections(collapsedSectionCsv.split(','));
                    for (var collapsedSectionIndex in this.collapsedSections()) {
                        let collapsedSectionId = this.collapsedSections()[collapsedSectionIndex];
                        $('#' + collapsedSectionId + ' .fiori3-quote-section-container').hide();
                    }
                }
            };

            executeCalculateAction = function (editableGroup, isAutocomplete, id) {
                var cartUpdateParams;
                if (!isAutocomplete) {
                    var $activeElem = $(document.activeElement);
                    if ($activeElem.hasClass('select2-selection')) {
                        // fix for select2 elements, since their active Element is a span but id is on the select element.
                        window.lastActiveElementId = 'select2_' + $activeElem.parents('.select2').siblings('select').attr('id');
                    } else {
                        window.lastActiveElementId = document.activeElement && document.activeElement.id ? document.activeElement.id : window.lastActiveElementId;
                    }
                } else {
                    window.lastActiveElementId = id;
                };

                if (editableGroup == null) {
                    cartUpdateParams = getCartUpdateParams(0);
                    cartUpdateParams.DirtyCells = null;

                } else {
                    cartUpdateParams = getCartUpdateParams(editableGroup)
                }
                cartServerProxy.calculate(cartUpdateParams, updateData);
            };

            buildActionsArray = function (observableArray, serverArray) {
                var newArray = [];
                ko.utils.arrayForEach(serverArray, function (item) {
                    var action = new ActionFactory(item);
                    if (item.Id === consts.quote.item.actions.replaceItemsActoinId) {
                        // we don't want to show replace items action in menu, we want to show it as button above items grid
                        self.canReplaceItems(true);
                        self.replaceActionName(action.name);
                        replaceItemAction = action;
                    } else {
                        newArray.push(action);
                    }
                });
                observableArray(newArray);
            };

            ActionFactory = function (serverItem) {
                var that = this;
                that.id = serverItem.Id;
                that.name = serverItem.Name;
                that.imageUrl = serverItem.ImageUrl;
                that.savesChanges = serverItem.SavesChanges;
                that.propmptsUserForVersionUpdate = serverItem.PropmptsUserForVersionUpdate;
                that.execute = function () {
                    if (!that.savesChanges && cellAndFieldManager.isCellOrCustomFieldsDirty()) {
                        utility.confirm("", self.discardUnsavedValuesMsg, function () {
                            executeAction(that.id, that.propmptsUserForVersionUpdate, false);
                        });
                    } else {
                        executeAction(that.id, that.propmptsUserForVersionUpdate);
                    }
                };
            };

            activateEditableGroup = function (editableGroup) {
                if (cellAndFieldManager.isCellOrCustomFieldsDirty()) {
                    executeCalculateAction(editableGroup, false);
                    makeHomeEndKeysAccessibleInSections();
                    makeItemTypeAccessible();
                    focusCorrespondingEditableGroupElement();
                } else {
                    cartServerProxy.setActiveEditableGroup(editableGroup, getFilterQuery(), function () {
                        executeWithRefocus(function () {
                            self.activeEditableGroup(editableGroup);
                            makeHomeEndKeysAccessibleInSections();
                            makeItemTypeAccessible();
                            focusCorrespondingEditableGroupElement();
                        });
                    });
                };
            };

            focusCorrespondingEditableGroupElement = function () {
                if (window.lastActiveElementId && window.lastActiveElementId.toLowerCase().indexOf('autocomplete') > -1) {
                    $('#' + window.lastActiveElementId + ' ~ .select2 .select2-selection').focus();
                } else if (window.lastActiveElementId && window.lastActiveElementId.split('_')[0] === 'select2') {
                    var idWithoutPrefix = window.lastActiveElementId.substring(window.lastActiveElementId.indexOf('_') + 1);
                    $('#' + idWithoutPrefix + ' ~ .select2 .select2-selection').focus();
                } else {
                    utility.focusLastActiveElementByIdIfExists();
                }
            };

            publishCartServerProxyEvents = function (namespaceObject) {
                function getProxyFunction(func, name) {
                    return function () {
                        if (name) {
                            utility.hideLoaderAndOverlay();
                            mediator.publish('RecommendationsModel.cancelRequest', false);
                        }
                        return func.apply(this, arguments);
                    };
                }

                for (var name in namespaceObject) {
                    var potentialFunction = namespaceObject[name];

                    if (Object.prototype.toString.call(potentialFunction) === '[object Function]') {
                        namespaceObject[name] = getProxyFunction(potentialFunction, name);
                    }
                }
            };


            //#endregion

            //#region State

            self.ownerId = ko.observable();
            self.cartId = ko.observable();
            self.opportunityId = ko.observable();
            self.opportunityName = ko.observable();
            self.origin = ko.observable();
            self.isPrimaryOnOpportunity = ko.observable();
            self.ownerIdCrypted = ko.observable();
            self.cartIdCrypted = ko.observable();
            self.workflowClientData = ko.observable();
            self.actionComment = ko.observable();
            self.hasUpdatableProducts = ko.observable(false);
            self.isInitalized = ko.observable(false);
            self.messageTitle = ko.observable();
            self.landingMessageTitle = ko.observable();
            self.messageItems = ko.observableArray();
            self.scriptingMessages = ko.observableArray();
            self.landingMessages = ko.observableArray();
            self.useRecurringPriceAndCost = ko.observable();
            self.cartCompositeNumber = ko.observable();
            self.dateCreated = ko.observable();
            self.dateTimeCreated = ko.observable();
            self.dateModified = ko.observable();
            self.dateTimeModified = ko.observable();
            //this field is kept for backward compatibility
            self.isEffectiveDateVisible = ko.observable(true);
            self.effectiveDate = ko.observable();
            self.revisionNumber = ko.observable();
            self.viewRevisionsUrl = ko.computed(function () {
                if (self.useNewQuoteEngine) {
                    return cartServerProxy.crateViewRevisionsUrlNewQuoteEngine(self.ownerIdCrypted(), self.cartIdCrypted());
                }
                return cartServerProxy.crateViewRevisionsUrl(self.ownerIdCrypted(), self.cartIdCrypted());
            });
            self.orderStatusId = ko.observable();
            self.orderStatuses = ko.observableArray();
            self.orderStatusName = ko.pureComputed(function () {
                var orderStatus = self.orderStatuses().find(function (status) {
                    return status.id === self.orderStatusId();
                });

                if (orderStatus) {
                    return orderStatus.name;
                }
            });

            self.IsPricingProcedureVisible = ko.observable();
            self.pricingProcedure = ko.observable();
            self.documentPricingProcedure = ko.observable();
            self.customerPricingProcedure = ko.observable();

            self.marketId = ko.observable();
            self.markets = ko.observableArray();

            self.marketName = ko.pureComputed(function () {
                var market = self.markets().find(function (market) {
                    return market.id === self.marketId();
                });

                if (market) {
                    return market.name;
                }
            });

            self.pricebookId = ko.observable();
            self.pricebooks = ko.observableArray();

            self.pricebookName = ko.pureComputed(function () {
                var pricebook = self.pricebooks().find(function (pricebook) {
                    return pricebook.value === self.pricebookId();
                });

                if (pricebook) {
                    return pricebook.text;
                }
            });

            self.orderId = ko.observable();
            self.externalId = ko.observable();
            self.isPricebookAvailable = ko.observable(true);
            self.shippingOptionId = ko.observable();
            self.shippingOptions = ko.observableArray();
            self.totalShippingCost = ko.observable(cellAndFieldManager.createCell());
            self.totalStateTax = ko.observable(cellAndFieldManager.createCell());
            self.mrcTotalStateTax = ko.observable(cellAndFieldManager.createCell());
            self.nrcTotalStateTax = ko.observable(cellAndFieldManager.createCell());

            self.totalVat = ko.observable(cellAndFieldManager.createCell());
            self.mrcTotalVat = ko.observable(cellAndFieldManager.createCell());
            self.nrcTotalVat = ko.observable(cellAndFieldManager.createCell());

            self.primaryActions = ko.observableArray();
            self.nonPrimaryActions = ko.observableArray();
            self.displayImagesForCartActions = ko.observable();
            self.canUndo = ko.observable();
            self.canRedo = ko.observable();
            self.totalAmount = ko.observable(cellAndFieldManager.createCell());
            self.mrcTotalAmount = ko.observable(cellAndFieldManager.createCell());
            self.estimatedContractTotalValue = ko.observable(cellAndFieldManager.createCell());
            self.tabsData = new CartTabsFactory();
            self.recommendationsData = new RecommendationsModelFactory();

            self.collapsedSections = ko.observableArray();


            self.selectedRevision = ko.computed(function () {
                return ko.utils.arrayFirst(self.availableRevisions(),
                    function (r) { return r.RevisionId.toString() === self.revisionNumber(); });
            });

            self.selectedRevisionName = ko.computed(function () {
                var revision = self.selectedRevision();
                if (revision) {
                    return revision.Name + (revision.IsActive ? ' (Active)' : '');
                }
                return '';
            });

            self.hasActions = function (revision, actionIds) {
                if (revision) {
                    var action = ko.utils.arrayFirst(revision.Actions, function (r) { return actionIds.indexOf(r.ActionId) > -1; });
                    if (action) {
                        return true;
                    }
                }
                return false;
            };

            self.showNewRevisionDialog = ko.observable(false);
            self.showRevisionNameDialog = ko.observable(false);
            self.newRevisionName = ko.observable();

            self.items = {
                columns: ko.observableArray(),
                cellColumns: ko.observableArray(),
                mainItems: ko.observableArray(),
                renderCount: ko.observable(consts.quote.item.itemsRenderBatchSize)
            };

            self.items.renderingMainItems = self.items.mainItems.filter(function (item) {
                return self.areItemsPaged() || item.index < self.items.renderCount(); // if items are paged always return true
            });

            self.areItemsPaged = ko.observable();

            self.pager = new Pager(
                1,
                0,
                10,
                [5, 10, 20, 50, 100],
                false, // don't autofix current page because server will so that and autocorrect could cause 2 calls to server
				false,
				"cartPager"
            );

            self.isMobile = ko.pureComputed(function () {
                return utility.viewportWidth() <= 800;
            });

            self.productTypes = {
                columns: ko.observableArray(),
                cellColumns: ko.observableArray(),
                columnLabels: ko.observableArray(),
                rows: ko.observableArray(),
                totals: ko.observableArray()
            };

            self.subTotalsWithDiscounts = {
                columns: ko.observableArray(),
                rows: ko.observableArray()
            };

            self.totals = {
                columns: ko.observableArray(),
                rows: ko.observableArray()
            };

            self.areAdditionalDiscountsEditable = ko.observable(false);
            self.additionalDiscounts = ko.observableArray();
            self.customFields = ko.observableArray();
            self.cartComment = ko.observable(cellAndFieldManager.createCell());
            self.quickAdd = new CartQuickAddModelFactory();
            self.itemsSearch = new CartItemsSearchModelFactory();
            self.approval = new CartApprovalModelFactory();
            self.quoteTables = ko.observableArray();
            self.customFieldsAndQuoteTables = ko.observableArray();

            self.proposal = {
                display: ko.observable(false),
                message: ko.observable(),
                docType: ko.observable(),
                docDownloadLink: ko.observable(),
                additionalDocuments: ko.observable()
            };

            self.diplayAddProdSection = ko.observable(true);
            self.showQuickConfig = ko.observable(true);
            self.displayActions = ko.computed(function () {
                return self.primaryActions().length > 0 || self.nonPrimaryActions.length > 0;
            });

            self.sections = ko.observableArray();

            self.cartUsage = ko.observableArray();
            self.areActionsActive = ko.observable(false);
            self.isEmpty = ko.computed(function () {
                return self.items.mainItems().length === 0;
            });
            self.isMobileReady = ko.computed(function () {
                return utility.viewportWidth() <= 800;
            });
            self.areActionsVisibleOnSide = ko.computed(function () {
                return utility.viewportWidth() > 992;
            });
            self.replaceActionName = ko.observable('');
            self.promosInfo = {
                shouldShowPromotionsInfo: ko.observable(false),
                hasSomeUnappliedSuggest: ko.observable(false),
                hasSomeAppliedSuggest: ko.observable(false),
                topDescription: ko.observable()
            };

            self.selectedItemsType = ko.observable("0");
            self.isItemTypeEditable = ko.observable();
            self.isSearchInputFocused = ko.observable(false);
            self.areItemsCollapsed = ko.observable(false);
            self.isAnyItemSelected = ko.computed(function () {
                return itemsModel.getSelectedCartItems(self.items.mainItems).length !== 0;
            });
            //#endregion

            //#region Methods

            function resetCollapseFilters(collapse) {
                self.filterPills.remove(function (f) {
                    return f.operator() === "collapse" || f.operator() === "collapseall" || f.operator() === "expand";
                });
                self.items.mainItems().forEach(function (f) {
                    f.isExpanded(!collapse);
                });
            }

            self.toggleItemsState = function () {
                if (self.areItemsCollapsed()) {
                   self.expandAll();
                } else {
                   self.collapseAll();
                }
                self.areItemsCollapsed(!self.areItemsCollapsed());
                window.lastActiveElementId = 'toggleAllItemsTrigger';
            };

            self.expandAll = function () {
                if (self.useNewQuoteEngine) {
                    resetCollapseFilters(false);
                    self.applyFilter();
                } else {
                    if (self.useNewQuoteEngine) {
                        if (self.areItemsPaged()) {
                            loadItems(); // if paged reload items
                        } else {
                            setExpanded(self.items.mainItems, true); // if not paged just sync client state
                        }
                    }
                    else {
                        cartServerProxy.expandAll(function () {
                            if (self.areItemsPaged()) {
                                loadItems(); // if paged reload items
                            } else {
                                setExpanded(self.items.mainItems, true); // if not paged just sync client state
                            }
                        });
                    }
                }
            };

            self.collapseAll = function () {
                if (self.useNewQuoteEngine) {
                    resetCollapseFilters(true);
                    self.filterPills.push(filterService.createFilter({
                        field: 'RolledUpItemNumber',
                        operator: 'collapseall',
                        dataType: 0,
                        template: null
                    }));
                    self.applyFilter();
                } else {
                    if (self.useNewQuoteEngine) {
                        if (self.areItemsPaged()) {
                            loadItems(); // if paged reload items
                        } else {
                            setExpanded(self.items.mainItems, false); // if not paged just sync client state
                        }
                    } else {
                        cartServerProxy.collapseAll(function () {
                            if (self.areItemsPaged()) {
                                loadItems(); // if paged reload items
                            } else {
                                setExpanded(self.items.mainItems, false); // if not paged just sync client state
                            }
                        });
                    }
                }
            };

            self.toggleCanManageItems = function () {
                if (!self.canManageItems()
                    && self.partNumberEditableGroup
                    && self.partNumberEditableGroup !== self.activeEditableGroup()) {
                    // if starting managed mode and part number
                    activateEditableGroup(self.partNumberEditableGroup);
                }

                self.canManageItems(!self.canManageItems());
            };

            self.deleteSelectedItems = function () {
                var cartItems = itemsModel.getSelectedCartItems(self.items.mainItems);
                if (cartItems.length > 0) {
                    utility.confirm('', self.deleteItemsMsg, function () {
                        cartServerProxy.deleteItems(cartItems, updateData);
                    });
                }
            };

            self.changeItemsType = function () {
                var cartItems = itemsModel.getSelectedCartItems(self.items.mainItems);
                if (cartItems.length > 0) {
                    cartServerProxy.changeItemsType(cartItems, self.selectedItemsType(), getFilterQuery(), updateData);
                }
                self.close();
            };

            self.updateCartItems = function () {
                var reorderItems = itemsModel.getReorderItems(self.items.mainItems);
                cartServerProxy.reorderItems(reorderItems, updateData);
            };

            self.undo = function () {
                cartServerProxy.undo(updateData);
            };

            self.redo = function () {
                cartServerProxy.redo(updateData);
            };

            self.calculate = function () {
                executeCalculateAction(self.activeEditableGroup(), false);
            };

            self.saveCustomFields = function(callback) {
                cartServerProxy.calculate(getCartUpdateParams(), callback)
            }

            self.calculateCellAction = function(id) {
                self.calculate();
                window.lastActiveElementId = id;
                mediator.publish('cartCellManager.CellFocusUpdated');
            };

            self.crateNewAdditionalDiscount = function () {
                cartServerProxy.crateNewAdditionalDiscount(getCartUpdateParams(), updateData);
            };

            $(".fiori3-quote-section-add-new").click(function (event) {
                event.stopPropagation();
            });

            self.QuickAddModuleFactory = function () {
                return self.quickAdd;
            };

            self.ItemsSearchModuleFactory = function () {
                return self.itemsSearch;
            };

            self.toggleAreActionsActive = function () {
                self.areActionsActive(!self.areActionsActive());
            };

            self.isDirty = function () {
                return cellAndFieldManager.isCellOrCustomFieldsDirty();
            };

            self.areCellsDirty = function () {
                return cellAndFieldManager.getDirtyCells().length > 0;
            }

            self.areCustomFieldsDirty = function () {
                return cellAndFieldManager.getDirtyCustomFields().length > 0;
            };

            self.replaceCartItems = function () {
                if (replaceItemAction) {
                    replaceItemAction.execute();
                }
            };

            self.renderMoreItems = function () {
                self.items.renderCount(self.items.renderCount() + consts.quote.item.itemsRenderBatchSize);
            };

            self.viewPromotions = function () {
                var cartPromotionsModel = new CartPromotionsModelFactory();
                utility.activateModalFromTemplate(cartPromotionsModel, "PromotionDialogTemplate");
            };

            //#endregion

            //#region Handlers
            self.effectiveDate.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeEffectiveDate(newValue, getFilterQuery(), updateData);
                }
            });

            self.opportunityId.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeOpportunityId(newValue, updateData);
                }
            });

            self.opportunityName.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeOpportunityName(newValue, updateData);
                }
            });

            self.orderStatusId.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeStatus(newValue, getFilterQuery(), updateData);
                }
            });

            self.marketId.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeMarket(newValue, getFilterQuery(), updateData, function (error) {
                        cartServerProxy.getProductsWithoutPricesForMarket(newValue, function (productSystemIds) {
                            self.openPricebookMissingForMarketDialog(error.responseJSON.Message, productSystemIds);
                        });
                        self.marketId(previousMarketId);
                    });
                }
            });

            self.pricebookId.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changePricebook(newValue, getFilterQuery(), updateData);
                }
            });

            self.shippingOptionId.subscribe(function (newValue) {
                if (!suppressUpdates) {
                    cartServerProxy.changeShipping(newValue, updateData);
                }
            });

            self.selectAll.subscribe(function (newValue) {
                if (newValue) {
                    itemsModel.selectAll(self.items.mainItems);
                } else {
                    itemsModel.deselectAll(self.items.mainItems);
                }
            });

            self.pager.currentPage.subscribe(itemsPagingHandler);

            self.toggleDebugger = function () {
                self.debuggerUrl(self.showDebugger() ? '' : common.getDebuggerUrl('CartDebugger.aspx'));
                self.showDebugger(!self.showDebugger());
            };

            self.showDebuggerWindow = function () {
                window.open(common.getDebuggerUrl('CartDebugger.aspx'), 'Debugger', 'width=600,height=770'); return false;
            };

            mediator.subscribe("invalidAutocompleteNotificationModel.updateCartData", function (serverData) {
                updateData(serverData);
            });


            self.pager.pageSize.subscribe(itemsPagingHandler);

            mediator.subscribe('cartCellManager.activateEditableGroup', activateEditableGroup);

            mediator.subscribe('cartCellManager.customFieldsChanged', function () {
                self.calculate();
            });

            mediator.subscribe("cartItemsModel.updateData", function (serverData) {
                updateData(serverData);
            });

            mediator.subscribe("quoteTablesModel.addRow", function (tableId) {
                cartServerProxy.addQuoteTableRow(tableId, self.tabId(), false, getFilterQuery(), updateDataQuoteTable);
            });

            mediator.subscribe("quoteTablesModel.deleteRow", function (tableId, rowId, deleteRowIdToFocus) {
                self.quoteTableActiveElement = deleteRowIdToFocus;
                cartServerProxy.deleteQuoteTableRow(rowId, tableId, self.tabId(), false, getFilterQuery(), updateDataQuoteTable);
            });

            mediator.subscribe("quoteTablesModel.copyRow", function (tableId, rowId) {
                cartServerProxy.copyQuoteTableRow(rowId, tableId, self.tabId(), false, getFilterQuery(), updateDataQuoteTable);
            });

            mediator.subscribe("quoteTablesModel.onQuoteTableCellChanged", function (tableId, changedCell, cellId, cellType) {
                self.lastActiveQuoteTable = tableId;
                if (cellType === 2) {
                    self.quoteTableActiveElement = cellId;
                }
                cartServerProxy.changeQuoteTableCells(changedCell, self.tabId(), false, getFilterQuery(), updateDataQuoteTable);
            });

            mediator.subscribe('quoteTableModels.checkQuoteTableFocus', function() {
                if (self.lastActiveQuoteTable) {
                    if (self.currentActiveElementId && $('#' + self.currentActiveElementId).length === 0) {
                        self.currentActiveElementId = self.lastActiveQuoteTable + '_searchButton';
                    }
                    self.lastActiveQuoteTable = null;
                }
            });

            mediator.subscribe("quoteTablesModel.executeQuoteTableCustomAction", function (tableId, actionId) {
                cartServerProxy.executeQuoteTableCustomAction(self.tabId(), tableId, actionId, false, updateDataQuoteTable);
            });

            mediator.subscribe("itemTypeEditModel.changeItemType", function (cartItem, newItemType, newBaseItem) {
                cartServerProxy.changeItemType(cartItem, newItemType, newBaseItem, getFilterQuery(), updateData);
            });

            mediator.subscribe("CartQuickAddModel.addToQuote", function (id, quantity) {
                cartServerProxy.addToQuote(id, quantity, getFilterQuery(), updateData);
            });

            mediator.subscribe("CartQuickAddModel.addFavoriteToQuote", function (id, quantity) {
                cartServerProxy.addFavoriteToQuote(id, quantity, getFilterQuery(), updateData);
            });

            mediator.subscribe("CartApproval.applySliderValue", function (sliderId, value) {
                cartServerProxy.changeApprovalProbability(sliderId, value, updateData);
            });

            mediator.subscribe("cartCellManager.applyMarginHealthValue", function (value, calculationMode, id) {
                cartServerProxy.changeMarginHealth(value, calculationMode, id, updateData);
            });

            mediator.subscribe("CartReassignModule.CartReassigned", function () {
                cartServerProxy.navigateToCartList();
            });

            mediator.subscribe("cartItemsModel.toggleExpanded", function () {
                if (self.areItemsPaged()) {
                    loadItems();
                }
            });

            mediator.subscribe("CartItemSearchModel.jumpToItem", function (cartItem) {
                window.lastActiveElementId = 'searchInput2';
                loadItems(cartItem);
            });

            mediator.subscribe('cart.customfield.autocomplete.select', function (scParamId, contentId, callback) {
                cartServerProxy.selectAutocompleteCustomField(scParamId, contentId, callback);
            });

            mediator.subscribe('cart.customfield.autocomplete.unselect', function (scParamId, callback) {
                cartServerProxy.selectAutocompleteCustomField(scParamId, 0, callback);
            });

            mediator.subscribe('RecommendationsModel.recommendationsApplied', function () {
                toastr.success(self.recommendationsAppliedMessage);
                queryString = utility.getQueryString();
                cartServerProxy.getInitData(cartMode, queryString.ownerid, queryString.cartid, queryString.avc, function (serverData) {
                    initData(serverData.InitData);

                    if (self.useNewQuoteEngine) {
                        loadItems();
                    }

                    updateData(serverData);

                    if (serverData.InitData && serverData.InitData.PromptForUpgradeMessage) {
                        utility.confirm(
                            "",
                            serverData.InitData.PromptForUpgradeMessage,
                            function () {
                                executeUpgradeProductsAction();
                            }
                        );
                    }
                });
            });

            self.showRevisionNameDialog.subscribe(function () {
                var animationDuration = 150;
                setTimeout(function () {
                    utility.makeHomeEndKeysAccessibleInContainer('#quote-info-section');
                }, animationDuration);
            })
            //#endregion

            // reset tab indexes

            mediator.publish("API:modelCreated", { model: self, modelName: "cart" });

            queryString = utility.getQueryString();
            cartServerProxy.getInitData(cartMode, queryString.ownerid, queryString.cartid, queryString.avc, function (serverData) {
                if (self.useNewQuoteEngine && serverData.InitData) {
                    self.visitorId = serverData.VisitorId;
                    filterEditor = new QuoteItemsFilterEditor({
                        filterPills: self.filterPills,
                        toggleFilterEditor: self.toggleFilterEditor,
                        toggleFilterEditorOnEnter: self.toggleFilterEditorOnEnter,
                        applyFilter: self.applyFilter,
                        visitorId: self.visitorId
                    });
                }

                if (serverData.CartNotLoaded) {
                    utility.alert("", serverData.ErrorMessage, function () {
                        cartServerProxy.navigateToCartList();
                    });

                    return;
                }

                var filtersKey = serverData.InitData.CartId + "_" + serverData.VisitorId;

                self.quoteItemFilterCache.setCartIdentity(filtersKey);

                self.quoteItemFilterCache.getFilterJS(function (filtersModel) {
                    filtersModel.forEach(function (f) {
                        var existingItemColumn = serverData.InitData.ItemColumns.find(function (ic) {
                            return ic.Name === f.field || f.field === "PartNumber" || f.field === "ProductTypeId" || f.field === "Description" || f.field === 'Unallocated' || f.field === 'OnlyMineSections';
                        });
                        if (existingItemColumn || f.dataType === 0) {
                            self.filterPills.push(filterService.createFilter(f));
                        }
                    });
                });


                initData(serverData.InitData);

                updateData(serverData);

                if (serverData.InitData && serverData.InitData.PromptForUpgradeMessage) {
                    utility.confirm(
                        "",
                        serverData.InitData.PromptForUpgradeMessage,
                        function () {
                            executeUpgradeProductsAction();
                        }
                    );
                }

                self.setTooltips();
            });

            var filterEditor = null;
            self.filterEditor = ko.observable();
            self.filteredTotalAmount = ko.observable();

            self.applyFilter = function () {
                if (self.pager.currentPage() > 1) {
                    self.pager.currentPage(1); //this triggers loadData
                } else {
                    loadItems();
                }
            };

            self.toggleFilterEditor = function () {
                if (self.filterEditor()) {
                    self.filterEditor(null);

                    setTimeout(function () {
                        var $el = utility.getFirstFocusableElementInContainer('.quote-filter-pills-container');
                        if ($el.length) {
                            $el.focus();
                        } else {
                            $('#itemsFilter').focus();
                        };
                    }, filterSidebarAnimationDuration);
                } else {
                    self.filterEditor(filterEditor);
                    self.filterEditor().initContextService();
                    self.filterEditor().initMetaData();
                }
            };

            self.toggleFilterEditorOnEnter = function (event) {
                if (event.key == 'Enter' || event.key == 'NumpadEnter') {
                    self.toggleFilterEditor();
                };
            };

            self.removeFilterCriteria = function (criteria) {
                self.filterPills.remove(criteria);
                self.applyFilter();
                window.lastActiveElementId = self.displayFilterPills().length ? utility.getFirstFocusableElementInContainer('.quote-filter-pills-container').attr('id') : 'itemsFilter';
            };

            self.clearFilters = function () {
                self.filterPills.remove(function (f) {
                    return f.dataType !== 0; //leave system filters
                });
                self.applyFilter();
                window.lastActiveElementId = "itemsFilter";
            };

            mediator.subscribe("quoteItemsFilterEditor.metaDataInitialized", function () {
                setTimeout(function () {
                    utility.makeFocusTrap('#filter-editor-content');
                    utility.getFirstFocusableElementInContainer('#quoteFilterContainer', ':not(a)').focus();
                    $(utility.getAllFocusableElements('#filter-editor-content')).each(function (index, element) {
                        if (element.id !== 'productTypeField') {
                            $(element).on('keydown', function () {
                                if (event.key === "Escape" || event.key === "Esc") {
                                    self.filterEditor(null);
                                    $('#' + 'itemsFilter').focus();
                                };
                            });
                        };
                    });

                    $('#productTypeField').on('keyup', function (event) {
                        if (event.key === 'Escape' || event.key === "Esc") {
                            if ($('#availableSuggestionsContainer').length) {
                                mediator.publish('cartModel.toggleProductTypeSuggestions');
                            } else {
                                self.toggleFilterEditor();
                            };
                        };
                    });
                }, filterSidebarAnimationDuration);
            });

            self.determineSectionsHeight = function (sectionId) {
                var quoteSection = $('#' + sectionId);

                if (quoteSection.length) {
                    quoteSection.css({ 'max-height': quoteSection.prop("scrollHeight"), 'overflow': 'hidden' });

                    // removing max-height to allow content changes in section
                    if (self.isSectionCollapsed(sectionId)) {
                        quoteSection.css({ 'max-height': 'none', 'overflow': 'visible' });
                    }
                }
            };

            self.setTooltips = function() {
                $('.tooltip-if-long').each(function(i, element) {
                    // -1 to allow for Edge's inaccuracy
                    if ($(element).prop('scrollWidth') - 1 <= $(element).prop('offsetWidth')) {
                        $(element).tooltip('destroy');
                    }
                });
            };

            self.openSearchInput = function () {
                self.isSearchInputFocused(true);
                $('.fiori3-table .fiori3-items-search .fiori3-input-group').removeClass('shrink-search-field');
                $('.fiori3-table .fiori3-items-search .fiori3-input-group').addClass('search-in-use');
                $('#searchInput2').focus();
                $('.search-input-trigger').css('pointer-events', 'none');
            };

            self.collapseSearchInput = function () {
                if ($('#searchInput2').val() === "") {
                    var animationDuration = 500;

                    $('.fiori3-table .fiori3-items-search .fiori3-input-group').removeClass('search-in-use');
                    $('.fiori3-table .fiori3-items-search .fiori3-input-group').addClass('shrink-search-field');
                    // timeout for animation
                    setTimeout(function () {
                        self.isSearchInputFocused(false);
                    }, animationDuration);
                }
                $('.search-input-trigger').css('pointer-events', 'auto');

            };

            $('#searchInput2').focusout(self.collapseSearchInput);

            $('#searchInput2').on('keypress', function (event) {
                if (event.which === 13) {
                    self.collapseSearchInput();
                }
            });

            self.getViewportWidth = function () {
                return window.innerWidth;
            }

            self.openPricebookMissingForMarketDialog = function (errorMessage, productIds) {
                var openPricebookMissingForMarketDialogModel = {
                    errorMessage: errorMessage,
                    productIds: productIds,
                    utility: utility,
                    copied: ko.observable()
                };

                utility.activateModalFromTemplate(openPricebookMissingForMarketDialogModel, "PricebookMissingForMarketDialogTemplate");
            };
        };
    });

/*
 * jQuery Highlight plugin
 *
 * Based on highlight v3 by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Code a little bit refactored and cleaned (in my humble opinion).
 * Most important changes:
 *  - has an option to highlight only entire words (wordsOnly - false by default),
 *  - has an option to be case sensitive (caseSensitive - false by default)
 *  - highlight element tag and class names can be specified in options
 *
 * Usage:
 *   // wrap every occurrance of text 'lorem' in content
 *   // with <span class='highlight'> (default options)
 *   $('#content').highlight('lorem');
 *
 *   // search for and highlight more terms at once
 *   // so you can save some time on traversing DOM
 *   $('#content').highlight(['lorem', 'ipsum']);
 *   $('#content').highlight('lorem ipsum');
 *
 *   // search only for entire word 'lorem'
 *   $('#content').highlight('lorem', { wordsOnly: true });
 *
 *   // don't ignore case during search of term 'lorem'
 *   $('#content').highlight('lorem', { caseSensitive: true });
 *
 *   // wrap every occurrance of term 'ipsum' in content
 *   // with <em class='important'>
 *   $('#content').highlight('ipsum', { element: 'em', className: 'important' });
 *
 *   // remove default highlight
 *   $('#content').unhighlight();
 *
 *   // remove custom highlight
 *   $('#content').unhighlight({ element: 'em', className: 'important' });
 *
 *
 * Copyright (c) 2009 Bartek Szopka
 *
 * Licensed under MIT license.
 *
 */

jQuery.extend({
    highlight: function (node, re, nodeName, className) {
        if (node.nodeType === 3) {
            var match = node.data.match(re);
            if (match) {
                var highlight = document.createElement(nodeName || 'span');
                highlight.className = className || 'highlight';
                var wordNode = node.splitText(match.index);
                wordNode.splitText(match[0].length);
                var wordClone = wordNode.cloneNode(true);
                highlight.appendChild(wordClone);
                wordNode.parentNode.replaceChild(highlight, wordNode);
                return 1; //skip added node in parent
            }
        } else if ((node.nodeType === 1 && node.childNodes) && // only element nodes that have children
                !/(script|style)/i.test(node.tagName) && // ignore script and style nodes
                !(node.tagName === nodeName.toUpperCase() && node.className === className)) { // skip if already highlighted
            for (var i = 0; i < node.childNodes.length; i++) {
                i += jQuery.highlight(node.childNodes[i], re, nodeName, className);
            }
        }
        return 0;
    }
});

jQuery.fn.unhighlight = function (options) {
    var settings = { className: 'highlight', element: 'span' };
    jQuery.extend(settings, options);

    return this.find(settings.element + "." + settings.className).each(function () {
        var parent = this.parentNode;
        parent.replaceChild(this.firstChild, this);
        parent.normalize();
    }).end();
};

jQuery.fn.highlight = function (words, options) {
    var settings = { className: 'highlight', element: 'span', caseSensitive: false, wordsOnly: false };
    jQuery.extend(settings, options);
    
    if (words.constructor === String) {
        words = [words];
    }
    words = jQuery.grep(words, function(word, i){
      return word != '';
    });
    words = jQuery.map(words, function(word, i) {
      return word.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    });
    if (words.length == 0) { return this; };

    var flag = settings.caseSensitive ? "" : "i";
    var pattern = "(" + words.join("|") + ")";
    if (settings.wordsOnly) {
        pattern = "\\b" + pattern + "\\b";
    }
    var re = new RegExp(pattern, flag);
    
    return this.each(function () {
        jQuery.highlight(this, re, settings.element, settings.className);
    });
};


define("jqueryHighlight", ["jquery"], function(){});

//core.js, widget.js, mouse.js, sortable.js
(function ($, undefined) {

    var uuid = 0,
        runiqueId = /^ui-id-\d+$/;

    // prevent duplicate loading
    // this is only a problem because we proxy existing functions
    // and we don't want to double proxy them
    $.ui = $.ui || {};
    if ($.ui.version) {
        return;
    }

    $.extend($.ui, {
        version: "1.10.1",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        _focus: $.fn.focus,
        focus: function (delay, fn) {
            return typeof delay === "number" ?
                this.each(function () {
                    var elem = this;
                    setTimeout(function () {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) :
                this._focus.apply(this, arguments);
        },

        scrollParent: function () {
            var scrollParent;
            if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
                scrollParent = this.parents().filter(function () {
                    return (/(relative|absolute|fixed)/).test($.css(this, "position")) && (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            } else {
                scrollParent = this.parents().filter(function () {
                    return (/(auto|scroll)/).test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
                }).eq(0);
            }

            return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },

        zIndex: function (zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        },

        uniqueId: function () {
            return this.each(function () {
                if (!this.id) {
                    this.id = "ui-id-" + (++uuid);
                }
            });
        },

        removeUniqueId: function () {
            return this.each(function () {
                if (runiqueId.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ?
            !element.disabled :
            "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
            !$(element).parents().addBack().filter(function () {
                return $.css(this, "visibility") === "hidden";
            }).length;
    }

    $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function (dataName) {
                return function (elem) {
                    return !!$.data(elem, dataName);
                };
            }) :
            // support: jQuery <1.8
            function (elem, i, match) {
                return !!$.data(elem, match[3]);
            },

        focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },

        tabbable: function (element) {
            var tabIndex = $.attr(element, "tabindex"),
                isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support: jQuery <1.8
    if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function (i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function () {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function (size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function (size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function () {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }

    // support: jQuery <1.8
    if (!$.fn.addBack) {
        $.fn.addBack = function (selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        };
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function (removeData) {
            return function (key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        })($.fn.removeData);
    }





    // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

    $.support.selectstart = "onselectstart" in document.createElement("div");
    $.fn.extend({
        disableSelection: function () {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
                ".ui-disableSelection", function (event) {
                    event.preventDefault();
                });
        },

        enableSelection: function () {
            return this.unbind(".ui-disableSelection");
        }
    });

    $.extend($.ui, {
        // $.ui.plugin is deprecated.  Use the proxy pattern instead.
        plugin: {
            add: function (module, option, set) {
                var i,
                    proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([option, set[i]]);
                }
            },
            call: function (instance, name, args) {
                var i,
                    set = instance.plugins[name];
                if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                    return;
                }

                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        },

        // only used by resizable
        hasScroll: function (el, a) {

            //If overflow is hidden, the element might have extra content, but the user wants to hide it
            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        }
    });

})(jQuery);

(function ($, undefined) {

    var uuid = 0,
        slice = Array.prototype.slice,
        _cleanData = $.cleanData;
    $.cleanData = function (elems) {
        for (var i = 0, elem; (elem = elems[i]) != null; i++) {
            try {
                $(elem).triggerHandler("remove");
                // http://bugs.jquery.com/ticket/8235
            } catch (e) { }
        }
        _cleanData(elems);
    };

    $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function () {
                var _super = function () {
                    return base.prototype[prop].apply(this, arguments);
                },
                    _superApply = function (args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function () {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);
    };

    $.widget.extend = function (target) {
        var input = slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === "string",
                args = slice.call(arguments, 1),
                returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
                $.widget.extend.apply(null, [options].concat(args)) :
                options;

            if (isMethodCall) {
                this.each(function () {
                    var methodValue,
                        instance = $.data(this, fullName);
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack(methodValue.get()) :
                            methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {})._init();
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function ( /* options, element */) { };
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function () {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind(this.eventNamespace)
                // 1.9 BC for #7810
                // TODO remove dual storage
                .removeData(this.widgetName)
                .removeData(this.widgetFullName)
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData($.camelCase(this.widgetFullName));
            this.widget()
                .unbind(this.eventNamespace)
                .removeAttr("aria-disabled")
                .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function () {
            return this.element;
        },

        option: function (key, value) {
            var options = key,
                parts,
                curOption,
                i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (value === undefined) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (value === undefined) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function (options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function (key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
                    .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
                    .attr("aria-disabled", value);
                this.hoverable.removeClass("ui-state-hover");
                this.focusable.removeClass("ui-state-focus");
            }

            return this;
        },

        enable: function () {
            return this._setOption("disabled", false);
        },
        disable: function () {
            return this._setOption("disabled", true);
        },

        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                // accept selectors, DOM elements
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                            (instance.options.disabled === true ||
                                $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^(\w+)\s*(.*)$/),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function (element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },

        _delay: function (handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function (event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function (event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function (type, event, data) {
            var prop, orig,
                callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
        $.Widget.prototype["_" + method] = function (element, options, callback) {
            if (typeof options === "string") {
                options = { effect: options };
            }
            var hasOptions,
                effectName = !options ?
                method :
                    options === true || typeof options === "number" ?
                defaultEffect :
                        options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function (next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

})(jQuery);

(function ($, undefined) {

    var mouseHandled = false;
    $(document).mouseup(function () {
        mouseHandled = false;
    });

    $.widget("ui.mouse", {
        version: "1.10.1",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function () {
            var that = this;

            this.element
                .bind("mousedown." + this.widgetName, function (event) {
                    return that._mouseDown(event);
                })
                .bind("click." + this.widgetName, function (event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function () {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                $(document)
                    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function (event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) { return; }

            // we may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function () {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // these delegates are required to keep context
            this._mouseMoveDelegate = function (event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function (event) {
                return that._mouseUp(event);
            };
            $(document)
                .bind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .bind("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function (event) {
            // IE mouseup check - mouseup happened when mouse was out of window
            if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                return this._mouseUp(event);
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function (event) {
            $(document)
                .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            return false;
        },

        _mouseDistanceMet: function (event) {
            return (Math.max(
                    Math.abs(this._mouseDownEvent.pageX - event.pageX),
                    Math.abs(this._mouseDownEvent.pageY - event.pageY)
                ) >= this.options.distance
            );
        },

        _mouseDelayMet: function (/* event */) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function (/* event */) { },
        _mouseDrag: function (/* event */) { },
        _mouseStop: function (/* event */) { },
        _mouseCapture: function (/* event */) { return true; }
    });

})(jQuery);

(function ($, undefined) {

    /*jshint loopfunc: true */

    function isOverAxis(x, reference, size) {
        return (x > reference) && (x < (reference + size));
    }

    $.widget("ui.sortable", $.ui.mouse, {
        version: "1.10.1",
        widgetEventPrefix: "sort",
        ready: false,
        options: {
            appendTo: "parent",
            axis: false,
            connectWith: false,
            containment: false,
            cursor: "auto",
            cursorAt: false,
            dropOnEmpty: true,
            forcePlaceholderSize: false,
            forceHelperSize: false,
            grid: false,
            handle: false,
            helper: "original",
            items: "> *",
            opacity: false,
            placeholder: false,
            revert: false,
            scroll: true,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            scope: "default",
            tolerance: "intersect",
            zIndex: 1000,

            // callbacks
            activate: null,
            beforeStop: null,
            change: null,
            deactivate: null,
            out: null,
            over: null,
            receive: null,
            remove: null,
            sort: null,
            start: null,
            stop: null,
            update: null
        },
        _create: function () {

            var o = this.options;
            this.containerCache = {};
            this.element.addClass("ui-sortable");

            //Get the items
            this.refresh();

            //Let's determine if the items are being displayed horizontally
            this.floating = this.items.length ? o.axis === "x" || (/left|right/).test(this.items[0].item.css("float")) || (/inline|table-cell/).test(this.items[0].item.css("display")) : false;

            //Let's determine the parent's offset
            this.offset = this.element.offset();

            //Initialize mouse events for interaction
            this._mouseInit();

            //We're ready to go
            this.ready = true;

        },

        _destroy: function () {
            this.element
                .removeClass("ui-sortable ui-sortable-disabled");
            this._mouseDestroy();

            for (var i = this.items.length - 1; i >= 0; i--) {
                this.items[i].item.removeData(this.widgetName + "-item");
            }

            return this;
        },

        _setOption: function (key, value) {
            if (key === "disabled") {
                this.options[key] = value;

                this.widget().toggleClass("ui-sortable-disabled", !!value);
            } else {
                // Don't call widget base _setOption for disable as it adds ui-state-disabled class
                $.Widget.prototype._setOption.apply(this, arguments);
            }
        },

        _mouseCapture: function (event, overrideHandle) {
            var currentItem = null,
                validHandle = false,
                that = this;

            if (this.reverting) {
                return false;
            }

            if (this.options.disabled || this.options.type === "static") {
                return false;
            }

            //We have to refresh the items data once first
            this._refreshItems(event);

            //Find out if the clicked node (or one of its parents) is a actual item in this.items
            $(event.target).parents().each(function () {
                if ($.data(this, that.widgetName + "-item") === that) {
                    currentItem = $(this);
                    return false;
                }
            });
            if ($.data(event.target, that.widgetName + "-item") === that) {
                currentItem = $(event.target);
            }

            if (!currentItem) {
                return false;
            }
            if (this.options.handle && !overrideHandle) {
                $(this.options.handle, currentItem).find("*").addBack().each(function () {
                    if (this === event.target) {
                        validHandle = true;
                    }
                });
                if (!validHandle) {
                    return false;
                }
            }

            this.currentItem = currentItem;
            this._removeCurrentsFromItems();
            return true;

        },

        _mouseStart: function (event, overrideHandle, noActivation) {

            var i,
                o = this.options;

            this.currentContainer = this;

            //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
            this.refreshPositions();

            //Create and append the visible helper
            this.helper = this._createHelper(event);

            //Cache the helper size
            this._cacheHelperProportions();

            /*
             * - Position generation -
             * This block generates everything position related - it's the core of draggables.
             */

            //Cache the margins of the original element
            this._cacheMargins();

            //Get the next scrolling parent
            this.scrollParent = this.helper.scrollParent();

            //The element's absolute position on the page minus margins
            this.offset = this.currentItem.offset();
            this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            };

            $.extend(this.offset, {
                click: { //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
            });

            // Only after we got the offset, we can change the helper's position to absolute
            // TODO: Still need to figure out a way to make relative sorting possible
            this.helper.css("position", "absolute");
            this.cssPosition = this.helper.css("position");

            //Generate the original position
            this.originalPosition = this._generatePosition(event);
            this.originalPageX = event.pageX;
            this.originalPageY = event.pageY;

            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

            //Cache the former DOM position
            this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

            //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
            if (this.helper[0] !== this.currentItem[0]) {
                this.currentItem.hide();
            }

            //Create the placeholder
            this._createPlaceholder();

            //Set a containment if given in the options
            if (o.containment) {
                this._setContainment();
            }

            if (o.cursor) { // cursor option
                if ($("body").css("cursor")) {
                    this._storedCursor = $("body").css("cursor");
                }
                $("body").css("cursor", o.cursor);
            }

            if (o.opacity) { // opacity option
                if (this.helper.css("opacity")) {
                    this._storedOpacity = this.helper.css("opacity");
                }
                this.helper.css("opacity", o.opacity);
            }

            if (o.zIndex) { // zIndex option
                if (this.helper.css("zIndex")) {
                    this._storedZIndex = this.helper.css("zIndex");
                }
                this.helper.css("zIndex", o.zIndex);
            }

            //Prepare scrolling
            if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
                this.overflowOffset = this.scrollParent.offset();
            }

            //Call callbacks
            this._trigger("start", event, this._uiHash());

            //Recache the helper size
            if (!this._preserveHelperProportions) {
                this._cacheHelperProportions();
            }


            //Post "activate" events to possible containers
            if (!noActivation) {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("activate", event, this._uiHash(this));
                }
            }

            //Prepare possible droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.current = this;
            }

            if ($.ui.ddmanager && !o.dropBehaviour) {
                $.ui.ddmanager.prepareOffsets(this, event);
            }

            this.dragging = true;

            this.helper.addClass("ui-sortable-helper");
            this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
            return true;

        },

        _mouseDrag: function (event) {
            var i, item, itemElement, intersection,
                o = this.options,
                scrolled = false;

            //Compute the helpers position
            this.position = this._generatePosition(event);
            this.positionAbs = this._convertPositionTo("absolute");

            if (!this.lastPositionAbs) {
                this.lastPositionAbs = this.positionAbs;
            }

            //Do scrolling
            if (this.options.scroll) {
                if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

                    if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
                    } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
                        this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
                    }

                    if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
                    } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
                        this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
                    }

                } else {

                    if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
                    } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
                    }

                    if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
                    } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
                        scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
                    }

                }

                if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
                    $.ui.ddmanager.prepareOffsets(this, event);
                }
            }

            //Regenerate the absolute position used for position checks
            this.positionAbs = this._convertPositionTo("absolute");

            //Set the helper position
            if (!this.options.axis || this.options.axis !== "y") {
                this.helper[0].style.left = this.position.left + "px";
            }
            if (!this.options.axis || this.options.axis !== "x") {
                this.helper[0].style.top = this.position.top + "px";
            }

            //Rearrange
            for (i = this.items.length - 1; i >= 0; i--) {

                //Cache variables and intersection, continue if no intersection
                item = this.items[i];
                itemElement = item.item[0];
                intersection = this._intersectsWithPointer(item);
                if (!intersection) {
                    continue;
                }

                // Only put the placeholder inside the current Container, skip all
                // items form other containers. This works because when moving
                // an item from one container to another the
                // currentContainer is switched before the placeholder is moved.
                //
                // Without this moving items in "sub-sortables" can cause the placeholder to jitter
                // beetween the outer and inner container.
                if (item.instance !== this.currentContainer) {
                    continue;
                }

                // cannot intersect with itself
                // no useless actions that have been done before
                // no action if the item moved is the parent of the item checked
                if (itemElement !== this.currentItem[0] &&
                    this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
                    !$.contains(this.placeholder[0], itemElement) &&
                    (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
                ) {

                    this.direction = intersection === 1 ? "down" : "up";

                    if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
                        this._rearrange(event, item);
                    } else {
                        break;
                    }

                    this._trigger("change", event, this._uiHash());
                    break;
                }
            }

            //Post events to containers
            this._contactContainers(event);

            //Interconnect with droppables
            if ($.ui.ddmanager) {
                $.ui.ddmanager.drag(this, event);
            }

            //Call callbacks
            this._trigger("sort", event, this._uiHash());

            this.lastPositionAbs = this.positionAbs;
            return false;

        },

        _mouseStop: function (event, noPropagation) {

            if (!event) {
                return;
            }

            //If we are using droppables, inform the manager about the drop
            if ($.ui.ddmanager && !this.options.dropBehaviour) {
                $.ui.ddmanager.drop(this, event);
            }

            if (this.options.revert) {
                var that = this,
                    cur = this.placeholder.offset();

                this.reverting = true;

                $(this.helper).animate({
                    left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft),
                    top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop)
                }, parseInt(this.options.revert, 10) || 500, function () {
                    that._clear(event);
                });
            } else {
                this._clear(event, noPropagation);
            }

            return false;

        },

        cancel: function () {

            if (this.dragging) {

                this._mouseUp({ target: null });

                if (this.options.helper === "original") {
                    this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
                } else {
                    this.currentItem.show();
                }

                //Post deactivating events to containers
                for (var i = this.containers.length - 1; i >= 0; i--) {
                    this.containers[i]._trigger("deactivate", null, this._uiHash(this));
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", null, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            if (this.placeholder) {
                //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
                if (this.placeholder[0].parentNode) {
                    this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
                }
                if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
                    this.helper.remove();
                }

                $.extend(this, {
                    helper: null,
                    dragging: false,
                    reverting: false,
                    _noFinalSort: null
                });

                if (this.domPosition.prev) {
                    $(this.domPosition.prev).after(this.currentItem);
                } else {
                    $(this.domPosition.parent).prepend(this.currentItem);
                }
            }

            return this;

        },

        serialize: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                str = [];
            o = o || {};

            $(items).each(function () {
                var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
                if (res) {
                    str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
                }
            });

            if (!str.length && o.key) {
                str.push(o.key + "=");
            }

            return str.join("&");

        },

        toArray: function (o) {

            var items = this._getItemsAsjQuery(o && o.connected),
                ret = [];

            o = o || {};

            items.each(function () { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
            return ret;

        },

        /* Be careful with the following core functions */
        _intersectsWith: function (item) {

            var x1 = this.positionAbs.left,
                x2 = x1 + this.helperProportions.width,
                y1 = this.positionAbs.top,
                y2 = y1 + this.helperProportions.height,
                l = item.left,
                r = l + item.width,
                t = item.top,
                b = t + item.height,
                dyClick = this.offset.click.top,
                dxClick = this.offset.click.left,
                isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

            if (this.options.tolerance === "pointer" ||
                this.options.forcePointerForContainers ||
                (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
            ) {
                return isOverElement;
            } else {

                return (l < x1 + (this.helperProportions.width / 2) && // Right Half
                    x2 - (this.helperProportions.width / 2) < r && // Left Half
                    t < y1 + (this.helperProportions.height / 2) && // Bottom Half
                    y2 - (this.helperProportions.height / 2) < b); // Top Half

            }
        },

        _intersectsWithPointer: function (item) {

            var isOverElementHeight = (this.options.axis === "x") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
                isOverElementWidth = (this.options.axis === "y") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
                isOverElement = isOverElementHeight && isOverElementWidth,
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (!isOverElement) {
                return false;
            }

            return this.floating ?
                (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1)
                : (verticalDirection && (verticalDirection === "down" ? 2 : 1));

        },

        _intersectsWithSides: function (item) {

            var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
                isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
                verticalDirection = this._getDragVerticalDirection(),
                horizontalDirection = this._getDragHorizontalDirection();

            if (this.floating && horizontalDirection) {
                return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
            } else {
                return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
            }

        },

        _getDragVerticalDirection: function () {
            var delta = this.positionAbs.top - this.lastPositionAbs.top;
            return delta !== 0 && (delta > 0 ? "down" : "up");
        },

        _getDragHorizontalDirection: function () {
            var delta = this.positionAbs.left - this.lastPositionAbs.left;
            return delta !== 0 && (delta > 0 ? "right" : "left");
        },

        refresh: function (event) {
            this._refreshItems(event);
            this.refreshPositions();
            return this;
        },

        _connectWith: function () {
            var options = this.options;
            return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
        },

        _getItemsAsjQuery: function (connected) {

            var i, j, cur, inst,
                items = [],
                queries = [],
                connectWith = this._connectWith();

            if (connectWith && connected) {
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
                        }
                    }
                }
            }

            queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

            for (i = queries.length - 1; i >= 0; i--) {
                queries[i][0].each(function () {
                    items.push(this);
                });
            }

            return $(items);

        },

        _removeCurrentsFromItems: function () {

            var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

            this.items = $.grep(this.items, function (item) {
                for (var j = 0; j < list.length; j++) {
                    if (list[j] === item.item[0]) {
                        return false;
                    }
                }
                return true;
            });

        },

        _refreshItems: function (event) {

            this.items = [];
            this.containers = [this];

            var i, j, cur, inst, targetData, _queries, item, queriesLength,
                items = this.items,
                queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
                connectWith = this._connectWith();

            if (connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
                for (i = connectWith.length - 1; i >= 0; i--) {
                    cur = $(connectWith[i]);
                    for (j = cur.length - 1; j >= 0; j--) {
                        inst = $.data(cur[j], this.widgetFullName);
                        if (inst && inst !== this && !inst.options.disabled) {
                            queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
                            this.containers.push(inst);
                        }
                    }
                }
            }

            for (i = queries.length - 1; i >= 0; i--) {
                targetData = queries[i][1];
                _queries = queries[i][0];

                for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
                    item = $(_queries[j]);

                    item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

                    items.push({
                        item: item,
                        instance: targetData,
                        width: 0, height: 0,
                        left: 0, top: 0
                    });
                }
            }

        },

        refreshPositions: function (fast) {

            //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
            if (this.offsetParent && this.helper) {
                this.offset.parent = this._getParentOffset();
            }

            var i, item, t, p;

            for (i = this.items.length - 1; i >= 0; i--) {
                item = this.items[i];

                //We ignore calculating positions of all connected containers when we're not over them
                if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
                    continue;
                }

                t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

                if (!fast) {
                    item.width = t.outerWidth();
                    item.height = t.outerHeight();
                }

                p = t.offset();
                item.left = p.left;
                item.top = p.top;
            }

            if (this.options.custom && this.options.custom.refreshContainers) {
                this.options.custom.refreshContainers.call(this);
            } else {
                for (i = this.containers.length - 1; i >= 0; i--) {
                    p = this.containers[i].element.offset();
                    this.containers[i].containerCache.left = p.left;
                    this.containers[i].containerCache.top = p.top;
                    this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
                    this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
                }
            }

            return this;
        },

        _createPlaceholder: function (that) {
            that = that || this;
            var className,
                o = that.options;

            if (!o.placeholder || o.placeholder.constructor === String) {
                className = o.placeholder;
                o.placeholder = {
                    element: function () {

                        var el = $(document.createElement(that.currentItem[0].nodeName))
                            .addClass(className || that.currentItem[0].className + " ui-sortable-placeholder")
                            .removeClass("ui-sortable-helper")[0];

                        if (!className) {
                            el.style.visibility = "hidden";
                        }

                        return el;
                    },
                    update: function (container, p) {

                        // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
                        // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
                        if (className && !o.forcePlaceholderSize) {
                            return;
                        }

                        //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
                        if (!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10)); }
                        if (!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10)); }
                    }
                };
            }

            //Create the placeholder
            that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

            //Append it after the actual current item
            that.currentItem.after(that.placeholder);

            //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
            o.placeholder.update(that, that.placeholder);

        },

        _contactContainers: function (event) {
            var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom,
                innermostContainer = null,
                innermostIndex = null;

            // get innermost container that intersects with item
            for (i = this.containers.length - 1; i >= 0; i--) {

                // never consider a container that's located within the item itself
                if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
                    continue;
                }

                if (this._intersectsWith(this.containers[i].containerCache)) {

                    // if we've already found a container and it's more "inner" than this, then continue
                    if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
                        continue;
                    }

                    innermostContainer = this.containers[i];
                    innermostIndex = i;

                } else {
                    // container doesn't intersect. trigger "out" event if necessary
                    if (this.containers[i].containerCache.over) {
                        this.containers[i]._trigger("out", event, this._uiHash(this));
                        this.containers[i].containerCache.over = 0;
                    }
                }

            }

            // if no intersecting containers found, return
            if (!innermostContainer) {
                return;
            }

            // move the item into the container if it's not there already
            if (this.containers.length === 1) {
                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            } else {

                //When entering a new container, we will find the item with the least distance and append our item near it
                dist = 10000;
                itemWithLeastDistance = null;
                posProperty = this.containers[innermostIndex].floating ? "left" : "top";
                sizeProperty = this.containers[innermostIndex].floating ? "width" : "height";
                base = this.positionAbs[posProperty] + this.offset.click[posProperty];
                for (j = this.items.length - 1; j >= 0; j--) {
                    if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
                        continue;
                    }
                    if (this.items[j].item[0] === this.currentItem[0]) {
                        continue;
                    }
                    cur = this.items[j].item.offset()[posProperty];
                    nearBottom = false;
                    if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
                        nearBottom = true;
                        cur += this.items[j][sizeProperty];
                    }

                    if (Math.abs(cur - base) < dist) {
                        dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
                        this.direction = nearBottom ? "up" : "down";
                    }
                }

                //Check if dropOnEmpty is enabled
                if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
                    return;
                }

                this.currentContainer = this.containers[innermostIndex];
                itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
                this._trigger("change", event, this._uiHash());
                this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

                //Update the placeholder
                this.options.placeholder.update(this.currentContainer, this.placeholder);

                this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
                this.containers[innermostIndex].containerCache.over = 1;
            }


        },

        _createHelper: function (event) {

            var o = this.options,
                helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

            //Add the helper to the DOM if that didn't happen already
            if (!helper.parents("body").length) {
                $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
            }

            if (helper[0] === this.currentItem[0]) {
                this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
            }

            if (!helper[0].style.width || o.forceHelperSize) {
                helper.width(this.currentItem.width());
            }
            if (!helper[0].style.height || o.forceHelperSize) {
                helper.height(this.currentItem.height());
            }

            return helper;

        },

        _adjustOffsetFromHelper: function (obj) {
            if (typeof obj === "string") {
                obj = obj.split(" ");
            }
            if ($.isArray(obj)) {
                obj = { left: +obj[0], top: +obj[1] || 0 };
            }
            if ("left" in obj) {
                this.offset.click.left = obj.left + this.margins.left;
            }
            if ("right" in obj) {
                this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
            }
            if ("top" in obj) {
                this.offset.click.top = obj.top + this.margins.top;
            }
            if ("bottom" in obj) {
                this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
            }
        },

        _getParentOffset: function () {


            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();

            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
                po.left += this.scrollParent.scrollLeft();
                po.top += this.scrollParent.scrollTop();
            }

            // This needs to be actually done for all browsers, since pageX/pageY includes this information
            // with an ugly IE fix
            if (this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
                po = { top: 0, left: 0 };
            }

            return {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };

        },

        _getRelativeOffset: function () {

            if (this.cssPosition === "relative") {
                var p = this.currentItem.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            } else {
                return { top: 0, left: 0 };
            }

        },

        _cacheMargins: function () {
            this.margins = {
                left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
                top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
            };
        },

        _cacheHelperProportions: function () {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },

        _setContainment: function () {

            var ce, co, over,
                o = this.options;
            if (o.containment === "parent") {
                o.containment = this.helper[0].parentNode;
            }
            if (o.containment === "document" || o.containment === "window") {
                this.containment = [
                    0 - this.offset.relative.left - this.offset.parent.left,
                    0 - this.offset.relative.top - this.offset.parent.top,
                    $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
                    ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
                ];
            }

            if (!(/^(document|window|parent)$/).test(o.containment)) {
                ce = $(o.containment)[0];
                co = $(o.containment).offset();
                over = ($(ce).css("overflow") !== "hidden");

                this.containment = [
                    co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
                    co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
                    co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left,
                    co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top
                ];
            }

        },

        _convertPositionTo: function (d, pos) {

            if (!pos) {
                pos = this.position;
            }
            var mod = d === "absolute" ? 1 : -1,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            return {
                top: (
                    pos.top +																// The absolute mouse position
                    this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)
                ),
                left: (
                    pos.left +																// The absolute mouse position
                    this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left * mod -										// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod)
                )
            };

        },

        _generatePosition: function (event) {

            var top, left,
                o = this.options,
                pageX = event.pageX,
                pageY = event.pageY,
                scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

            // This is another very weird special case that only happens for relative elements:
            // 1. If the css position is relative
            // 2. and the scroll parent is the document or similar to the offset parent
            // we have to refresh the relative offset during the scroll so there are no jumps
            if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
                this.offset.relative = this._getRelativeOffset();
            }

            /*
             * - Position constraining -
             * Constrain the position to a mix of grid, containment.
             */

            if (this.originalPosition) { //If we are not dragging yet, we won't check for options

                if (this.containment) {
                    if (event.pageX - this.offset.click.left < this.containment[0]) {
                        pageX = this.containment[0] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top < this.containment[1]) {
                        pageY = this.containment[1] + this.offset.click.top;
                    }
                    if (event.pageX - this.offset.click.left > this.containment[2]) {
                        pageX = this.containment[2] + this.offset.click.left;
                    }
                    if (event.pageY - this.offset.click.top > this.containment[3]) {
                        pageY = this.containment[3] + this.offset.click.top;
                    }
                }

                if (o.grid) {
                    top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
                    pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

                    left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
                    pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
                }

            }

            return {
                top: (
                    pageY -																// The absolute mouse position
                    this.offset.click.top -													// Click offset (relative to the element)
                    this.offset.relative.top -											// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))
                ),
                left: (
                    pageX -																// The absolute mouse position
                    this.offset.click.left -												// Click offset (relative to the element)
                    this.offset.relative.left -											// Only for relative positioned nodes: Relative offset from element to offset parent
                    this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
                    ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()))
                )
            };

        },

        _rearrange: function (event, i, a, hardRefresh) {

            a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

            //Various things done here to improve the performance:
            // 1. we create a setTimeout, that calls refreshPositions
            // 2. on the instance, we have a counter variable, that get's higher after every append
            // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
            // 4. this lets only the last addition to the timeout stack through
            this.counter = this.counter ? ++this.counter : 1;
            var counter = this.counter;

            this._delay(function () {
                if (counter === this.counter) {
                    this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
                }
            });

        },

        _clear: function (event, noPropagation) {

            this.reverting = false;
            // We delay all events that have to be triggered to after the point where the placeholder has been removed and
            // everything else normalized again
            var i,
                delayedTriggers = [];

            // We first have to update the dom position of the actual currentItem
            // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
            if (!this._noFinalSort && this.currentItem.parent().length) {
                this.placeholder.before(this.currentItem);
            }
            this._noFinalSort = null;

            if (this.helper[0] === this.currentItem[0]) {
                for (i in this._storedCSS) {
                    if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
                        this._storedCSS[i] = "";
                    }
                }
                this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
            } else {
                this.currentItem.show();
            }

            if (this.fromOutside && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
            }
            if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
                delayedTriggers.push(function (event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
            }

            // Check if the items Container has Changed and trigger appropriate
            // events.
            if (this !== this.currentContainer) {
                if (!noPropagation) {
                    delayedTriggers.push(function (event) { this._trigger("remove", event, this._uiHash()); });
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("receive", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("update", event, this._uiHash(this)); }; }).call(this, this.currentContainer));
                }
            }


            //Post events to containers
            for (i = this.containers.length - 1; i >= 0; i--) {
                if (!noPropagation) {
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("deactivate", event, this._uiHash(this)); }; }).call(this, this.containers[i]));
                }
                if (this.containers[i].containerCache.over) {
                    delayedTriggers.push((function (c) { return function (event) { c._trigger("out", event, this._uiHash(this)); }; }).call(this, this.containers[i]));
                    this.containers[i].containerCache.over = 0;
                }
            }

            //Do what was originally in plugins
            if (this._storedCursor) {
                $("body").css("cursor", this._storedCursor);
            }
            if (this._storedOpacity) {
                this.helper.css("opacity", this._storedOpacity);
            }
            if (this._storedZIndex) {
                this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
            }

            this.dragging = false;
            if (this.cancelHelperRemoval) {
                if (!noPropagation) {
                    this._trigger("beforeStop", event, this._uiHash());
                    for (i = 0; i < delayedTriggers.length; i++) {
                        delayedTriggers[i].call(this, event);
                    } //Trigger all delayed events
                    this._trigger("stop", event, this._uiHash());
                }

                this.fromOutside = false;
                return false;
            }

            if (!noPropagation) {
                this._trigger("beforeStop", event, this._uiHash());
            }

            //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

            if (this.helper[0] !== this.currentItem[0]) {
                this.helper.remove();
            }
            this.helper = null;

            if (!noPropagation) {
                for (i = 0; i < delayedTriggers.length; i++) {
                    delayedTriggers[i].call(this, event);
                } //Trigger all delayed events
                this._trigger("stop", event, this._uiHash());
            }

            this.fromOutside = false;
            return true;

        },

        _trigger: function () {
            if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
                this.cancel();
            }
        },

        _uiHash: function (_inst) {
            var inst = _inst || this;
            return {
                helper: inst.helper,
                placeholder: inst.placeholder || $([]),
                position: inst.position,
                originalPosition: inst.originalPosition,
                offset: inst.positionAbs,
                item: inst.currentItem,
                sender: _inst ? _inst.element : null
            };
        }

    });

})(jQuery);
define("jqueryuiSortable", ["jquery"], function(){});


/*global define, requirejs*/
/*jslint browser: true*/
define('CartApp', ['jquery', 'knockout', 'CartModel', 'mediator-js', 'underscore', 'Utility', 'PerfectScrollbar', 'Toastr', 'CoreApp', 'typeahead', 'jqueryHighlight', 'jqueryuiSortable', 'bootstrapTabdrop'],
    function ($, ko, CartModelFactory, mediator, _, utility, PerfectScrollbar, toastr) {
        "use strict";
        return {
            init: function (cartMode, model) {                
                $(function () {
                    if (model === undefined) {
                        model = new CartModelFactory(cartMode);
                    }

                    var cartModel = model;
                    var quickAddModel, $input, ajdustQuckAddVisibility, showPopover, addProductPopoverScroll, searchItemsScroll, focusInputOnClose,
                        actionsContainerScroll, itemsSearchModel, searchInput, ajdustItemsSearchVisibility, showItemsSearchPopover;

                    $input = $("#quickAddInput");

                    showPopover = function () {
                        $input.popover('show');
                        addProductPopoverScroll = new PerfectScrollbar('.add-product .popover', { suppressScrollX: true });
                    };

                    mediator.subscribe("CartQuickAddModel.quickAddLoaded", function () {
                        $('.add-product .popover').scrollTop(0);
                        utility.makeHomeEndKeysAccessible('.catalog-table', true);
                        if (addProductPopoverScroll) {
                            addProductPopoverScroll.update();
                        }
                    });

                    $('#quickAddInput').on('keydown', function () {
                        if (event.key === "Tab") {
                            utility.makeFocusTrap('.add-product .popover');
                            $('.add-product .popover').bind('keydown', {}, focusInputOnClose);
                        }
                    });

                    focusInputOnClose = function (event) {
                        if (event.key === "Escape" || event.key === "Esc") {
                            $("#quickAddInput").focus();
                            $('.add-product .popover').unbind('keydown', focusInputOnClose);
                        }
                    }

                    ajdustQuckAddVisibility = function () {
                        if (quickAddModel.quickAddSearchThrottled().length > 0) {
                            if (quickAddModel.quickAddHasFocus() && !$input.hasPopover()) {
                                showPopover(); // if not shown and has text and focus, show it
                            }
                        } else {
                            // hide if shown
                            if ($input.hasPopover()) {
                                $input.hidePopover();
                            }
                        }
                    };

                    quickAddModel = cartModel.quickAdd;
                    quickAddModel.quickAddSearchThrottled.subscribe(ajdustQuckAddVisibility);
                    quickAddModel.quickAddHasFocus.subscribe(ajdustQuckAddVisibility);

                    searchInput = function () {
                        if (cartModel.isMobile()) {
                            return $("#searchInput1");
                        } else {
                            return $("#searchInput2");
                        }
                    }

                    showItemsSearchPopover = function () {
                        searchInput().popover('show');

                        var searchItemsPopover = document.querySelector('.search-items .popover');
                        if (searchItemsPopover) {
                            searchItemsScroll = new PerfectScrollbar('.search-items .popover', { suppressScrollX: true });
                            searchItemsPopover.highlight(cartModel.itemsSearch.search());
                        };

                        var itemsSectionPopover = document.querySelector('#items-section .popover');
                        if (itemsSectionPopover) {
                            new PerfectScrollbar(itemsSectionPopover, { supressScrollX: true });
                        };
                    };

                    mediator.subscribe("CartQuickAddModel.searchItemsLoaded", function () {
                        var searchItems = $('.search-items .popover');

                        if (searchItems.length) {
                            searchItems.scrollTop(0);
                            searchItemsScroll.update();
                            searchItems.highlight(cartModel.itemsSearch.search());
                        };
                    });

                    ajdustItemsSearchVisibility = function () {
                        if (itemsSearchModel.searchThrottled().length > 0) {
                            if (!searchInput().hasPopover()) {
                                showItemsSearchPopover(); // if not shown and has text and focus, show it
                            }
                        } else {
                            // hide if shown
                            if (searchInput().hasPopover()) {
                                searchInput().hidePopover();
                            }
                        }
                    };

                    itemsSearchModel = cartModel.itemsSearch;
                    itemsSearchModel.searchThrottled.subscribe(ajdustItemsSearchVisibility);
                    itemsSearchModel.hasFocus.subscribe(ajdustItemsSearchVisibility);

                    mediator.subscribe("CartModel.dataRefreshed", function () {
                        if ($('#actionsContainer').length) {
                            actionsContainerScroll.update();
                        }

                        $('.item-description').each(function (index, element) {
                            if (element.offsetHeight < element.scrollHeight
                                || element.offsetWidth < element.scrollWidth) {
                                // if description has overflow (not whole content is visible)
                                // show icon and add whole popover to content
                                $(element).next().show();
                            }
                        });
                    });

                    mediator.subscribe("CartModel.itemsPaged", function () {
                        var $el = $("#items-section table");
                        if ($el.length && !utility.isElementTopVisible($el.get(0))) {
                            // scroll to the top of the table but only if we found table by above selector
                            // it won't work if someone altered "items-section" is using customization
                            // so we this condition we are just avoiding script breaking
                            // we also won't scroll if table top is already visible, it would just cause unnecessary screen jumping
                            var elemTop = $el.offset().top;
                            $(window).scrollTop(elemTop);
                        }
                    });


                   
                    mediator.subscribe("CartTabs.TabChanged", function (url) {
                        if (model.saveOnTabChange && model.areCustomFieldsDirty()) {
                            model.saveCustomFields(function (serverData) {
                                if (!serverData.ErrorMessage) {
                                    window.location.href = url;
                                } else {
                                    toastr.error(serverData.ErrorMessage);
                                }
                            });
                        } else {
                            window.location.href = url;
                        }
                    });
                    
                    $(window).on('beforeunload', function () {
                        if ((!cartModel.saveOnTabChange && cartModel.isDirty()) || cartModel.areCellsDirty()) {
                            return cartModel.unsavedChangesMsg;
                        }
                    });

                    $('.affix-top').affix({ offset: { top: 50 } });

                    function renderMoreIfNeeded() {
                        var elem = document.getElementById('itemsLoadingIndicator');
                        if (utility.isWholeElementVisible(elem)) {
                            cartModel.renderMoreItems();

                            // recheck if more items should be rendered
                            // we use timeout to be use rendering is finished by browser
                            setTimeout(renderMoreIfNeeded, 1);
                        }
                    }

                    ko.applyBindings(cartModel, document.getElementById("cartContainer"));

                    // for backward compatibility
                    window.addEventListener('scroll', _.throttle(renderMoreIfNeeded, 300));

                    // plain JS because of Edge
                    document.getElementsByTagName('body')[0].addEventListener('scroll', _.throttle(renderMoreIfNeeded, 300));

                    // after model binding and rendering is done check if more items need to be rendered
                    setTimeout(renderMoreIfNeeded, 1);

                    mediator.subscribe("CartModel.itemsLoaded", function (cartItem) {
                        var $el = $('.isSearchMatch');
                        if ($el.length === 0) {
                            return; // if no element found
                        }

                        // scroll if needed
                        if (!utility.isWholeElementVisible($el.get(0))) {
                            var elemTop = $el.offset().top;
                            var elemBottom = elemTop + $el.height();
                            $(window).scrollTop(elemBottom - $(window).height());
                        }

                        // highlight
                        $el.addClass('highlight-row');

                        setTimeout(function () {
                            $el.removeClass('highlight-row');
                        }, 3000);

                        if ($('#actionsContainer').length) {
                            actionsContainerScroll = new PerfectScrollbar('#actionsContainer', { suppressScrollX: true });
                        };
                    });

                    $('#itemsTable').sortable({
                        handle: ".handle",
                        helper: function (e, ui) { //It helps to all colon to stay the same size when one row is dragged
                            ui.children().each(function () {
                                $(this).width($(this).width());
                            });
                            return ui;
                        },
                        stop: function (event, ui) {
                            var item = ko.dataFor(ui.item[0]);
                            var upItem = undefined;
                            if (ui.item[0].previousElementSibling !== null) {
                                upItem = ko.dataFor(ui.item[0].previousElementSibling);
                            }
                            item.moveToPosition(upItem);
                        }
                    });
                });
            }
        };
    }
);

